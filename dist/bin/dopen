#!/usr/bin/env node
import require$$4, { createRequire } from "node:module";
import process$1, { argv, cwd, env } from "node:process";
import { PassThrough, Stream } from "node:stream";
import require$$0 from "url";
import os, { homedir } from "node:os";
import tty from "node:tty";
import { EventEmitter } from "node:events";
import * as fs$1 from "node:fs";
import fs, { accessSync, constants } from "node:fs";
import path, { join } from "node:path";
import { access, constants as constants$1, mkdir, readFile, stat, writeFile } from "node:fs/promises";
import { execSync, spawn } from "node:child_process";
import { randomUUID } from "node:crypto";
import { createServer } from "node:net";
import require$$0$1, { format } from "util";
import { normalize, resolve } from "path";
import { readFileSync } from "fs";
import require$$0$2, { fileURLToPath } from "node:url";

//#region rolldown:runtime
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __esm = (fn, res) => function() {
	return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __commonJS = (cb, mod) => function() {
	return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __copyProps = (to, from, except, desc) => {
	if (from && typeof from === "object" || typeof from === "function") for (var keys = __getOwnPropNames(from), i = 0, n = keys.length, key; i < n; i++) {
		key = keys[i];
		if (!__hasOwnProp.call(to, key) && key !== except) __defProp(to, key, {
			get: ((k) => from[k]).bind(null, key),
			enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable
		});
	}
	return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", {
	value: mod,
	enumerable: true
}) : target, mod));
var __require = /* @__PURE__ */ createRequire(import.meta.url);

//#endregion
//#region node_modules/react/cjs/react.production.js
var require_react_production = /* @__PURE__ */ __commonJS({ "node_modules/react/cjs/react.production.js": ((exports) => {
	var REACT_ELEMENT_TYPE$1 = Symbol.for("react.transitional.element"), REACT_PORTAL_TYPE = Symbol.for("react.portal"), REACT_FRAGMENT_TYPE$1 = Symbol.for("react.fragment"), REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode"), REACT_PROFILER_TYPE = Symbol.for("react.profiler"), REACT_CONSUMER_TYPE = Symbol.for("react.consumer"), REACT_CONTEXT_TYPE = Symbol.for("react.context"), REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref"), REACT_SUSPENSE_TYPE = Symbol.for("react.suspense"), REACT_MEMO_TYPE = Symbol.for("react.memo"), REACT_LAZY_TYPE = Symbol.for("react.lazy"), REACT_ACTIVITY_TYPE = Symbol.for("react.activity"), MAYBE_ITERATOR_SYMBOL = Symbol.iterator;
	function getIteratorFn(maybeIterable) {
		if (null === maybeIterable || "object" !== typeof maybeIterable) return null;
		maybeIterable = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable["@@iterator"];
		return "function" === typeof maybeIterable ? maybeIterable : null;
	}
	var ReactNoopUpdateQueue = {
		isMounted: function() {
			return !1;
		},
		enqueueForceUpdate: function() {},
		enqueueReplaceState: function() {},
		enqueueSetState: function() {}
	}, assign = Object.assign, emptyObject = {};
	function Component(props, context, updater) {
		this.props = props;
		this.context = context;
		this.refs = emptyObject;
		this.updater = updater || ReactNoopUpdateQueue;
	}
	Component.prototype.isReactComponent = {};
	Component.prototype.setState = function(partialState, callback) {
		if ("object" !== typeof partialState && "function" !== typeof partialState && null != partialState) throw Error("takes an object of state variables to update or a function which returns an object of state variables.");
		this.updater.enqueueSetState(this, partialState, callback, "setState");
	};
	Component.prototype.forceUpdate = function(callback) {
		this.updater.enqueueForceUpdate(this, callback, "forceUpdate");
	};
	function ComponentDummy() {}
	ComponentDummy.prototype = Component.prototype;
	function PureComponent$1(props, context, updater) {
		this.props = props;
		this.context = context;
		this.refs = emptyObject;
		this.updater = updater || ReactNoopUpdateQueue;
	}
	var pureComponentPrototype = PureComponent$1.prototype = new ComponentDummy();
	pureComponentPrototype.constructor = PureComponent$1;
	assign(pureComponentPrototype, Component.prototype);
	pureComponentPrototype.isPureReactComponent = !0;
	var isArrayImpl = Array.isArray;
	function noop$1() {}
	var ReactSharedInternals = {
		H: null,
		A: null,
		T: null,
		S: null
	}, hasOwnProperty = Object.prototype.hasOwnProperty;
	function ReactElement(type, key, props) {
		var refProp = props.ref;
		return {
			$$typeof: REACT_ELEMENT_TYPE$1,
			type,
			key,
			ref: void 0 !== refProp ? refProp : null,
			props
		};
	}
	function cloneAndReplaceKey(oldElement, newKey) {
		return ReactElement(oldElement.type, newKey, oldElement.props);
	}
	function isValidElement(object) {
		return "object" === typeof object && null !== object && object.$$typeof === REACT_ELEMENT_TYPE$1;
	}
	function escape$1(key) {
		var escaperLookup = {
			"=": "=0",
			":": "=2"
		};
		return "$" + key.replace(/[=:]/g, function(match) {
			return escaperLookup[match];
		});
	}
	var userProvidedKeyEscapeRegex = /\/+/g;
	function getElementKey(element, index) {
		return "object" === typeof element && null !== element && null != element.key ? escape$1("" + element.key) : index.toString(36);
	}
	function resolveThenable(thenable) {
		switch (thenable.status) {
			case "fulfilled": return thenable.value;
			case "rejected": throw thenable.reason;
			default: switch ("string" === typeof thenable.status ? thenable.then(noop$1, noop$1) : (thenable.status = "pending", thenable.then(function(fulfilledValue) {
				"pending" === thenable.status && (thenable.status = "fulfilled", thenable.value = fulfilledValue);
			}, function(error) {
				"pending" === thenable.status && (thenable.status = "rejected", thenable.reason = error);
			})), thenable.status) {
				case "fulfilled": return thenable.value;
				case "rejected": throw thenable.reason;
			}
		}
		throw thenable;
	}
	function mapIntoArray(children, array, escapedPrefix, nameSoFar, callback) {
		var type = typeof children;
		if ("undefined" === type || "boolean" === type) children = null;
		var invokeCallback = !1;
		if (null === children) invokeCallback = !0;
		else switch (type) {
			case "bigint":
			case "string":
			case "number":
				invokeCallback = !0;
				break;
			case "object": switch (children.$$typeof) {
				case REACT_ELEMENT_TYPE$1:
				case REACT_PORTAL_TYPE:
					invokeCallback = !0;
					break;
				case REACT_LAZY_TYPE: return invokeCallback = children._init, mapIntoArray(invokeCallback(children._payload), array, escapedPrefix, nameSoFar, callback);
			}
		}
		if (invokeCallback) return callback = callback(children), invokeCallback = "" === nameSoFar ? "." + getElementKey(children, 0) : nameSoFar, isArrayImpl(callback) ? (escapedPrefix = "", null != invokeCallback && (escapedPrefix = invokeCallback.replace(userProvidedKeyEscapeRegex, "$&/") + "/"), mapIntoArray(callback, array, escapedPrefix, "", function(c) {
			return c;
		})) : null != callback && (isValidElement(callback) && (callback = cloneAndReplaceKey(callback, escapedPrefix + (null == callback.key || children && children.key === callback.key ? "" : ("" + callback.key).replace(userProvidedKeyEscapeRegex, "$&/") + "/") + invokeCallback)), array.push(callback)), 1;
		invokeCallback = 0;
		var nextNamePrefix = "" === nameSoFar ? "." : nameSoFar + ":";
		if (isArrayImpl(children)) for (var i = 0; i < children.length; i++) nameSoFar = children[i], type = nextNamePrefix + getElementKey(nameSoFar, i), invokeCallback += mapIntoArray(nameSoFar, array, escapedPrefix, type, callback);
		else if (i = getIteratorFn(children), "function" === typeof i) for (children = i.call(children), i = 0; !(nameSoFar = children.next()).done;) nameSoFar = nameSoFar.value, type = nextNamePrefix + getElementKey(nameSoFar, i++), invokeCallback += mapIntoArray(nameSoFar, array, escapedPrefix, type, callback);
		else if ("object" === type) {
			if ("function" === typeof children.then) return mapIntoArray(resolveThenable(children), array, escapedPrefix, nameSoFar, callback);
			array = String(children);
			throw Error("Objects are not valid as a React child (found: " + ("[object Object]" === array ? "object with keys {" + Object.keys(children).join(", ") + "}" : array) + "). If you meant to render a collection of children, use an array instead.");
		}
		return invokeCallback;
	}
	function mapChildren(children, func, context) {
		if (null == children) return children;
		var result = [], count = 0;
		mapIntoArray(children, result, "", "", function(child) {
			return func.call(context, child, count++);
		});
		return result;
	}
	function lazyInitializer(payload) {
		if (-1 === payload._status) {
			var ctor = payload._result;
			ctor = ctor();
			ctor.then(function(moduleObject) {
				if (0 === payload._status || -1 === payload._status) payload._status = 1, payload._result = moduleObject;
			}, function(error) {
				if (0 === payload._status || -1 === payload._status) payload._status = 2, payload._result = error;
			});
			-1 === payload._status && (payload._status = 0, payload._result = ctor);
		}
		if (1 === payload._status) return payload._result.default;
		throw payload._result;
	}
	var reportGlobalError = "function" === typeof reportError ? reportError : function(error) {
		if ("object" === typeof window && "function" === typeof window.ErrorEvent) {
			var event = new window.ErrorEvent("error", {
				bubbles: !0,
				cancelable: !0,
				message: "object" === typeof error && null !== error && "string" === typeof error.message ? String(error.message) : String(error),
				error
			});
			if (!window.dispatchEvent(event)) return;
		} else if ("object" === typeof process && "function" === typeof process.emit) {
			process.emit("uncaughtException", error);
			return;
		}
		console.error(error);
	}, Children = {
		map: mapChildren,
		forEach: function(children, forEachFunc, forEachContext) {
			mapChildren(children, function() {
				forEachFunc.apply(this, arguments);
			}, forEachContext);
		},
		count: function(children) {
			var n = 0;
			mapChildren(children, function() {
				n++;
			});
			return n;
		},
		toArray: function(children) {
			return mapChildren(children, function(child) {
				return child;
			}) || [];
		},
		only: function(children) {
			if (!isValidElement(children)) throw Error("React.Children.only expected to receive a single React element child.");
			return children;
		}
	};
	exports.Activity = REACT_ACTIVITY_TYPE;
	exports.Children = Children;
	exports.Component = Component;
	exports.Fragment = REACT_FRAGMENT_TYPE$1;
	exports.Profiler = REACT_PROFILER_TYPE;
	exports.PureComponent = PureComponent$1;
	exports.StrictMode = REACT_STRICT_MODE_TYPE;
	exports.Suspense = REACT_SUSPENSE_TYPE;
	exports.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE = ReactSharedInternals;
	exports.__COMPILER_RUNTIME = {
		__proto__: null,
		c: function(size) {
			return ReactSharedInternals.H.useMemoCache(size);
		}
	};
	exports.cache = function(fn) {
		return function() {
			return fn.apply(null, arguments);
		};
	};
	exports.cacheSignal = function() {
		return null;
	};
	exports.cloneElement = function(element, config, children) {
		if (null === element || void 0 === element) throw Error("The argument must be a React element, but you passed " + element + ".");
		var props = assign({}, element.props), key = element.key;
		if (null != config) for (propName in void 0 !== config.key && (key = "" + config.key), config) !hasOwnProperty.call(config, propName) || "key" === propName || "__self" === propName || "__source" === propName || "ref" === propName && void 0 === config.ref || (props[propName] = config[propName]);
		var propName = arguments.length - 2;
		if (1 === propName) props.children = children;
		else if (1 < propName) {
			for (var childArray = Array(propName), i = 0; i < propName; i++) childArray[i] = arguments[i + 2];
			props.children = childArray;
		}
		return ReactElement(element.type, key, props);
	};
	exports.createContext = function(defaultValue) {
		defaultValue = {
			$$typeof: REACT_CONTEXT_TYPE,
			_currentValue: defaultValue,
			_currentValue2: defaultValue,
			_threadCount: 0,
			Provider: null,
			Consumer: null
		};
		defaultValue.Provider = defaultValue;
		defaultValue.Consumer = {
			$$typeof: REACT_CONSUMER_TYPE,
			_context: defaultValue
		};
		return defaultValue;
	};
	exports.createElement = function(type, config, children) {
		var propName, props = {}, key = null;
		if (null != config) for (propName in void 0 !== config.key && (key = "" + config.key), config) hasOwnProperty.call(config, propName) && "key" !== propName && "__self" !== propName && "__source" !== propName && (props[propName] = config[propName]);
		var childrenLength = arguments.length - 2;
		if (1 === childrenLength) props.children = children;
		else if (1 < childrenLength) {
			for (var childArray = Array(childrenLength), i = 0; i < childrenLength; i++) childArray[i] = arguments[i + 2];
			props.children = childArray;
		}
		if (type && type.defaultProps) for (propName in childrenLength = type.defaultProps, childrenLength) void 0 === props[propName] && (props[propName] = childrenLength[propName]);
		return ReactElement(type, key, props);
	};
	exports.createRef = function() {
		return { current: null };
	};
	exports.forwardRef = function(render$1) {
		return {
			$$typeof: REACT_FORWARD_REF_TYPE,
			render: render$1
		};
	};
	exports.isValidElement = isValidElement;
	exports.lazy = function(ctor) {
		return {
			$$typeof: REACT_LAZY_TYPE,
			_payload: {
				_status: -1,
				_result: ctor
			},
			_init: lazyInitializer
		};
	};
	exports.memo = function(type, compare$1) {
		return {
			$$typeof: REACT_MEMO_TYPE,
			type,
			compare: void 0 === compare$1 ? null : compare$1
		};
	};
	exports.startTransition = function(scope) {
		var prevTransition = ReactSharedInternals.T, currentTransition = {};
		ReactSharedInternals.T = currentTransition;
		try {
			var returnValue = scope(), onStartTransitionFinish = ReactSharedInternals.S;
			null !== onStartTransitionFinish && onStartTransitionFinish(currentTransition, returnValue);
			"object" === typeof returnValue && null !== returnValue && "function" === typeof returnValue.then && returnValue.then(noop$1, reportGlobalError);
		} catch (error) {
			reportGlobalError(error);
		} finally {
			null !== prevTransition && null !== currentTransition.types && (prevTransition.types = currentTransition.types), ReactSharedInternals.T = prevTransition;
		}
	};
	exports.unstable_useCacheRefresh = function() {
		return ReactSharedInternals.H.useCacheRefresh();
	};
	exports.use = function(usable) {
		return ReactSharedInternals.H.use(usable);
	};
	exports.useActionState = function(action, initialState, permalink) {
		return ReactSharedInternals.H.useActionState(action, initialState, permalink);
	};
	exports.useCallback = function(callback, deps) {
		return ReactSharedInternals.H.useCallback(callback, deps);
	};
	exports.useContext = function(Context) {
		return ReactSharedInternals.H.useContext(Context);
	};
	exports.useDebugValue = function() {};
	exports.useDeferredValue = function(value, initialValue) {
		return ReactSharedInternals.H.useDeferredValue(value, initialValue);
	};
	exports.useEffect = function(create$1, deps) {
		return ReactSharedInternals.H.useEffect(create$1, deps);
	};
	exports.useEffectEvent = function(callback) {
		return ReactSharedInternals.H.useEffectEvent(callback);
	};
	exports.useId = function() {
		return ReactSharedInternals.H.useId();
	};
	exports.useImperativeHandle = function(ref, create$1, deps) {
		return ReactSharedInternals.H.useImperativeHandle(ref, create$1, deps);
	};
	exports.useInsertionEffect = function(create$1, deps) {
		return ReactSharedInternals.H.useInsertionEffect(create$1, deps);
	};
	exports.useLayoutEffect = function(create$1, deps) {
		return ReactSharedInternals.H.useLayoutEffect(create$1, deps);
	};
	exports.useMemo = function(create$1, deps) {
		return ReactSharedInternals.H.useMemo(create$1, deps);
	};
	exports.useOptimistic = function(passthrough, reducer) {
		return ReactSharedInternals.H.useOptimistic(passthrough, reducer);
	};
	exports.useReducer = function(reducer, initialArg, init) {
		return ReactSharedInternals.H.useReducer(reducer, initialArg, init);
	};
	exports.useRef = function(initialValue) {
		return ReactSharedInternals.H.useRef(initialValue);
	};
	exports.useState = function(initialState) {
		return ReactSharedInternals.H.useState(initialState);
	};
	exports.useSyncExternalStore = function(subscribe, getSnapshot, getServerSnapshot) {
		return ReactSharedInternals.H.useSyncExternalStore(subscribe, getSnapshot, getServerSnapshot);
	};
	exports.useTransition = function() {
		return ReactSharedInternals.H.useTransition();
	};
	exports.version = "19.2.0";
}) });

//#endregion
//#region node_modules/react/index.js
var require_react = /* @__PURE__ */ __commonJS({ "node_modules/react/index.js": ((exports, module) => {
	module.exports = require_react_production();
}) });

//#endregion
//#region node_modules/es-toolkit/dist/function/debounce.mjs
function debounce$1(func, debounceMs, { signal, edges } = {}) {
	let pendingThis = void 0;
	let pendingArgs = null;
	const leading = edges != null && edges.includes("leading");
	const trailing = edges == null || edges.includes("trailing");
	const invoke = () => {
		if (pendingArgs !== null) {
			func.apply(pendingThis, pendingArgs);
			pendingThis = void 0;
			pendingArgs = null;
		}
	};
	const onTimerEnd = () => {
		if (trailing) invoke();
		cancel();
	};
	let timeoutId = null;
	const schedule = () => {
		if (timeoutId != null) clearTimeout(timeoutId);
		timeoutId = setTimeout(() => {
			timeoutId = null;
			onTimerEnd();
		}, debounceMs);
	};
	const cancelTimer = () => {
		if (timeoutId !== null) {
			clearTimeout(timeoutId);
			timeoutId = null;
		}
	};
	const cancel = () => {
		cancelTimer();
		pendingThis = void 0;
		pendingArgs = null;
	};
	const flush = () => {
		invoke();
	};
	const debounced = function(...args) {
		if (signal?.aborted) return;
		pendingThis = this;
		pendingArgs = args;
		const isFirstCall = timeoutId == null;
		schedule();
		if (leading && isFirstCall) invoke();
	};
	debounced.schedule = schedule;
	debounced.cancel = cancel;
	debounced.flush = flush;
	signal?.addEventListener("abort", cancel, { once: true });
	return debounced;
}

//#endregion
//#region node_modules/es-toolkit/dist/compat/function/debounce.mjs
function debounce(func, debounceMs = 0, options = {}) {
	if (typeof options !== "object") options = {};
	const { leading = false, trailing = true, maxWait } = options;
	const edges = Array(2);
	if (leading) edges[0] = "leading";
	if (trailing) edges[1] = "trailing";
	let result = void 0;
	let pendingAt = null;
	const _debounced = debounce$1(function(...args) {
		result = func.apply(this, args);
		pendingAt = null;
	}, debounceMs, { edges });
	const debounced = function(...args) {
		if (maxWait != null) {
			if (pendingAt === null) pendingAt = Date.now();
			if (Date.now() - pendingAt >= maxWait) {
				result = func.apply(this, args);
				pendingAt = Date.now();
				_debounced.cancel();
				_debounced.schedule();
				return result;
			}
		}
		_debounced.apply(this, args);
		return result;
	};
	const flush = () => {
		_debounced.flush();
		return result;
	};
	debounced.cancel = _debounced.cancel;
	debounced.flush = flush;
	return debounced;
}

//#endregion
//#region node_modules/es-toolkit/dist/compat/function/throttle.mjs
function throttle(func, throttleMs = 0, options = {}) {
	const { leading = true, trailing = true } = options;
	return debounce(func, throttleMs, {
		leading,
		maxWait: throttleMs,
		trailing
	});
}

//#endregion
//#region node_modules/environment/index.js
const isBrowser = globalThis.window?.document !== void 0;
const isNode = globalThis.process?.versions?.node !== void 0;
const isBun = globalThis.process?.versions?.bun !== void 0;
const isDeno = globalThis.Deno?.version?.deno !== void 0;
const isElectron = globalThis.process?.versions?.electron !== void 0;
const isJsDom = globalThis.navigator?.userAgent?.includes("jsdom") === true;
const isWebWorker = typeof WorkerGlobalScope !== "undefined" && globalThis instanceof WorkerGlobalScope;
const isDedicatedWorker = typeof DedicatedWorkerGlobalScope !== "undefined" && globalThis instanceof DedicatedWorkerGlobalScope;
const isSharedWorker = typeof SharedWorkerGlobalScope !== "undefined" && globalThis instanceof SharedWorkerGlobalScope;
const isServiceWorker = typeof ServiceWorkerGlobalScope !== "undefined" && globalThis instanceof ServiceWorkerGlobalScope;
const platform = globalThis.navigator?.userAgentData?.platform;
const isMacOs = platform === "macOS" || globalThis.navigator?.platform === "MacIntel" || globalThis.navigator?.userAgent?.includes(" Mac ") === true || globalThis.process?.platform === "darwin";
const isWindows$1 = platform === "Windows" || globalThis.navigator?.platform === "Win32" || globalThis.process?.platform === "win32";
const isLinux = platform === "Linux" || globalThis.navigator?.platform?.startsWith("Linux") === true || globalThis.navigator?.userAgent?.includes(" Linux ") === true || globalThis.process?.platform === "linux";
const isIos = platform === "iOS" || globalThis.navigator?.platform === "MacIntel" && globalThis.navigator?.maxTouchPoints > 1 || /iPad|iPhone|iPod/.test(globalThis.navigator?.platform);
const isAndroid = platform === "Android" || globalThis.navigator?.platform === "Android" || globalThis.navigator?.userAgent?.includes(" Android ") === true || globalThis.process?.platform === "android";

//#endregion
//#region node_modules/ansi-escapes/base.js
const ESC = "\x1B[";
const isTerminalApp = !isBrowser && process$1.env.TERM_PROGRAM === "Apple_Terminal";
const isWindows = !isBrowser && process$1.platform === "win32";
const cwdFunction = isBrowser ? () => {
	throw new Error("`process.cwd()` only works in Node.js, not the browser.");
} : process$1.cwd;
const cursorUp = (count = 1) => ESC + count + "A";
const cursorLeft = ESC + "G";
const cursorSavePosition = isTerminalApp ? "\x1B7" : ESC + "s";
const cursorRestorePosition = isTerminalApp ? "\x1B8" : ESC + "u";
const cursorGetPosition = ESC + "6n";
const cursorNextLine = ESC + "E";
const cursorPrevLine = ESC + "F";
const cursorHide = ESC + "?25l";
const cursorShow = ESC + "?25h";
const eraseLines = (count) => {
	let clear = "";
	for (let i = 0; i < count; i++) clear += eraseLine + (i < count - 1 ? cursorUp() : "");
	if (count) clear += cursorLeft;
	return clear;
};
const eraseEndLine = ESC + "K";
const eraseStartLine = ESC + "1K";
const eraseLine = ESC + "2K";
const eraseDown = ESC + "J";
const eraseUp = ESC + "1J";
const eraseScreen = ESC + "2J";
const scrollUp = ESC + "S";
const scrollDown = ESC + "T";
const clearViewport = `${eraseScreen}${ESC}H`;
const clearTerminal = isWindows ? `${eraseScreen}${ESC}0f` : `${eraseScreen}${ESC}3J${ESC}H`;
const enterAlternativeScreen = ESC + "?1049h";
const exitAlternativeScreen = ESC + "?1049l";

//#endregion
//#region node_modules/is-in-ci/index.js
var import_react = /* @__PURE__ */ __toESM(require_react(), 1);
const check = (key) => key in env && env[key] !== "0" && env[key] !== "false";
const isInCi = check("CI") || check("CONTINUOUS_INTEGRATION");
var is_in_ci_default = isInCi;

//#endregion
//#region node_modules/auto-bind/index.js
const getAllProperties = (object) => {
	const properties = /* @__PURE__ */ new Set();
	do
		for (const key of Reflect.ownKeys(object)) properties.add([object, key]);
	while ((object = Reflect.getPrototypeOf(object)) && object !== Object.prototype);
	return properties;
};
function autoBind(self, { include, exclude } = {}) {
	const filter = (key) => {
		const match = (pattern) => typeof pattern === "string" ? key === pattern : pattern.test(key);
		if (include) return include.some(match);
		if (exclude) return !exclude.some(match);
		return true;
	};
	for (const [object, key] of getAllProperties(self.constructor.prototype)) {
		if (key === "constructor" || !filter(key)) continue;
		const descriptor = Reflect.getOwnPropertyDescriptor(object, key);
		if (descriptor && typeof descriptor.value === "function") self[key] = self[key].bind(self);
	}
	return self;
}

//#endregion
//#region node_modules/signal-exit/signals.js
var require_signals = /* @__PURE__ */ __commonJS({ "node_modules/signal-exit/signals.js": ((exports, module) => {
	module.exports = [
		"SIGABRT",
		"SIGALRM",
		"SIGHUP",
		"SIGINT",
		"SIGTERM"
	];
	if (process.platform !== "win32") module.exports.push("SIGVTALRM", "SIGXCPU", "SIGXFSZ", "SIGUSR2", "SIGTRAP", "SIGSYS", "SIGQUIT", "SIGIOT");
	if (process.platform === "linux") module.exports.push("SIGIO", "SIGPOLL", "SIGPWR", "SIGSTKFLT", "SIGUNUSED");
}) });

//#endregion
//#region node_modules/signal-exit/index.js
var require_signal_exit = /* @__PURE__ */ __commonJS({ "node_modules/signal-exit/index.js": ((exports, module) => {
	var process$2 = global.process;
	const processOk = function(process$3) {
		return process$3 && typeof process$3 === "object" && typeof process$3.removeListener === "function" && typeof process$3.emit === "function" && typeof process$3.reallyExit === "function" && typeof process$3.listeners === "function" && typeof process$3.kill === "function" && typeof process$3.pid === "number" && typeof process$3.on === "function";
	};
	/* istanbul ignore if */
	if (!processOk(process$2)) module.exports = function() {
		return function() {};
	};
	else {
		var assert = __require("assert");
		var signals = require_signals();
		var isWin = /^win/i.test(process$2.platform);
		var EE = __require("events");
		/* istanbul ignore if */
		if (typeof EE !== "function") EE = EE.EventEmitter;
		var emitter;
		if (process$2.__signal_exit_emitter__) emitter = process$2.__signal_exit_emitter__;
		else {
			emitter = process$2.__signal_exit_emitter__ = new EE();
			emitter.count = 0;
			emitter.emitted = {};
		}
		if (!emitter.infinite) {
			emitter.setMaxListeners(Infinity);
			emitter.infinite = true;
		}
		module.exports = function(cb, opts) {
			/* istanbul ignore if */
			if (!processOk(global.process)) return function() {};
			assert.equal(typeof cb, "function", "a callback must be provided for exit handler");
			if (loaded === false) load();
			var ev = "exit";
			if (opts && opts.alwaysLast) ev = "afterexit";
			var remove = function() {
				emitter.removeListener(ev, cb);
				if (emitter.listeners("exit").length === 0 && emitter.listeners("afterexit").length === 0) unload();
			};
			emitter.on(ev, cb);
			return remove;
		};
		var unload = function unload$1() {
			if (!loaded || !processOk(global.process)) return;
			loaded = false;
			signals.forEach(function(sig) {
				try {
					process$2.removeListener(sig, sigListeners[sig]);
				} catch (er) {}
			});
			process$2.emit = originalProcessEmit;
			process$2.reallyExit = originalProcessReallyExit;
			emitter.count -= 1;
		};
		module.exports.unload = unload;
		var emit = function emit$1(event, code, signal) {
			/* istanbul ignore if */
			if (emitter.emitted[event]) return;
			emitter.emitted[event] = true;
			emitter.emit(event, code, signal);
		};
		var sigListeners = {};
		signals.forEach(function(sig) {
			sigListeners[sig] = function listener() {
				/* istanbul ignore if */
				if (!processOk(global.process)) return;
				if (process$2.listeners(sig).length === emitter.count) {
					unload();
					emit("exit", null, sig);
					/* istanbul ignore next */
					emit("afterexit", null, sig);
					/* istanbul ignore next */
					if (isWin && sig === "SIGHUP") sig = "SIGINT";
					/* istanbul ignore next */
					process$2.kill(process$2.pid, sig);
				}
			};
		});
		module.exports.signals = function() {
			return signals;
		};
		var loaded = false;
		var load = function load$1() {
			if (loaded || !processOk(global.process)) return;
			loaded = true;
			emitter.count += 1;
			signals = signals.filter(function(sig) {
				try {
					process$2.on(sig, sigListeners[sig]);
					return true;
				} catch (er) {
					return false;
				}
			});
			process$2.emit = processEmit;
			process$2.reallyExit = processReallyExit;
		};
		module.exports.load = load;
		var originalProcessReallyExit = process$2.reallyExit;
		var processReallyExit = function processReallyExit$1(code) {
			/* istanbul ignore if */
			if (!processOk(global.process)) return;
			process$2.exitCode = code || 0;
			emit("exit", process$2.exitCode, null);
			/* istanbul ignore next */
			emit("afterexit", process$2.exitCode, null);
			/* istanbul ignore next */
			originalProcessReallyExit.call(process$2, process$2.exitCode);
		};
		var originalProcessEmit = process$2.emit;
		var processEmit = function processEmit$1(ev, arg) {
			if (ev === "exit" && processOk(global.process)) {
				/* istanbul ignore else */
				if (arg !== void 0) process$2.exitCode = arg;
				var ret = originalProcessEmit.apply(this, arguments);
				/* istanbul ignore next */
				emit("exit", process$2.exitCode, null);
				/* istanbul ignore next */
				emit("afterexit", process$2.exitCode, null);
				/* istanbul ignore next */
				return ret;
			} else return originalProcessEmit.apply(this, arguments);
		};
	}
}) });

//#endregion
//#region node_modules/patch-console/dist/index.js
var import_signal_exit$1 = /* @__PURE__ */ __toESM(require_signal_exit(), 1);
const consoleMethods = [
	"assert",
	"count",
	"countReset",
	"debug",
	"dir",
	"dirxml",
	"error",
	"group",
	"groupCollapsed",
	"groupEnd",
	"info",
	"log",
	"table",
	"time",
	"timeEnd",
	"timeLog",
	"trace",
	"warn"
];
let originalMethods = {};
const patchConsole = (callback) => {
	const stdout = new PassThrough();
	const stderr = new PassThrough();
	stdout.write = (data) => {
		callback("stdout", data);
	};
	stderr.write = (data) => {
		callback("stderr", data);
	};
	const internalConsole = new console.Console(stdout, stderr);
	for (const method of consoleMethods) {
		originalMethods[method] = console[method];
		console[method] = internalConsole[method];
	}
	return () => {
		for (const method of consoleMethods) console[method] = originalMethods[method];
		originalMethods = {};
	};
};
var dist_default = patchConsole;

//#endregion
//#region node_modules/react-reconciler/cjs/react-reconciler-constants.production.js
var require_react_reconciler_constants_production = /* @__PURE__ */ __commonJS({ "node_modules/react-reconciler/cjs/react-reconciler-constants.production.js": ((exports) => {
	exports.DefaultEventPriority = 32;
	exports.LegacyRoot = 0;
	exports.NoEventPriority = 0;
}) });

//#endregion
//#region node_modules/react-reconciler/constants.js
var require_constants$1 = /* @__PURE__ */ __commonJS({ "node_modules/react-reconciler/constants.js": ((exports, module) => {
	module.exports = require_react_reconciler_constants_production();
}) });

//#endregion
//#region node_modules/yoga-layout/dist/binaries/yoga-wasm-base64-esm.js
var import_constants$1 = /* @__PURE__ */ __toESM(require_constants$1(), 1);
var loadYoga = (() => {
	var _scriptDir = import.meta.url;
	return (function(loadYoga$1) {
		loadYoga$1 = loadYoga$1 || {};
		var h;
		h || (h = typeof loadYoga$1 !== "undefined" ? loadYoga$1 : {});
		var aa, ca;
		h.ready = new Promise(function(a, b) {
			aa = a;
			ca = b;
		});
		var da = Object.assign({}, h), q = "";
		"undefined" != typeof document && document.currentScript && (q = document.currentScript.src);
		_scriptDir && (q = _scriptDir);
		0 !== q.indexOf("blob:") ? q = q.substr(0, q.replace(/[?#].*/, "").lastIndexOf("/") + 1) : q = "";
		var ea = h.print || console.log.bind(console), v = h.printErr || console.warn.bind(console);
		Object.assign(h, da);
		da = null;
		var w;
		h.wasmBinary && (w = h.wasmBinary);
		h.noExitRuntime;
		"object" != typeof WebAssembly && x("no native wasm support detected");
		var fa, ha = !1;
		function z(a, b, c) {
			c = b + c;
			for (var d = ""; !(b >= c);) {
				var e = a[b++];
				if (!e) break;
				if (e & 128) {
					var f = a[b++] & 63;
					if (192 == (e & 224)) d += String.fromCharCode((e & 31) << 6 | f);
					else {
						var g = a[b++] & 63;
						e = 224 == (e & 240) ? (e & 15) << 12 | f << 6 | g : (e & 7) << 18 | f << 12 | g << 6 | a[b++] & 63;
						65536 > e ? d += String.fromCharCode(e) : (e -= 65536, d += String.fromCharCode(55296 | e >> 10, 56320 | e & 1023));
					}
				} else d += String.fromCharCode(e);
			}
			return d;
		}
		var ia, ja, A, C, ka, D, E, la, ma;
		function na() {
			var a = fa.buffer;
			ia = a;
			h.HEAP8 = ja = new Int8Array(a);
			h.HEAP16 = C = new Int16Array(a);
			h.HEAP32 = D = new Int32Array(a);
			h.HEAPU8 = A = new Uint8Array(a);
			h.HEAPU16 = ka = new Uint16Array(a);
			h.HEAPU32 = E = new Uint32Array(a);
			h.HEAPF32 = la = new Float32Array(a);
			h.HEAPF64 = ma = new Float64Array(a);
		}
		var oa, pa = [], qa = [], ra = [];
		function sa() {
			var a = h.preRun.shift();
			pa.unshift(a);
		}
		var F = 0, ta = null, G = null;
		function x(a) {
			if (h.onAbort) h.onAbort(a);
			a = "Aborted(" + a + ")";
			v(a);
			ha = !0;
			a = new WebAssembly.RuntimeError(a + ". Build with -sASSERTIONS for more info.");
			ca(a);
			throw a;
		}
		function ua(a) {
			return a.startsWith("data:application/octet-stream;base64,");
		}
		var H = "data:application/octet-stream;base64,AGFzbQEAAAABugM3YAF/AGACf38AYAF/AX9gA39/fwBgAn98AGACf38Bf2ADf39/AX9gBH9/f30BfWADf398AGAAAGAEf39/fwBgAX8BfGACf38BfGAFf39/f38Bf2AAAX9gA39/fwF9YAZ/f31/fX8AYAV/f39/fwBgAn9/AX1gBX9/f319AX1gAX8BfWADf35/AX5gB39/f39/f38AYAZ/f39/f38AYAR/f39/AX9gBn9/f319fQF9YAR/f31/AGADf399AX1gBn98f39/fwF/YAR/fHx/AGACf30AYAh/f39/f39/fwBgDX9/f39/f39/f39/f38AYAp/f39/f39/f39/AGAFf39/f38BfGAEfHx/fwF9YA1/fX1/f399fX9/f39/AX9gB39/f319f38AYAJ+fwF/YAN/fX0BfWABfAF8YAN/fHwAYAR/f319AGAHf39/fX19fQF9YA1/fX99f31/fX19fX1/AX9gC39/f39/f399fX19AX9gCH9/f39/f319AGAEf39+fgBgB39/f39/f38Bf2ACfH8BfGAFf398fH8AYAN/f38BfGAEf39/fABgA39/fQBgBn9/fX99fwF/ArUBHgFhAWEAHwFhAWIAAwFhAWMACQFhAWQAFgFhAWUAEQFhAWYAIAFhAWcAAAFhAWgAIQFhAWkAAwFhAWoAAAFhAWsAFwFhAWwACgFhAW0ABQFhAW4AAwFhAW8AAQFhAXAAFwFhAXEABgFhAXIAAAFhAXMAIgFhAXQACgFhAXUADQFhAXYAFgFhAXcAAgFhAXgAAwFhAXkAGAFhAXoAAgFhAUEAAQFhAUIAEQFhAUMAAQFhAUQAAAOiAqACAgMSBwcACRkDAAoRBgYKEwAPDxMBBiMTCgcHGgMUASQFJRQHAwMKCgMmAQYYDxobFAAKBw8KBwMDAgkCAAAFGwACBwIHBgIDAQMIDAABKAkHBQURACkZASoAAAIrLAIALQcHBy4HLwkFCgMCMA0xAgMJAgACAQYKAQIBBQEACQIFAQEABQAODQ0GFQIBHBUGAgkCEAAAAAUyDzMMBQYINAUCAwUODg41AgMCAgIDBgICNgIBDAwMAQsLCwsLCx0CAAIAAAABABABBQICAQMCEgMMCwEBAQEBAQsLAQICAwICAgICAgIDAgIICAEICAgEBAQEBAQEBAQABAQABAQEBAAE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GiABQQA2AvADIAFCADcC6AMgAigC7AMiAyACKALoAyIERwRAIAMgBGsiBEEASA0FIAEgBBAeIgM2AuwDIAEgAzYC6AMgASADIARqNgLwAyACKALoAyIEIAIoAuwDIghHBEADQCADIAQoAgA2AgAgA0EEaiEDIARBBGoiBCAIRw0ACwsgASADNgLsAwsgASACKQL0AzcC9AMgASACKAKEBDYChAQgASACKQL8AzcC/AMgAUEANgLkAwsgBSABNgIAIAEgADYC5AMLIAZBAWohBiAFQQRqIgUgB0cNAAsLDwsQAgALUAACQAJAAkACQAJAIAIOBAQAAQIDCyAAIAEgAUEwahBDDwsgACABIAFBMGogAxBEDwsgACABIAFBMGoQQg8LECQACyAAIAEgAUEwaiADEEULcAIBfwF9IwBBEGsiBCQAIARBCGogACABQQJ0QdwlaigCACACEDZDAADAfyEFAkACQAJAIAQtAAxBAWsOAgABAgsgBCoCCCEFDAELIAQqAgggA5RDCtcjPJQhBQsgBEEQaiQAIAVDAAAAACAFIAVbGwt5AgF/AX0jAEEQayIDJAAgA0EIaiAAIAFBAnRB7CVqKAIAIAIQU0MAAMB/IQQCQAJAAkAgAy0ADEEBaw4CAAECCyADKgIIIQQMAQsgAyoCCEMAAAAAlEMK1yM8lCEECyADQRBqJAAgBEMAAAAAl0MAAAAAIAQgBFsbC1QAAkACQAJAAkACQCACDgQEAAECAwsgACABIAFBwgBqEEMPCyAAIAEgAUHCAGogAxBEDwsgACABIAFBwgBqEEIPCxAkAAsgACABIAFBwgBqIAMQRQsvACAAIAJFQQF0IgIgASADEGAgACACIAEQS5IgACACIAEgAxB/IAAgAiABEFKSkgvOAQIDfwJ9IwBBEGsiAyQAQQEhBCADQQhqIABB/ABqIgUgACABQQF0akH2AGoiAS8BABAfAkACQCADKgIIIgcgAioCACIGXARAIAcgB1sEQCACLQAEIQIMAgsgBiAGXCEECyACLQAEIQIgBEUNACADLQAMIAJB/wFxRg0BCyAFIAEgBiACEDkDQCAALQAAIgFBBHENASAAIAFBBHI6AAAgACgCECIBBEAgACABEQAACyAAQYCAgP4HNgKcASAAKALkAyIADQALCyADQRBqJAALzgECA38CfSMAQRBrIgMkAEEBIQQgA0EIaiAAQfwAaiIFIAAgAUEBdGpB8gBqIgEvAQAQHwJAAkAgAyoCCCIHIAIqAgAiBlwEQCAHIAdbBEAgAi0ABCECDAILIAYgBlwhBAsgAi0ABCECIARFDQAgAy0ADCACQf8BcUYNAQsgBSABIAYgAhA5A0AgAC0AACIBQQRxDQEgACABQQRyOgAAIAAoAhAiAQRAIAAgAREAAAsgAEGAgID+BzYCnAEgACgC5AMiAA0ACwsgA0EQaiQACwoAIABBMGtBCkkLBQAQAgALBAAgAAsUACAABEAgACAAKAIAKAIEEQAACwsrAQF/IAAoAgwiAQRAIAEQIwsgACgCACIBBEAgACABNgIEIAEQIwsgABAjC4EEAQN/IwBBEGsiAyQAIABCADcCBCAAQcEgOwAVIABCADcCDCAAQoCAgICAgIACNwIYIAAgAC0AF0HgAXE6ABcgACAALQAAQeABcUEFcjoAACAAIAAtABRBgAFxOgAUIABBIGpBAEHOABAqGiAAQgA3AXIgAEGEgBA2AW4gAEEANgF6IABCADcCgAEgAEIANwKIASAAQgA3ApABIABCADcCoAEgAEKAgICAgICA4P8ANwKYASAAQQA6AKgBIABBrAFqQQBBxAEQKhogAEHwAmohBCAAQbABaiECA0AgAkKAgID8i4CAwL9/NwIQIAJCgYCAgBA3AgggAkKAgID8i4CAwL9/NwIAIAJBGGoiAiAERw0ACyAAQoCAgPyLgIDAv383AvACIABCgICA/IuAgMC/fzcCgAMgAEKBgICAEDcC+AIgAEKAgID+h4CA4P8ANwKUAyAAQoCAgP6HgIDg/wA3AowDIABBiANqIgIgAi0AAEH4AXE6AAAgAEGcA2pBAEHYABAqGiAAQQA6AIQEIABBgICA/gc2AoAEIABBADoA/AMgAEGAgID+BzYC+AMgACABNgL0AyABBEAgAS0ACEEBcQRAIAAgAC0AFEHzAXFBCHI6ABQgACAALwAVQfD/A3FBBHI7ABULIANBEGokACAADwsgA0GiGjYCACADEHIQJAALMwAgACABQQJ0QfwlaigCAEECdGoqApQDIABBFGoiACABQQEgAhAiIAAgAUEBIAIQIZKSC44DAQp/IwBB0AJrIgEkACAAKALoAyIDIAAoAuwDIgVHBEAgAUGMAmohBiABQeABaiEHIAFBIGohCCABQRxqIQkgAUEQaiEEA0AgAygCACICLQAXQRB0QYCAMHFBgIAgRgRAIAFBCGpBAEHEAhAqGiABQYCAgP4HNgIMIARBADoACCAEQgA3AgAgCUEAQcQBECoaIAghAANAIABCgICA/IuAgMC/fzcCECAAQoGAgIAQNwIIIABCgICA/IuAgMC/fzcCACAAQRhqIgAgB0cNAAsgAUKAgID8i4CAwL9/NwPwASABQoGAgIAQNwPoASABQoCAgPyLgIDAv383A+ABIAFCgICA/oeAgOD/ADcChAIgAUKAgID+h4CA4P8ANwL8ASABIAEtAPgBQfgBcToA+AEgBkEAQcAAECoaIAJBmAFqIAFBCGpBxAIQKxogAkIANwKMAyACIAItAAAiAEEBciIKQfsBcSAKIABBBHEbOgAAIAIQTyACEF4LIANBBGoiAyAFRw0ACwsgAUHQAmokAAtMAQF/QQEhAQJAIAAtAB5BB3ENACAALQAiQQdxDQAgAC0ALkEHcQ0AIAAtACpBB3ENACAALQAmQQdxDQAgAC0AKEEHcUEARyEBCyABC3YCAX8BfSMAQRBrIgQkACAEQQhqIAAgAUECdEHcJWooAgAgAhBQQwAAwH8hBQJAAkACQCAELQAMQQFrDgIAAQILIAQqAgghBQwBCyAEKgIIIAOUQwrXIzyUIQULIARBEGokACAFQwAAAACXQwAAAAAgBSAFWxsLogQCBn8CfgJ/QQghBAJAAkAgAEFHSw0AA0BBCCAEIARBCE0bIQRB6DopAwAiBwJ/QQggAEEDakF8cSAAQQhNGyIAQf8ATQRAIABBA3ZBAWsMAQsgAEEdIABnIgFrdkEEcyABQQJ0a0HuAGogAEH/H00NABpBPyAAQR4gAWt2QQJzIAFBAXRrQccAaiIBIAFBP08bCyIDrYgiCFBFBEADQCAIIAh6IgiIIQcCfiADIAinaiIDQQR0IgJB6DJqKAIAIgEgAkHgMmoiBkcEQCABIAQgABBjIgUNBSABKAIEIgUgASgCCDYCCCABKAIIIAU2AgQgASAGNgIIIAEgAkHkMmoiAigCADYCBCACIAE2AgAgASgCBCABNgIIIANBAWohAyAHQgGIDAELQeg6Qeg6KQMAQn4gA62JgzcDACAHQgGFCyIIQgBSDQALQeg6KQMAIQcLAkAgB1BFBEBBPyAHeadrIgZBBHQiAkHoMmooAgAhAQJAIAdCgICAgARUDQBB4wAhAyABIAJB4DJqIgJGDQADQCADRQ0BIAEgBCAAEGMiBQ0FIANBAWshAyABKAIIIgEgAkcNAAsgAiEBCyAAQTBqEGQNASABRQ0EIAEgBkEEdEHgMmoiAkYNBANAIAEgBCAAEGMiBQ0EIAEoAggiASACRw0ACwwECyAAQTBqEGRFDQMLQQAhBSAEIARBAWtxDQEgAEFHTQ0ACwsgBQwBC0EACwtwAgF/AX0jAEEQayIEJAAgBEEIaiAAIAFBAnRB7CVqKAIAIAIQKEMAAMB/IQUCQAJAAkAgBC0ADEEBaw4CAAECCyAEKgIIIQUMAQsgBCoCCCADlEMK1yM8lCEFCyAEQRBqJAAgBUMAAAAAIAUgBVsbC6ADAQN/IAEgAEEEaiIEakEBa0EAIAFrcSIFIAJqIAAgACgCACIBakEEa00EfyAAKAIEIgMgACgCCDYCCCAAKAIIIAM2AgQgBCAFRwRAIAAgAEEEaygCAEF+cWsiAyAFIARrIgQgAygCAGoiBTYCACAFQXxxIANqQQRrIAU2AgAgACAEaiIAIAEgBGsiATYCAAsCQCABIAJBGGpPBEAgACACakEIaiIDIAEgAmtBCGsiATYCACABQXxxIANqQQRrIAFBAXI2AgAgAwJ/IAMoAgBBCGsiAUH/AE0EQCABQQN2QQFrDAELIAFnIQQgAUEdIARrdkEEcyAEQQJ0a0HuAGogAUH/H00NABpBPyABQR4gBGt2QQJzIARBAXRrQccAaiIBIAFBP08bCyIBQQR0IgRB4DJqNgIEIAMgBEHoMmoiBCgCADYCCCAEIAM2AgAgAygCCCADNgIEQeg6Qeg6KQMAQgEgAa2GhDcDACAAIAJBCGoiATYCACABQXxxIABqQQRrIAE2AgAMAQsgACABakEEayABNgIACyAAQQRqBSADCwvmAwEFfwJ/QbAwKAIAIgEgAEEHakF4cSIDaiECAkAgA0EAIAEgAk8bDQAgAj8AQRB0SwRAIAIQFkUNAQtBsDAgAjYCACABDAELQfw7QTA2AgBBfwsiAkF/RwRAIAAgAmoiA0EQayIBQRA2AgwgAUEQNgIAAkACf0HgOigCACIABH8gACgCCAVBAAsgAkYEQCACIAJBBGsoAgBBfnFrIgRBBGsoAgAhBSAAIAM2AghBcCAEIAVBfnFrIgAgACgCAGpBBGstAABBAXFFDQEaIAAoAgQiAyAAKAIINgIIIAAoAgggAzYCBCAAIAEgAGsiATYCAAwCCyACQRA2AgwgAkEQNgIAIAIgAzYCCCACIAA2AgRB4DogAjYCAEEQCyACaiIAIAEgAGsiATYCAAsgAUF8cSAAakEEayABQQFyNgIAIAACfyAAKAIAQQhrIgFB/wBNBEAgAUEDdkEBawwBCyABQR0gAWciA2t2QQRzIANBAnRrQe4AaiABQf8fTQ0AGkE/IAFBHiADa3ZBAnMgA0EBdGtBxwBqIgEgAUE/TxsLIgFBBHQiA0HgMmo2AgQgACADQegyaiIDKAIANgIIIAMgADYCACAAKAIIIAA2AgRB6DpB6DopAwBCASABrYaENwMACyACQX9HC80BAgN/An0jAEEQayIDJABBASEEIANBCGogAEH8AGoiBSAAIAFBAXRqQSBqIgEvAQAQHwJAAkAgAyoCCCIHIAIqAgAiBlwEQCAHIAdbBEAgAi0ABCECDAILIAYgBlwhBAsgAi0ABCECIARFDQAgAy0ADCACQf8BcUYNAQsgBSABIAYgAhA5A0AgAC0AACIBQQRxDQEgACABQQRyOgAAIAAoAhAiAQRAIAAgAREAAAsgAEGAgID+BzYCnAEgACgC5AMiAA0ACwsgA0EQaiQAC0ABAX8CQEGsOy0AAEEBcQRAQag7KAIAIQIMAQtBAUGAJxAMIQJBrDtBAToAAEGoOyACNgIACyACIAAgAUEAEBMLzQECA38CfSMAQRBrIgMkAEEBIQQgA0EIaiAAQfwAaiIFIAAgAUEBdGpBMmoiAS8BABAfAkACQCADKgIIIgcgAioCACIGXARAIAcgB1sEQCACLQAEIQIMAgsgBiAGXCEECyACLQAEIQIgBEUNACADLQAMIAJB/wFxRg0BCyAFIAEgBiACEDkDQCAALQAAIgFBBHENASAAIAFBBHI6AAAgACgCECIBBEAgACABEQAACyAAQYCAgP4HNgKcASAAKALkAyIADQALCyADQRBqJAALDwAgASAAKAIAaiACOQMACw0AIAEgACgCAGorAwALCwAgAARAIAAQIwsLxwECBH8CfSMAQRBrIgIkACACQQhqIABB/ABqIgQgAEEeaiIFLwEAEB9BASEDAkACQCACKgIIIgcgASoCACIGXARAIAcgB1sEQCABLQAEIQEMAgsgBiAGXCEDCyABLQAEIQEgA0UNACACLQAMIAFB/wFxRg0BCyAEIAUgBiABEDkDQCAALQAAIgFBBHENASAAIAFBBHI6AAAgACgCECIBBEAgACABEQAACyAAQYCAgP4HNgKcASAAKALkAyIADQALCyACQRBqJAALlgMCA34CfyAAvSICQjSIp0H/D3EiBEH/D0YEQCAARAAAAAAAAPA/oiIAIACjDwsgAkIBhiIBQoCAgICAgIDw/wBYBEAgAEQAAAAAAAAAAKIgACABQoCAgICAgIDw/wBRGw8LAn4gBEUEQEEAIQQgAkIMhiIBQgBZBEADQCAEQQFrIQQgAUIBhiIBQgBZDQALCyACQQEgBGuthgwBCyACQv////////8Hg0KAgICAgICACIQLIQEgBEH/B0oEQANAAkAgAUKAgICAgICACH0iA0IAUw0AIAMiAUIAUg0AIABEAAAAAAAAAACiDwsgAUIBhiEBIARBAWsiBEH/B0oNAAtB/wchBAsCQCABQoCAgICAgIAIfSIDQgBTDQAgAyIBQgBSDQAgAEQAAAAAAAAAAKIPCyABQv////////8HWARAA0AgBEEBayEEIAFCgICAgICAgARUIQUgAUIBhiEBIAUNAAsLIAJCgICAgICAgICAf4MgAUKAgICAgICACH0gBK1CNIaEIAFBASAEa62IIARBAEobhL8LiwEBA38DQCAAQQR0IgFB5DJqIAFB4DJqIgI2AgAgAUHoMmogAjYCACAAQQFqIgBBwABHDQALQTAQZBpBmDtBBjYCAEGcO0EANgIAEJwBQZw7Qcg7KAIANgIAQcg7QZg7NgIAQcw7QcMBNgIAQdA7QQA2AgAQjwFB0DtByDsoAgA2AgBByDtBzDs2AgALjwEBAn8jAEEQayIEJAACfUMAAAAAIAAvABVBgOAAcUUNABogBEEIaiAAQRRqIgBBASACQQJGQQF0IAFB/gFxQQJHGyIFIAIQNgJAIAQtAAxFDQAgBEEIaiAAIAUgAhA2IAQtAAxBA0YNACAAIAEgAiADEIEBDAELIAAgASACIAMQgAGMCyEDIARBEGokACADC4QBAQJ/AkACQCAAKALoAyICIAAoAuwDIgNGDQADQCACKAIAIAFGDQEgAkEEaiICIANHDQALDAELIAIgA0YNACABLQAXQRB0QYCAMHFBgIAgRgRAIAAgACgC4ANBAWs2AuADCyACIAJBBGoiASADIAFrEDMaIAAgA0EEazYC7ANBAQ8LQQALCwBByDEgACABEEkLPAAgAEUEQCACQQVHQQAgAhtFBEBBuDAgAyAEEEkaDwsgAyAEEHAaDwsgACABIAIgAyAEIAAoAgQRDQAaCyYBAX8jAEEQayIBJAAgASAANgIMQbgwQdglIAAQSRogAUEQaiQAC4cDAwN/BXwCfSAAKgKgA7siBiACoCECIAAqApwDuyIHIAGgIQggACgC9AMqAhgiC0MAAAAAXARAIAAqApADuyEJIAAqAowDIQwgACAHIAu7IgFBACAALQAAQRBxIgNBBHYiBBA0OAKcAyAAIAYgAUEAIAQQNDgCoAMgASAMuyIHohBsIgYgBmIiBEUgBplELUMc6+I2Gj9jcUUEQCAEIAZEAAAAAAAA8L+gmUQtQxzr4jYaP2NFciEFCyACIAmgIQogCCAHoCEHAn8gASAJohBsIgYgBmIiBEUEQEEAIAaZRC1DHOviNho/Yw0BGgsgBCAGRAAAAAAAAPC/oJlELUMc6+I2Gj9jRXILIQQgACAHIAEgA0EARyIDIAVxIAMgBUEBc3EQNCAIIAFBACADEDSTOAKMAyAAIAogASADIARxIAMgBEEBc3EQNCACIAFBACADEDSTOAKQAwsgACgC6AMiAyAAKALsAyIARwRAA0AgAygCACAIIAIQcyADQQRqIgMgAEcNAAsLC1UBAX0gAEEUaiIAIAEgAkECSSICIAQgBRA1IQYgACABIAIgBCAFEC0iBUMAAAAAYCADIAVecQR9IAUFIAZDAAAAAGBFBEAgAw8LIAYgAyADIAZdGwsLeAEBfwJAIAAoAgAiAgRAA0AgAUUNAiACIAEoAgQ2AgQgAiABKAIINgIIIAEoAgAhASAAKAIAIQAgAigCACICDQALCyAAIAEQPA8LAkAgAEUNACAAKAIAIgFFDQAgAEEANgIAA0AgASgCACEAIAEQIyAAIgENAAsLC5kCAgZ/AX0gAEEUaiEHQQMhBCAALQAUQQJ2QQNxIQUCQAJ/AkAgAUEBIAAoAuQDGyIIQQJGBEACQCAFQQJrDgIEAAILQQIhBAwDC0ECIQRBACAFQQFLDQEaCyAECyEGIAUhBAsgACAEIAggAyACIARBAkkiBRsQbiEKIAAgBiAIIAIgAyAFGxBuIQMgAEGcA2oiAEEBIAFBAkZBAXQiCCAFG0ECdGogCiAHIAQgASACECKSOAIAIABBAyABQQJHQQF0IgkgBRtBAnRqIAogByAEIAEgAhAhkjgCACAAIAhBASAGQQF2IgQbQQJ0aiADIAcgBiABIAIQIpI4AgAgACAJQQMgBBtBAnRqIAMgByAGIAEgAhAhkjgCAAvUAgEDfyMAQdACayIBJAAgAUEIakEAQcQCECoaIAFBADoAGCABQgA3AxAgAUGAgID+BzYCDCABQRxqQQBBxAEQKhogAUHgAWohAyABQSBqIQIDQCACQoCAgPyLgIDAv383AhAgAkKBgICAEDcCCCACQoCAgPyLgIDAv383AgAgAkEYaiICIANHDQALIAFCgICA/IuAgMC/fzcD8AEgAUKBgICAEDcD6AEgAUKAgID8i4CAwL9/NwPgASABQoCAgP6HgIDg/wA3AoQCIAFCgICA/oeAgOD/ADcC/AEgASABLQD4AUH4AXE6APgBIAFBjAJqQQBBwAAQKhogAEGYAWogAUEIakHEAhArGiAAQgA3AowDIAAgAC0AAEEBcjoAACAAEE8gACgC6AMiAiAAKALsAyIARwRAA0AgAigCABB3IAJBBGoiAiAARw0ACwsgAUHQAmokAAuuAgIKfwJ9IwBBIGsiASQAIAFBgAI7AB4gAEHuAGohByAAQfgDaiEFIABB8gBqIQggAEH2AGohCSAAQfwAaiEDQQAhAANAIAFBEGogAyAJIAFBHmogBGotAAAiAkEBdCIEaiIGLwEAEB8CQAJAIAEtABRFDQAgAUEIaiADIAYvAQAQHyABIAMgBCAIai8BABAfIAEtAAwgAS0ABEcNAAJAIAEqAggiDCAMXCIKIAEqAgAiCyALXHJFBEAgDCALk4tDF7fROF0NAQwCCyAKRSALIAtbcg0BCyABQRBqIAMgBi8BABAfDAELIAFBEGogAyAEIAdqLwEAEB8LIAUgAkEDdGoiAiABLQAUOgAEIAIgASgCEDYCAEEBIQQgACECQQEhACACRQ0ACyABQSBqJAALMgACf0EAIAAvABVBgOAAcUGAwABGDQAaQQEgABA7QwAAAABcDQAaIAAQQEMAAAAAXAsLewEBfSADIASTIgMgA1sEfUMAAAAAIABBFGoiACABIAIgBSAGEDUiByAEkyAHIAdcGyIHQ///f38gACABIAIgBSAGEC0iBSAEkyAFIAVcGyIEIAMgAyAEXhsiAyADIAddGyAHIAMgAyADXBsgAyADWyAHIAdbcRsFIAMLC98FAwR/BX0BfCAJQwAAAABdIAhDAAAAAF1yBH8gDQUgBSESIAEhEyADIRQgByERIAwqAhgiFUMAAAAAXARAIAG7IBW7IhZBAEEAEDQhEyADuyAWQQBBABA0IRQgBbsgFkEAQQAQNCESIAe7IBZBAEEAEDQhEQsCf0EAIAAgBEcNABogEiATk4tDF7fROF0gEyATXCINIBIgElxyRQ0AGkEAIBIgElsNABogDQshDAJAIAIgBkcNACAUIBRcIg0gESARXHJFBEAgESAUk4tDF7fROF0hDwwBCyARIBFbDQAgDSEPC0EBIQ5BASENAkAgDA0AIAEgCpMhAQJAIABFBEAgASABXCIAIAggCFxyRQRAQQAhDCABIAiTi0MXt9E4XUUNAgwDC0EAIQwgCCAIWw0BIAANAgwBCyAAQQJGIQwgAEECRw0AIARBAUcNACABIAhgDQECQCAIIAhcIgAgASABXHJFBEAgASAIk4tDF7fROF1FDQEMAwtBACENIAEgAVsNAkEBIQ0gAA0CC0EAIQ0MAQtBACENIAggCFwiACABIAVdRXINACAMRSABIAFcIhAgBSAFXHIgBEECR3JyDQBBASENIAEgCGANAEEAIQ0gACAQcg0AIAEgCJOLQxe30ThdIQ0LAkAgDw0AIAMgC5MhAQJAAkAgAkUEQCABIAFcIgIgCSAJXHJFBEBBACEAIAEgCZOLQxe30ThdRQ0CDAQLQQAhACAJIAlbDQEgAg0DDAELIAJBAkYhACACQQJHIAZBAUdyDQAgASAJYARADAMLIAkgCVwiACABIAFcckUEQCABIAmTi0MXt9E4XUUNAgwDC0EAIQ4gASABWw0CQQEhDiAADQIMAQsgCSAJXCICIAEgB11Fcg0AIABFIAEgAVwiBCAHIAdcciAGQQJHcnINACABIAlgDQFBACEOIAIgBHINASABIAmTi0MXt9E4XSEODAELQQAhDgsgDSAOcQsL4wEBA38jAEEQayIBJAACQAJAIAAtABRBCHFFDQBBASEDIAAvABVB8AFxQdAARg0AIAEgABAyIAEoAgQhAAJAIAEoAgAiAkUEQEEAIQMgAEUNAQsDQCACKALsAyACKALoAyICa0ECdSAATQ0DIAIgAEECdGooAgAiAC8AFSAALQAXQRB0ciIAQYDgAHFBgMAARyAAQYAecUGACkZxIgMNASABEC4gASgCBCIAIAEoAgAiAnINAAsLIAEoAggiAEUNAANAIAAoAgAhAiAAECMgAiIADQALCyABQRBqJAAgAw8LEAIAC7IBAQR/AkACQCAAKAIEIgMgACgCACIEKALsAyAEKALoAyIBa0ECdUkEQCABIANBAnRqIQIDQCACKAIAIgEtABdBEHRBgIAwcUGAgCBHDQMgASgC7AMgASgC6ANGDQJBDBAeIgIgBDYCBCACIAM2AgggAiAAKAIINgIAQQAhAyAAQQA2AgQgACABNgIAIAAgAjYCCCABIQQgASgC6AMiAiABKALsA0cNAAsLEAIACyAAEC4LC4wQAgx/B30jAEEgayINJAAgDUEIaiABEDIgDSgCCCIOIA0oAgwiDHIEQCADQQEgAxshFSAAQRRqIRQgBUEBaiEWA0ACQAJAAn8CQAJAAkACQAJAIAwgDigC7AMgDigC6AMiDmtBAnVJBEAgDiAMQQJ0aigCACILLwAVIAstABdBEHRyIgxBgIAwcUGAgBBGDQgCQAJAIAxBDHZBA3EOAwEKAAoLIAkhFyAKIRogASgC9AMtABRBBHFFBEAgACoClAMgFEECQQEQMCAUQQJBARAvkpMhFyAAKgKYAyAUQQBBARAwIBRBAEEBEC+SkyEaCyALQRRqIQ8gAS0AFEECdkEDcSEQAkACfwJAIANBAkciE0UEQEEAIQ5BAyEMAkAgEEECaw4CBAACC0ECIQwMAwtBAiEMQQAgEEEBSw0BGgsgDAshDiAQIQwLIA9BAkEBIBcQIiAPQQJBASAXECGSIR0gD0EAQQEgFxAiIRwgD0EAQQEgFxAhIRsgCyoC+AMhGAJAAkACQAJAIAstAPwDQQFrDgIBAAILIBggF5RDCtcjPJQhGAsgGEMAAAAAYEUNACAdIAsgA0EAIBcgFxAxkiEYDAELIA1BGGogDyALQTJqIhAgAxBFQwAAwH8hGCANLQAcRQ0AIA1BGGogDyAQIAMQRCANLQAcRQ0AIA1BGGogDyAQIAMQRSANLQAcQQNGDQAgDUEYaiAPIBAgAxBEIA0tABxBA0YNACALQQIgAyAAKgKUAyAUQQIgAxBLIBRBAiADEFKSkyAPQQIgAyAXEFEgD0ECIAMgFxCDAZKTIBcgFxAlIRgLIBwgG5IhHCALKgKABCEZAkACQAJAIAstAIQEQQFrDgIBAAILIBkgGpRDCtcjPJQhGQsgGUMAAAAAYEUNACAcIAsgA0EBIBogFxAxkiEZDAMLIA1BGGogDyALQTJqIhAQQwJAIA0tABxFDQAgDUEYaiAPIBAQQiANLQAcRQ0AIA1BGGogDyAQEEMgDS0AHEEDRg0AIA1BGGogDyAQEEIgDS0AHEEDRg0AIAtBACADIAAqApgDIBRBACADEEsgFEEAIAMQUpKTIA9BACADIBoQUSAPQQAgAyAaEIMBkpMgGiAXECUhGQwDC0MAAMB/IRkgGCAYXA0GIAtB/ABqIhAgC0H6AGoiEi8BABAgIhsgG1sNAwwFCyALLQAAQQhxDQggCxBPIAAgCyACIAstABRBA3EiDCAVIAwbIAQgFiAGIAsqApwDIAeSIAsqAqADIAiSIAkgChB+IBFyIQxBACERIAxBAXFFDQhBASERIAsgCy0AAEEBcjoAAAwICxACAAsgGCAYXCAZIBlcRg0BIAtB/ABqIhAgC0H6AGoiEi8BABAgIhsgG1wNASAYIBhcBEAgGSAckyAQIAsvAXoQIJQgHZIhGAwCCyAZIBlbDQELIBwgGCAdkyAQIBIvAQAQIJWSIRkLIBggGFwNASAZIBlbDQMLQQAMAQtBAQshEiALIBcgGCACQQFHIAxBAklxIBdDAAAAAF5xIBJxIhAbIBkgA0ECIBIgEBsgGSAZXCAXIBpBAEEGIAQgBSAGED0aIAsqApQDIA9BAkEBIBcQIiAPQQJBASAXECGSkiEYIAsqApgDIA9BAEEBIBcQIiAPQQBBASAXECGSkiEZC0EBIRAgCyAYIBkgA0EAQQAgFyAaQQFBASAEIAUgBhA9GiAAIAEgCyADIAxBASAXIBoQggEgACABIAsgAyAOQQAgFyAaEIIBIBFBAXFFBEAgCy0AAEEBcSEQCyABLQAUIhJBAnZBA3EhDAJAAn8CQAJAAkACQAJAAkACQAJAAkACfwJAIBNFBEBBACERQQMhDiAMQQJrDgIDDQELQQIhDkEAIAxBAUsNARoLIA4LIREgEkEEcUUNBCASQQhxRQ0BIAwhDgsgASEMIA8QXw0BDAILAkAgCy0ANEEHcQ0AIAstADhBB3ENACALLQBCQQdxDQAgDCEOIAEhDCALQUBrLwEAQQdxRQ0CDAELIAwhDgsgACEMCwJ/AkACQAJAIA5BAWsOAwABAgULIAtBmANqIQ4gC0GoA2ohE0EBIRIgDEGYA2oMAgsgC0GUA2ohDiALQZwDaiETQQIhEiAMQZQDagwBCyALQZQDaiEOIAtBpANqIRNBACESIAxBlANqCyEMIAsgEkECdGogDCoCACAOKgIAkyATKgIAkzgCnAMLIBFBAXFFDQUCQAJAIBFBAnEEQCABIQwgDxBfDQEMAgsgCy0ANEEHcQ0AIAstADhBB3ENACALLQBCQQdxDQAgASEMIAtBQGsvAQBBB3FFDQELIAAhDAsgEUEBaw4DAQIDAAsQJAALIAtBmANqIREgC0GoA2ohDkEBIRMgDEGYA2oMAgsgC0GUA2ohESALQZwDaiEOQQIhEyAMQZQDagwBCyALQZQDaiERIAtBpANqIQ5BACETIAxBlANqCyEMIAsgE0ECdGogDCoCACARKgIAkyAOKgIAkzgCnAMLIAsqAqADIRsgCyoCnAMgB0MAAAAAIA8QXxuTIRcCfQJAIAstADRBB3ENACALLQA4QQdxDQAgCy0AQkEHcQ0AIAtBQGsvAQBBB3ENAEMAAAAADAELIAgLIRogCyAXOAKcAyALIBsgGpM4AqADIBAhEQsgDUEIahAuIA0oAgwiDCANKAIIIg5yDQALCyANKAIQIgwEQANAIAwoAgAhACAMECMgACIMDQALCyANQSBqJAAgEUEBcQt2AgF/AX0jAEEQayIEJAAgBEEIaiAAIAFBAnRB7CVqKAIAIAIQUEMAAMB/IQUCQAJAAkAgBC0ADEEBaw4CAAECCyAEKgIIIQUMAQsgBCoCCCADlEMK1yM8lCEFCyAEQRBqJAAgBUMAAAAAl0MAAAAAIAUgBVsbC3gCAX8BfSMAQRBrIgQkACAEQQhqIABBAyACQQJHQQF0IAFB/gFxQQJHGyACEDZDAADAfyEFAkACQAJAIAQtAAxBAWsOAgABAgsgBCoCCCEFDAELIAQqAgggA5RDCtcjPJQhBQsgBEEQaiQAIAVDAAAAACAFIAVbGwt4AgF/AX0jAEEQayIEJAAgBEEIaiAAQQEgAkECRkEBdCABQf4BcUECRxsgAhA2QwAAwH8hBQJAAkACQCAELQAMQQFrDgIAAQILIAQqAgghBQwBCyAEKgIIIAOUQwrXIzyUIQULIARBEGokACAFQwAAAAAgBSAFWxsLoA0BBH8jAEEQayIJJAAgCUEIaiACQRRqIgggA0ECRkEBdEEBIARB/gFxQQJGIgobIgsgAxA2IAYgByAKGyEHAkACQAJAAkACQAJAIAktAAxFDQAgCUEIaiAIIAsgAxA2IAktAAxBA0YNACAIIAQgAyAHEIEBIABBFGogBCADEDCSIAggBCADIAcQIpIhBkEBIQMCQAJ/AkACQAJAAkAgBA4EAgMBAAcLQQIhAwwBC0EAIQMLIAMgC0YNAgJAAkAgBA4EAgIAAQYLIABBlANqIQNBAAwCCyAAQZQDaiEDQQAMAQsgAEGYA2ohA0EBCyEAIAMqAgAgAiAAQQJ0aioClAOTIAaTIQYLIAIgBEECdEHcJWooAgBBAnRqIAY4ApwDDAULIAlBCGogCCADQQJHQQF0QQMgChsiCiADEDYCQCAJLQAMRQ0AIAlBCGogCCAKIAMQNiAJLQAMQQNGDQACfwJAAkACQCAEDgQCAgABBQsgAEGUA2ohBUEADAILIABBlANqIQVBAAwBCyAAQZgDaiEFQQELIQEgBSoCACACQZQDaiIFIAFBAnRqKgIAkyAAQRRqIAQgAxAvkyAIIAQgAyAHECGTIAggBCADIAcQgAGTIQZBASEDAkACfwJAAkACQAJAIAQOBAIDAQAHC0ECIQMMAQtBACEDCyADIAtGDQICQAJAIAQOBAICAAEGCyAAQZQDaiEDQQAMAgsgAEGUA2ohA0EADAELIABBmANqIQNBAQshACADKgIAIAUgAEECdGoqAgCTIAaTIQYLIAIgBEECdEHcJWooAgBBAnRqIAY4ApwDDAULAkACQAJAIAUEQCABLQAUQQR2QQdxIgBBBUsNCEEBIAB0IgBBMnENASAAQQlxBEAgBEECdEHcJWooAgAhACAIIAQgAyAGEEEgASAAQQJ0IgBqIgEqArwDkiEGIAAgAmogAigC9AMtABRBAnEEfSAGBSAGIAEqAswDkgs4ApwDDAkLIAEgBEECdEHsJWooAgBBAnRqIgAqArwDIAggBCADIAYQYpIhBiACKAL0Ay0AFEECcUUEQCAGIAAqAswDkiEGCwJAAkACQAJAIAQOBAEBAgAICyABKgKUAyACKgKUA5MhB0ECIQMMAgsgASoCmAMgAioCmAOTIQdBASEDAkAgBA4CAgAHC0EDIQMMAQsgASoClAMgAioClAOTIQdBACEDCyACIANBAnRqIAcgBpM4ApwDDAgLIAIvABZBD3EiBUUEQCABLQAVQQR2IQULIAVBBUYEQCABLQAUQQhxRQ0CCyABLwAVQYCAA3FBgIACRgRAIAVBAmsOAgEHAwsgBUEISw0HQQEgBXRB8wNxDQYgBUECRw0CC0EAIQACfQJ/AkACQAJAAkACfwJAAkACQCAEDgQCAgABBAsgASoClAMhB0ECIQAgAUG8A2oMAgsgASoClAMhByABQcQDagwBCyABKgKYAyEHAkACQCAEDgIAAQMLQQMhACABQcADagwBC0EBIQAgAUHIA2oLIQUgByAFKgIAkyABQbwDaiIIIABBAnRqKgIAkyIHIAIoAvQDLQAUQQJxDQUaAkAgBA4EAAIDBAELQQMhACABQdADagwECxAkAAtBASEAIAFB2ANqDAILQQIhACABQcwDagwBC0EAIQAgAUHUA2oLIQUgByAFKgIAkyABIABBAnRqKgLMA5MLIAIgBEECdCIFQfwlaigCAEECdGoqApQDIAJBFGoiACAEQQEgBhAiIAAgBEEBIAYQIZKSk0MAAAA/lCAIIAVB3CVqKAIAIgVBAnRqKgIAkiAAIAQgAyAGEEGSIQYgAiAFQQJ0aiACKAL0Ay0AFEECcQR9IAYFIAYgASAFQQJ0aioCzAOSCzgCnAMMBgsgAS8AFUGAgANxQYCAAkcNBAsgASAEQQJ0QewlaigCAEECdGoiACoCvAMgCCAEIAMgBhBikiEGIAIoAvQDLQAUQQJxRQRAIAYgACoCzAOSIQYLAkACQCAEDgQBAQMAAgsgASoClAMgAioClAOTIQdBAiEDDAMLIAEqApgDIAIqApgDkyEHQQEhAwJAIAQOAgMAAQtBAyEDDAILECQACyABKgKUAyACKgKUA5MhB0EAIQMLIAIgA0ECdGogByAGkzgCnAMMAQsgBEECdEHcJWooAgAhACAIIAQgAyAGEEEgASAAQQJ0IgBqIgEqArwDkiEGIAAgAmogAigC9AMtABRBAnEEfSAGBSAGIAEqAswDkgs4ApwDCyAJQRBqJAALcAIBfwF9IwBBEGsiBCQAIARBCGogACABQQJ0QewlaigCACACEDZDAADAfyEFAkACQAJAIAQtAAxBAWsOAgABAgsgBCoCCCEFDAELIAQqAgggA5RDCtcjPJQhBQsgBEEQaiQAIAVDAAAAACAFIAVbGwscACAAIAFBCCACpyACQiCIpyADpyADQiCIpxAVCwUAEFgACzkAIABFBEBBAA8LAn8gAUGAf3FBgL8DRiABQf8ATXJFBEBB/DtBGTYCAEF/DAELIAAgAToAAEEBCwvEAgACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQCABQQlrDhIACgsMCgsCAwQFDAsMDAoLBwgJCyACIAIoAgAiAUEEajYCACAAIAEoAgA2AgAPCwALIAIgAigCACIBQQRqNgIAIAAgATIBADcDAA8LIAIgAigCACIBQQRqNgIAIAAgATMBADcDAA8LIAIgAigCACIBQQRqNgIAIAAgATAAADcDAA8LIAIgAigCACIBQQRqNgIAIAAgATEAADcDAA8LAAsgAiACKAIAQQdqQXhxIgFBCGo2AgAgACABKwMAOQMADwsgACACIAMRAQALDwsgAiACKAIAIgFBBGo2AgAgACABNAIANwMADwsgAiACKAIAIgFBBGo2AgAgACABNQIANwMADwsgAiACKAIAQQdqQXhxIgFBCGo2AgAgACABKQMANwMAC84BAgN/An0jAEEQayIDJABBASEEIANBCGogAEH8AGoiBSAAIAFBAXRqQegAaiIBLwEAEB8CQAJAIAMqAggiByACKgIAIgZcBEAgByAHWwRAIAItAAQhAgwCCyAGIAZcIQQLIAItAAQhAiAERQ0AIAMtAAwgAkH/AXFGDQELIAUgASAGIAIQOQNAIAAtAAAiAUEEcQ0BIAAgAUEEcjoAACAAKAIQIgEEQCAAIAERAAALIABBgICA/gc2ApwBIAAoAuQDIgANAAsLIANBEGokAAtdAQR/IAAoAgAhAgNAIAIsAAAiAxBXBEBBfyEEIAAgAkEBaiICNgIAIAFBzJmz5gBNBH9BfyADQTBrIgMgAUEKbCIEaiADIARB/////wdzShsFIAQLIQEMAQsLIAELrhQCEn8BfiMAQdAAayIIJAAgCCABNgJMIAhBN2ohFyAIQThqIRQCQAJAAkACQANAIAEhDSAHIA5B/////wdzSg0BIAcgDmohDgJAAkACQCANIgctAAAiCQRAA0ACQAJAIAlB/wFxIgFFBEAgByEBDAELIAFBJUcNASAH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IQEgAEIANwIEIAAgATYCACABIAA2AgQgAkEQaiQAIAALGwEBfyAABEAgACgCACIBBEAgARAjCyAAECMLC0kBAn9BBBAeIQFBIBAeIgBBADYCHCAAQoCAgICAgIDAPzcCFCAAQgA3AgwgAEEAOgAIIABBAzYCBCAAQQA2AgAgASAANgIAIAELIAAgAkEFR0EAIAIbRQRAQbgwIAMgBBBJDwsgAyAEEHALIgEBfiABIAKtIAOtQiCGhCAEIAARFQAiBUIgiKckASAFpwuoAQEFfyAAKAJUIgMoAgAhBSADKAIEIgQgACgCFCAAKAIcIgdrIgYgBCAGSRsiBgRAIAUgByAGECsaIAMgAygCACAGaiIFNgIAIAMgAygCBCAGayIENgIECyAEIAIgAiAESxsiBARAIAUgASAEECsaIAMgAygCACAEaiIFNgIAIAMgAygCBCAEazYCBAsgBUEAOgAAIAAgACgCLCIBNgIcIAAgATYCFCACCwQAQgALBABBAAuKBQIGfgJ/IAEgASgCAEEHakF4cSIBQRBqNgIAIAAhCSABKQMAIQMgASkDCCEGIwBBIGsiCCQAAkAgBkL///////////8AgyIEQoCAgICAgMCAPH0gBEKAgICAgIDA/8MAfVQEQCAGQgSGIANCPIiEIQQgA0L//////////w+DIgNCgYCAgICAgIAIWgRAIARCgYCAgICAgIDAAHwhAgwCCyAEQoCAgICAgICAQH0hAiADQoCAgICAgICACFINASACIARCAYN8IQIMAQsgA1AgBEKAgICAgIDA//8AVCAEQoCAgICAgMD//wBRG0UEQCAGQgSGIANCPIiEQv////////8Dg0KAgICAgICA/P8AhCECDAELQoCAgICAgID4/wAhAiAEQv///////7//wwBWDQBCACECIARCMIinIgBBkfcASQ0AIAMhAiAGQv///////z+DQoCAgICAgMAAhCIFIQcCQCAAQYH3AGsiAUHAAHEEQCACIAFBQGqthiEHQgAhAgwBCyABRQ0AIAcgAa0iBIYgAkHAACABa62IhCEHIAIgBIYhAgsgCCACNwMQIAggBzcDGAJAQYH4ACAAayIAQcAAcQRAIAUgAEFAaq2IIQNCACEFDAELIABFDQAgBUHAACAAa62GIAMgAK0iAoiEIQMgBSACiCEFCyAIIAM3AwAgCCAFNwMIIAgpAwhCBIYgCCkDACIDQjyIhCECIAgpAxAgCCkDGIRCAFKtIANC//////////8Pg4QiA0KBgICAgICAgAhaBEAgAkIBfCECDAELIANCgICAgICAgIAIUg0AIAJCAYMgAnwhAgsgCEEgaiQAIAkgAiAGQoCAgICAgICAgH+DhL85AwALmRgDEn8BfAN+IwBBsARrIgwkACAMQQA2AiwCQCABvSIZQgBTBEBBASERQZkJIRMgAZoiAb0hGQwBCyAEQYAQcQRAQQEhEUGcCSETDAELQZ8JQZoJIARBAXEiERshEyARRSEVCwJAIBlCgICAgICAgPj/AINCgICAgICAgPj/AFEEQCAAQSAgAiARQQNqIgMgBEH//3txECkgACATIBEQJiAAQe0VQdweIAVBIHEiBRtB4RpB4B4gBRsgASABYhtBAxAmIABBICACIAMgBEGAwABzECkgAyACIAIgA0gbIQoMAQsgDEEQaiESAkACfwJAIAEgDEEsahCMASIBIAGgIgFEAAAAAAAAAABiBEAgDCAMKAIsIgZBAWs2AiwgBUEgciIOQeEARw0BDAMLIAVBIHIiDkHhAEYNAiAMKAIsIQlBBiADIANBAEgbDAELIAwgBkEdayIJNgIsIAFEAAAAAAAAsEGiIQFBBiADIANBAEgbCyELIAxBMGpBoAJBACAJQQBOG2oiDSEHA0AgBwJ/IAFEAAAAAAAA8EFjIAFEAAAAAAAAAABmcQRAIAGrDAELQQALIgM2AgAgB0EEaiEHIAEgA7ihRAAAAABlzc1BoiIBRAAAAAAAAAAAYg0ACwJAIAlBAEwEQCAJIQMgByEGIA0hCAwBCyANIQggCSEDA0BBHSADIANBHU4bIQMCQCAHQQRrIgYgCEkNACADrSEaQgAhGQNAIAYgGUL/////D4MgBjUCACAahnwiG0KAlOvcA4AiGUKA7JSjDH4gG3w+AgAgBkEEayIGIAhPDQALIBmnIgZFDQAgCEEEayIIIAY2AgALA0AgCCAHIgZJBEAgBkEEayIHKAIARQ0BCwsgDCAMKAIsIANrIgM2AiwgBiEHIANBAEoNAAsLIANBAEgEQCALQRlqQQluQQFqIQ8gDkHmAEYhEANAQQlBACADayIDIANBCU4bIQoCQCAGIAhNBEAgCCgCACEHDAELQYCU69wDIAp2IRRBfyAKdEF/cyEWQQAhAyAIIQcDQCAHIAMgBygCACIXIAp2ajYCACAWIBdxIBRsIQMgB0EEaiIHIAZJDQALIAgoAgAhByADRQ0AIAYgAzYCACAGQQRqIQYLIAwgDCgCLCAKaiIDNgIsIA0gCCAHRUECdGoiCCAQGyIHIA9BAnRqIAYgBiAHa0ECdSAPShshBiADQQBIDQALC0EAIQMCQCAGIAhNDQAgDSAIa0ECdUEJbCEDQQohByAIKAIAIgpBCkkNAANAIANBAWohAyAKIAdBCmwiB08NAAsLIAsgA0EAIA5B5gBHG2sgDkHnAEYgC0EAR3FrIgcgBiANa0ECdUEJbEEJa0gEQEEEQaQCIAlBAEgbIAxqIAdBgMgAaiIKQQltIg9BAnRqQdAfayEJQQohByAPQXdsIApqIgpBB0wEQANAIAdBCmwhByAKQQFqIgpBCEcNAAsLAkAgCSgCACIQIBAgB24iDyAHbCIKRiAJQQRqIhQgBkZxDQAgECAKayEQAkAgD0EBcUUEQEQAAAAAAABAQyEBIAdBgJTr3ANHIAggCU9yDQEgCUEEay0AAEEBcUUNAQtEAQAAAAAAQEMhAQtEAAAAAAAA4D9EAAAAAAAA8D9EAAAAAAAA+D8gBiAURhtEAAAAAAAA+D8gECAHQQF2IhRGGyAQIBRJGyEYAkAgFQ0AIBMtAABBLUcNACAYmiEYIAGaIQELIAkgCjYCACABIBigIAFhDQAgCSAHIApqIgM2AgAgA0GAlOvcA08EQANAIAlBADYCACAIIAlBBGsiCUsEQCAIQQRrIghBADYCAAsgCSAJKAIAQQFqIgM2AgAgA0H/k+vcA0sNAAsLIA0gCGtBAnVBCWwhA0EKIQcgCCgCACIKQQpJDQADQCADQQFqIQMgCiAHQQpsIgdPDQALCyAJQQRqIgcgBiAGIAdLGyEGCwNAIAYiByAITSIKRQRAIAdBBGsiBigCAEUNAQsLAkAgDkHnAEcEQCAEQQhxIQkMAQsgA0F/c0F/IAtBASALGyIGIANKIANBe0pxIgkbIAZqIQtBf0F+IAkbIAVqIQUgBEEIcSIJDQBBdyEGAkAgCg0AIAdBBGsoAgAiDkUNAEEKIQpBACEGIA5BCnANAANAIAYiCUEBaiEGIA4gCkEKbCIKcEUNAAsgCUF/cyEGCyAHIA1rQQJ1QQlsIQogBUFfcUHGAEYEQEEAIQkgCyAGIApqQQlrIgZBACAGQQBKGyIGIAYgC0obIQsMAQtBACEJIAsgAyAKaiAGakEJayIGQQAgBkEAShsiBiAGIAtKGyELC0F/IQogC0H9////B0H+////ByAJIAtyIhAbSg0BIAsgEEEAR2pBAWohDgJAIAVBX3EiFUHGAEYEQCADIA5B/////wdzSg0DIANBACADQQBKGyEGDAELIBIgAyADQR91IgZzIAZrrSASEEciBmtBAUwEQANAIAZBAWsiBkEwOgAAIBIgBmtBAkgNAAsLIAZBAmsiDyAFOgAAIAZBAWtBLUErIANBAEgbOgAAIBIgD2siBiAOQf////8Hc0oNAgsgBiAOaiIDIBFB/////wdzSg0BIABBICACIAMgEWoiBSAEECkgACATIBEQJiAAQTAgAiAFIARBgIAEcxApAkACQAJAIBVBxgBGBEAgDEEQaiIGQQhyIQMgBkEJciEJIA0gCCAIIA1LGyIKIQgDQCAINQIAIAkQRyEGAkAgCCAKRwRAIAYgDEEQak0NAQNAIAZBAWsiBkEwOgAAIAYgDEEQaksNAAsMAQsgBiAJRw0AIAxBMDoAGCADIQYLIAAgBiAJIAZrECYgCEEEaiIIIA1NDQALIBAEQCAAQYwlQQEQJgsgC0EATCAHIAhNcg0BA0AgCDUCACAJEEciBiAMQRBqSwRAA0AgBkEBayIGQTA6AAAgBiAMQRBqSw0ACwsgACAGQQkgCyALQQlOGxAmIAtBCWshBiAIQQRqIgggB08NAyALQQlKIQMgBiELIAMNAAsMAgsCQCALQQBIDQAgByAIQQRqIAcgCEsbIQogDEEQaiIGQQhyIQMgBkEJciENIAghBwNAIA0gBzUCACANEEciBkYEQCAMQTA6ABggAyEGCwJAIAcgCEcEQCAGIAxBEGpNDQEDQCAGQQFrIgZBMDoAACAGIAxBEGpLDQALDAELIAAgBkEBECYgBkEBaiEGIAkgC3JFDQAgAEGMJUEBECYLIAAgBiALIA0gBmsiBiAGIAtKGxAmIAsgBmshCyAHQQRqIgcgCk8NASALQQBODQALCyAAQTAgC0ESakESQQAQKSAAIA8gEiAPaxAmDAILIAshBgsgAEEwIAZBCWpBCUEAECkLIABBICACIAUgBEGAwABzECkgBSACIAIgBUgbIQoMAQsgEyAFQRp0QR91QQlxaiELAkAgA0ELSw0AQQwgA2shBkQAAAAAAAAwQCEYA0AgGEQAAAAAAAAwQKIhGCAGQQFrIgYNAAsgCy0AAEEtRgRAIBggAZogGKGgmiEBDAELIAEgGKAgGKEhAQsgEUECciEJIAVBIHEhCCASIAwoAiwiByAHQR91IgZzIAZrrSASEEciBkYEQCAMQTA6AA8gDEEPaiEGCyAGQQJrIg0gBUEPajoAACAGQQFrQS1BKyAHQQBIGzoAACAEQQhxIQYgDEEQaiEHA0AgByIFAn8gAZlEAAAAAAAA4EFjBEAgAaoMAQtBgICAgHgLIgdBkC9qLQAAIAhyOgAAIAYgA0EASnJFIAEgB7ehRAAAAAAAADBAoiIBRAAAAAAAAAAAYXEgBUEBaiIHIAxBEGprQQFHckUEQCAFQS46AAEgBUECaiEHCyABRAAAAAAAAAAAYg0AC0F/IQpB/f///wcgCSASIA1rIgVqIgZrIANIDQAgAEEgIAIgBgJ/AkAgA0UNACAHIAxBEGprIghBAmsgA04NACADQQJqDAELIAcgDEEQamsiCAsiB2oiAyAEECkgACALIAkQJiAAQTAgAiADIARBgIAEcxApIAAgDEEQaiAIECYgAEEwIAcgCGtBAEEAECkgACANIAUQJiAAQSAgAiADIARBgMAAcxApIAMgAiACIANIGyEKCyAMQbAEaiQAIAoLRgEBfyAAKAI8IQMjAEEQayIAJAAgAyABpyABQiCIpyACQf8BcSAAQQhqEBQQjQEhAiAAKQMIIQEgAEEQaiQAQn8gASACGwu+AgEHfyMAQSBrIgMkACADIAAoAhwiBDYCECAAKAIUIQUgAyACNgIcIAMgATYCGCADIAUgBGsiATYCFCABIAJqIQVBAiEGIANBEGohAQJ/A0ACQAJAAkAgACgCPCABIAYgA0EMahAYEI0BRQRAIAUgAygCDCIHRg0BIAdBAE4NAgwDCyAFQX9HDQILIAAgACgCLCIBNgIcIAAgATYCFCAAIAEgACgCMGo2AhAgAgwDCyABIAcgASgCBCIISyIJQQN0aiIEIAcgCEEAIAkbayIIIAQoAgBqNgIAIAFBDEEEIAkbaiIBIAEoAgAgCGs2AgAgBSAHayEFIAYgCWshBiAEIQEMAQsLIABBADYCHCAAQgA3AxAgACAAKAIAQSByNgIAQQAgBkECRg0AGiACIAEoAgRrCyEEIANBIGokACAECwkAIAAoAjwQGQsjAQF/Qcg7KAIAIgAEQANAIAAoAgARCQAgACgCBCIADQALCwu/AgEFfyMAQeAAayICJAAgAiAANgIAIwBBEGsiAyQAIAMgAjYCDCMAQZABayIAJAAgAEGgL0GQARArIgAgAkEQaiIFIgE2AiwgACABNgIUIABB/////wdBfiABayIEIARB/////wdPGyIENgIwIAAgASAEaiIBNgIcIAAgATYCECAAQbsTIAJBAEEAEIsBGiAEBEAgACgCFCIBIAEgACgCEEZrQQA6AAALIABBkAFqJAAgA0EQaiQAAkAgBSIAQQNxBEADQCAALQAARQ0CIABBAWoiAEEDcQ0ACwsDQCAAIgFBBGohACABKAIAIgNBf3MgA0GBgoQIa3FBgIGChHhxRQ0ACwNAIAEiAEEBaiEBIAAtAAANAAsLIAAgBWtBAWoiABBhIgEEfyABIAUgABArBUEACyEAIAJB4ABqJAAgAAvFAQICfwF8IwBBMGsiBiQAIAEoAgghBwJAQbQ7LQAAQQFxBEBBsDsoAgAhAQwBC0EFQZAnEAwhAUG0O0EBOgAAQbA7IAE2AgALIAYgBTYCKCAGIAQ4AiAgBiADNgIYIAYgAjgCEAJ/IAEgB0GXGyAGQQxqIAZBEGoQEiIIRAAAAAAAAPBBYyAIRAAAAAAAAAAAZnEEQCAIqwwBC0EACyEBIAYoAgwhAyAAIAEpAwA3AwAgACABKQMINwMIIAMQESAGQTBqJAALCQAgABCQARAjCwwAIAAoAghB6BwQZgsJACAAEJIBECMLVQECfyMAQTBrIgIkACABIAAoAgQiA0EBdWohASAAKAIAIQAgAiABIANBAXEEfyABKAIAIABqKAIABSAACxEBAEEwEB4gAkEwECshACACQTBqJAAgAAs7AQF/IAEgACgCBCIFQQF1aiEBIAAoAgAhACABIAIgAyAEIAVBAXEEfyABKAIAIABqKAIABSAACxEdAAs3AQF/IAEgACgCBCIDQQF1aiEBIAAoAgAhACABIAIgA0EBcQR/IAEoAgAgAGooAgAFIAALERIACzcBAX8gASAAKAIEIgNBAXVqIQEgACgCACEAIAEgAiADQQFxBH8gASgCACAAaigCAAUgAAsRDAALNQEBfyABIAAoAgQiAkEBdWohASAAKAIAIQAgASACQQFxBH8gASgCACAAaigCAAUgAAsRCwALYQECfyMAQRBrIgIkACABIAAoAgQiA0EBdWohASAAKAIAIQAgAiABIANBAXEEfyABKAIAIABqKAIABSAACxEBAEEQEB4iACACKQMINwMIIAAgAikDADcDACACQRBqJAAgAAtjAQJ/IwBBEGsiAyQAIAEgACgCBCIEQQF1aiEBIAAoAgAhACADIAEgAiAEQQFxBH8gASgCACAAaigCAAUgAAsRAwBBEBAeIgAgAykDCDcDCCAAIAMpAwA3AwAgA0EQaiQAIAALNwEBfyABIAAoAgQiA0EBdWohASAAKAIAIQAgASACIANBAXEEfyABKAIAIABqKAIABSAACxEEAAs5AQF/IAEgACgCBCIEQQF1aiEBIAAoAgAhACABIAIgAyAEQQFxBH8gASgCACAAaigCAAUgAAsRCAALCQAgASAAEQIACwUAQcM7Cw8AIAEgACgCAGogAjYCAAsNACABIAAoAgBqKAIACxgBAX9BEBAeIgBCADcDCCAAQQA2AgAgAAsYAQF/QRAQHiIAQgA3AwAgAEIANwMIIAALDABBMBAeQQBBMBAqCzcBAX8gASAAKAIEIgNBAXVqIQEgACgCACEAIAEgAiADQQFxBH8gASgCACAAaigCAAUgAAsRHgALBQBBvjsLIQAgACABKAIAIAEgASwAC0EASBtBuzsgAigCABAQNgIACyoBAX9BDBAeIgFBADoABCABIAAoAgA2AgggAEEANgIAIAFB2Cc2AgAgAQsFAEG7OwsFAEG4OwshACAAIAEoAgAgASABLAALQQBIG0GkOyACKAIAEBA2AgAL2AEBBH8jAEEgayIDJAAgASgCACIEQfD///8HSQRAAkACQCAEQQtPBEAgBEEPckEBaiIFEB4hBiADIAVBgICAgHhyNgIQIAMgBjYCCCADIAQ2AgwgBCAGaiEFDAELIAMgBDoAEyADQQhqIgYgBGohBSAERQ0BCyAGIAFBBGogBBArGgsgBUEAOgAAIAMgAjYCACADQRhqIANBCGogAyAAEQMAIAMoAhgQHSADKAIYIgAQBiADKAIAEAYgAywAE0EASARAIAMoAggQIwsgA0EgaiQAIAAPCxACAAsqAQF/QQwQHiIBQQA6AAQgASAAKAIANgIIIABBADYCACABQeAmNgIA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AkEIaiAIIAYQHyACIAcgAC8AABAfQQEhAyACKgIIIgogAioCACILXAR/IAogClsNAyALIAtcBSADC0UNAiACLQAMIAItAARHDQILIABBAmohAEEBIQMgBCEGQQEhBCAGRQ0ACyABLwB6IgBBB3FFBEAgBS0AekEHcUUNAgsgCCAAECAiCiAHIAUvAHoQICILWw0BIAogClsNACALIAtcDQELIAFBFGogBUEUakHoABArGiABQfwAaiAFQfwAahCgAQNAIAEtAAAiAEEEcQ0BIAEgAEEEcjoAACABKAIQIgAEQCABIAARAAALIAFBgICA/gc2ApwBIAEoAuQDIgENAAsLIAJBEGokAAvGAwEEfyMAQaAEayICJAAgACgCBCEBIABBADYCBCABBEAgASABKAIAKAIEEQAACyAAKAIIIQEgAEEANgIIIAEEQCABIAEoAgAoAgQRAAALAkAgACgCACIAKALoAyAAKALsA0YEQCAAKALkAw0BIAAgAkEYaiAAKAL0AxBcIgEpAgA3AgAgACABKAIQNgIQIAAgASkCCDcCCCAAQRRqIAFBFGpB6AAQKxogACABKQKMATcCjAEgACABKQKEATcChAEgACABKQJ8NwJ8IAEoApQBIQQgAUEANgKUASAAKAKUASEDIAAgBDYClAEgAwRAIAMQWwsgAEGYAWogAUGYAWpB0AIQKxogACgC6AMiAwRAIAAgAzYC7AMgAxAjCyAAIAEoAugDNgLoAyAAIAEoAuwDNgLsAyAAIAEoAvADNgLwAyABQQA2AvADIAFCADcC6AMgACABKQL8AzcC/AMgACABKQL0AzcC9AMgACABKAKEBDYChAQgASgClAEhACABQQA2ApQBIAAEQCAAEFsLIAJBoARqJAAPCyACQfAcNgIQIABBBUHYJSACQRBqECwQJAALIAJB5hE2AgAgAEEFQdglIAIQLBAkAAsLAEEMEB4gABCiAQsLAEEMEB5BABCiAQsNACAAKAIALQAIQQFxCwoAIAAoAgAoAhQLGQAgAUH/AXEEQBACAAsgACgCACgCEEEBcQsYACAAKAIAIgAgAC0ACEH+AXEgAXI6AAgLJgAgASAAKAIAIgAoAhRHBEAgACABNgIUIAAgACgCDEEBajYCDAsLkgEBAn8jAEEQayICJAAgACgCACEAIAFDAAAAAGAEQCABIAAqAhhcBEAgACABOAIYIAAgACgCDEEBajYCDAsgAkEQaiQADwsgAkGIFDYCACMAQRBrIgMkACADIAI2AgwCQCAARQRAQbgwQdglIAIQSRoMAQsgAEEAQQVB2CUgAiAAKAIEEQ0AGgsgA0EQaiQAECQACz8AIAFB/wFxRQRAIAIgACgCACIAKAIQIgFBAXFHBEAgACABQX5xIAJyNgIQIAAgACgCDEEBajYCDAsPCxACAAsL4CYjAEGACAuBHk9ubHkgbGVhZiBub2RlcyB3aXRoIGN1c3RvbSBtZWFzdXJlIGZ1bmN0aW9ucyBzaG91bGQgbWFudWFsbHkgbWFyayB0aGVtc2VsdmVzIGFzIGRpcnR5AGlzRGlydHkAbWFya0RpcnR5AGRlc3Ryb3kAc2V0RGlzcGxheQBnZXREaXNwbGF5AHNldEZsZXgALSsgICAwWDB4AC0wWCswWCAwWC0weCsweCAweABzZXRGbGV4R3JvdwBnZXRGbGV4R3JvdwBzZXRPdmVyZmxvdwBnZXRPdmVyZmxvdwBoYXNOZXdMYXlvdXQAY2FsY3VsYXRlTGF5b3V0AGdldENvbXB1dGVkTGF5b3V0AHVuc2lnbmVkIHNob3J0AGdldENoaWxkQ291bnQAdW5zaWduZWQgaW50AHNldEp1c3RpZnlDb250ZW50AGdldEp1c3RpZnlDb250ZW50AGF2YWlsYWJsZUhlaWdodCBpcyBpbmRlZmluaXRlIHNvIGhlaWdodFNpemluZ01vZGUgbXVzdCBiZSBTaXppbmdNb2RlOjpNYXhDb250ZW50AGF2YWlsYWJsZVdpZHRoIGlzIGluZGVmaW5pdGUgc28gd2lkdGhTaXppbmdNb2RlIG11c3QgYmUgU2l6aW5nTW9kZTo6TWF4Q29udGVudABzZXRBbGlnbkNvbnRlbnQAZ2V0QWxpZ25Db250ZW50AGdldFBhcmVudABpbXBsZW1lbnQAc2V0TWF4SGVpZ2h0UGVyY2VudABzZXRIZWlnaHRQZXJjZW50AHNldE1pbkhlaWdodFBlcmNlbnQAc2V0RmxleEJhc2lzUGVyY2VudABzZXRHYXBQZXJjZW50AHNldFBvc2l0aW9uUGVyY2VudABzZXRNYXJnaW5QZXJjZW50AHNldE1heFdpZHRoUGVyY2VudABzZXRXaWR0aFBlcmNlbnQAc2V0TWluV2lkdGhQZXJjZW50AHNldFBhZGRpbmdQZXJjZW50AGhhbmRsZS50eXBlKCkgPT0gU3R5bGVWYWx1ZUhhbmRsZTo6VHlwZTo6UG9pbnQgfHwgaGFuZGxlLnR5cGUoKSA9PSBTdHlsZVZhbHVlSGFuZGxlOjpUeXBlOjpQZXJjZW50AGNyZWF0ZURlZmF1bHQAdW5pdAByaWdodABoZWlnaHQAc2V0TWF4SGVpZ2h0AGdldE1heEhlaWdodABzZXRIZWlnaHQAZ2V0SGVpZ2h0AHNldE1pbkhlaWdodABnZXRNaW5IZWlnaHQAZ2V0Q29tcHV0ZWRIZWlnaHQAZ2V0Q29tcHV0ZWRSaWdodABsZWZ0AGdldENvbXB1dGVkTGVmdAByZXNldABfX2Rlc3RydWN0AGZsb2F0AHVpbnQ2NF90AHVzZVdlYkRlZmF1bHRzAHNldFVzZVdlYkRlZmF1bHRzAHNldEFsaWduSXRlbXMAZ2V0QWxpZ25JdGVtcwBzZXRGbGV4QmFzaXMAZ2V0RmxleEJhc2lzAENhbm5vdCBnZXQgbGF5b3V0IHByb3BlcnRpZXMgb2YgbXVsdGktZWRnZSBzaG9ydGhhbmRzAHNldFBvaW50U2NhbGVGYWN0b3IATWVhc3VyZUNhbGxiYWNrV3JhcHBlcgBEaXJ0aWVkQ2FsbGJhY2tXcmFwcGVyAENhbm5vdCByZXNldCBhIG5vZGUgc3RpbGwgYXR0YWNoZWQgdG8gYSBvd25lcgBzZXRCb3JkZXIAZ2V0Qm9yZGVyAGdldENvbXB1dGVkQm9yZGVyAGdldE51bWJlcgBoYW5kbGUudHlwZSgpID09IFN0eWxlVmFsdWVIYW5kbGU6OlR5cGU6Ok51bWJlcgB1bnNpZ25lZCBjaGFyAHRvcABnZXRDb21wdXRlZFRvcABzZXRGbGV4V3JhcABnZXRGbGV4V3JhcABzZXRHYXAAZ2V0R2FwACVwAHNldEhlaWdodEF1dG8Ac2V0RmxleEJhc2lzQXV0bwBzZXRQb3NpdGlvbkF1dG8Ac2V0TWFyZ2luQXV0bwBzZXRXaWR0aEF1dG8AU2NhbGUgZmFjdG9yIHNob3VsZCBub3QgYmUgbGVzcyB0aGFuIHplcm8Ac2V0QXNwZWN0UmF0aW8AZ2V0QXNwZWN0UmF0aW8Ac2V0UG9zaXRpb24AZ2V0UG9zaXRpb24Abm90aWZ5T25EZXN0cnVjdGlvbgBzZXRGbGV4RGlyZWN0aW9uAGdldEZsZXhEaXJlY3Rpb24Ac2V0RGlyZWN0aW9uAGdldERpcmVjdGlvbgBzZXRNYXJnaW4AZ2V0TWFyZ2luAGdldENvbXB1dGVkTWFyZ2luAG1hcmtMYXlvdXRTZWVuAG5hbgBib3R0b20AZ2V0Q29tcHV0ZWRCb3R0b20AYm9vbABlbXNjcmlwdGVuOjp2YWwAc2V0RmxleFNocmluawBnZXRGbGV4U2hyaW5rAHNldEFsd2F5c0Zvcm1zQ29udGFpbmluZ0Jsb2NrAE1lYXN1cmVDYWxsYmFjawBEaXJ0aWVkQ2FsbGJhY2sAZ2V0TGVuZ3RoAHdpZHRoAHNldE1heFdpZHRoAGdldE1heFdpZHRoAHNldFdpZHRoAGdldFdpZHRoAHNldE1pbldpZHRoAGdldE1pbldpZHRoAGdldENvbXB1dGVkV2lkdGgAcHVzaAAvaG9tZS9ydW5uZXIvd29yay95b2dhL3lvZ2EvamF2YXNjcmlwdC8uLi95b2dhL3N0eWxlL1NtYWxsVmFsdWVCdWZmZXIuaAAvaG9tZS9ydW5uZXIvd29yay95b2dhL3lvZ2EvamF2YXNjcmlwdC8uLi95b2dhL3N0eWxlL1N0eWxlVmFsdWVQb29sLmgAdW5zaWduZWQgbG9uZwBzZXRCb3hTaXppbmcAZ2V0Qm94U2l6aW5nAHN0ZDo6d3N0cmluZwBzdGQ6OnN0cmluZwBzdGQ6OnUxNnN0cmluZwBzdGQ6OnUzMnN0cmluZwBzZXRQYWRkaW5nAGdldFBhZGRpbmcAZ2V0Q29tcHV0ZWRQYWRkaW5nAFRyaWVkIHRvIGNvbnN0cnVjdCBZR05vZGUgd2l0aCBudWxsIGNvbmZpZwBBdHRlbXB0aW5nIHRvIGNvbnN0cnVjdCBOb2RlIHdpdGggbnVsbCBjb25maWcAY3JlYXRlV2l0aENvbmZpZwBpbmYAc2V0QWxpZ25TZWxmAGdldEFsaWduU2VsZgBTaXplAHZhbHVlAFZhbHVlAGNyZWF0ZQBtZWFzdXJlAHNldFBvc2l0aW9uVHlwZQBnZXRQb3NpdGlvblR5cGUAaXNSZWZlcmVuY2VCYXNlbGluZQBzZXRJc1JlZmVyZW5jZUJhc2VsaW5lAGNvcHlTdHlsZQBkb3VibGUATm9kZQBleHRlbmQAaW5zZXJ0Q2hpbGQAZ2V0Q2hpbGQAcmVtb3ZlQ2hpbGQAdm9pZABzZXRFeHBlcmltZW50YWxGZWF0dXJlRW5hYmxlZABpc0V4cGVyaW1lbnRhbEZlYXR1cmVFbmFibGVkAGRpcnRpZWQAQ2Fubm90IHJlc2V0IGEgbm9kZSB3aGljaCBzdGlsbCBoYXMgY2hpbGRyZW4gYXR0YWNoZWQAdW5zZXRNZWFzdXJlRnVuYwB1bnNldERpcnRpZWRGdW5jAHNldEVycmF0YQBnZXRFcnJhdGEATWVhc3VyZSBmdW5jdGlvbiByZXR1cm5lZCBhbiBpbnZhbGlkIGRpbWVuc2lvbiB0byBZb2dhOiBbd2lkdGg9JWYsIGhlaWdodD0lZl0ARXhwZWN0IGN1c3RvbSBiYXNlbGluZSBmdW5jdGlvbiB0byBub3QgcmV0dXJuIE5hTgBOQU4ASU5GAGVtc2NyaXB0ZW46Om1lbW9yeV92aWV3PHNob3J0PgBlbXNjcmlwdGVuOjptZW1vcnlfdmlldzx1bnNpZ25lZCBzaG9ydD4AZW1zY3JpcHRlbjo6bWVtb3J5X3ZpZXc8aW50PgBlbXNjcmlwdGVuOjptZW1vcnlfdmlldzx1bnNpZ25lZCBpbnQ+AGVtc2NyaXB0ZW46Om1lbW9yeV92aWV3PGZsb2F0PgBlbXNjcmlwdGVuOjptZW1vcnlfdmlldzx1aW50OF90PgBlbXNjcmlwdGVuOjptZW1vcnlfdmlldzxpbnQ4X3Q+AGVtc2NyaXB0ZW46Om1lbW9yeV92aWV3PHVpbnQxNl90PgBlbXNjcmlwdGVuOjptZW1vcnlfdmlldzxpbnQxNl90PgBlbXNjcmlwdGVuOjptZW1vcnlfdmlldzx1aW50MzJfdD4AZW1zY3JpcHRlbjo6bWVtb3J5X3ZpZXc8aW50MzJfdD4AZW1zY3JpcHRlbjo6bWVtb3J5X3ZpZXc8Y2hhcj4AZW1zY3JpcHRlbjo6bWVtb3J5X3ZpZXc8dW5zaWduZWQgY2hhcj4Ac3RkOjpiYXNpY19zdHJpbmc8dW5zaWduZWQgY2hhcj4AZW1zY3JpcHRlbjo6bWVtb3J5X3ZpZXc8c2lnbmVk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";
		if (!ua(H)) {
			var va = H;
			H = h.locateFile ? h.locateFile(va, q) : q + va;
		}
		function wa() {
			var a = H;
			try {
				if (a == H && w) return new Uint8Array(w);
				if (ua(a)) try {
					var b = xa(a.slice(37)), c = new Uint8Array(b.length);
					for (a = 0; a < b.length; ++a) c[a] = b.charCodeAt(a);
					var d = c;
				} catch (f) {
					throw Error("Converting base64 string to bytes failed.");
				}
				else d = void 0;
				var e = d;
				if (e) return e;
				throw "both async and sync fetching of the wasm failed";
			} catch (f) {
				x(f);
			}
		}
		function ya() {
			return w || "function" != typeof fetch ? Promise.resolve().then(function() {
				return wa();
			}) : fetch(H, { credentials: "same-origin" }).then(function(a) {
				if (!a.ok) throw "failed to load wasm binary file at '" + H + "'";
				return a.arrayBuffer();
			}).catch(function() {
				return wa();
			});
		}
		function za(a) {
			for (; 0 < a.length;) a.shift()(h);
		}
		function Aa(a) {
			if (void 0 === a) return "_unknown";
			a = a.replace(/[^a-zA-Z0-9_]/g, "$");
			var b = a.charCodeAt(0);
			return 48 <= b && 57 >= b ? "_" + a : a;
		}
		function Ba(a, b) {
			a = Aa(a);
			return function() {
				return b.apply(this, arguments);
			};
		}
		var J = [
			{},
			{ value: void 0 },
			{ value: null },
			{ value: !0 },
			{ value: !1 }
		], Ca = [];
		function Da(a) {
			var b = Error, c = Ba(a, function(d) {
				this.name = a;
				this.message = d;
				d = Error(d).stack;
				void 0 !== d && (this.stack = this.toString() + "\n" + d.replace(/^Error(:[^\n]*)?\n/, ""));
			});
			c.prototype = Object.create(b.prototype);
			c.prototype.constructor = c;
			c.prototype.toString = function() {
				return void 0 === this.message ? this.name : this.name + ": " + this.message;
			};
			return c;
		}
		var K = void 0;
		function L(a) {
			throw new K(a);
		}
		var M = (a) => {
			a || L("Cannot use deleted val. handle = " + a);
			return J[a].value;
		}, Ea = (a) => {
			switch (a) {
				case void 0: return 1;
				case null: return 2;
				case !0: return 3;
				case !1: return 4;
				default:
					var b = Ca.length ? Ca.pop() : J.length;
					J[b] = {
						ga: 1,
						value: a
					};
					return b;
			}
		}, Fa = void 0, Ga = void 0;
		function N(a) {
			for (var b = ""; A[a];) b += Ga[A[a++]];
			return b;
		}
		var O = [];
		function Ha() {
			for (; O.length;) {
				var a = O.pop();
				a.M.$ = !1;
				a["delete"]();
			}
		}
		var P = void 0, Q = {};
		function Ia(a, b) {
			for (void 0 === b && L("ptr should not be undefined"); a.R;) b = a.ba(b), a = a.R;
			return b;
		}
		var R = {};
		function Ja(a) {
			a = Ka(a);
			var b = N(a);
			S(a);
			return b;
		}
		function La(a, b) {
			var c = R[a];
			void 0 === c && L(b + " has unknown type " + Ja(a));
			return c;
		}
		function Ma() {}
		var Na = !1;
		function Oa(a) {
			--a.count.value;
			0 === a.count.value && (a.T ? a.U.W(a.T) : a.P.N.W(a.O));
		}
		function Pa(a, b, c) {
			if (b === c) return a;
			if (void 0 === c.R) return null;
			a = Pa(a, b, c.R);
			return null === a ? null : c.na(a);
		}
		var Qa = {};
		function Ra(a, b) {
			b = Ia(a, b);
			return Q[b];
		}
		var Sa = void 0;
		function Ta(a) {
			throw new Sa(a);
		}
		function Ua(a, b) {
			b.P && b.O || Ta("makeClassHandle requires ptr and ptrType");
			!!b.U !== !!b.T && Ta("Both smartPtrType and smartPtr must be specified");
			b.count = { value: 1 };
			return T(Object.create(a, { M: { value: b } }));
		}
		function T(a) {
			if ("undefined" === typeof FinalizationRegistry) return T = (b) => b, a;
			Na = new FinalizationRegistry((b) => {
				Oa(b.M);
			});
			T = (b) => {
				var c = b.M;
				c.T && Na.register(b, { M: c }, b);
				return b;
			};
			Ma = (b) => {
				Na.unregister(b);
			};
			return T(a);
		}
		var Va = {};
		function Wa(a) {
			for (; a.length;) {
				var b = a.pop();
				a.pop()(b);
			}
		}
		function Xa(a) {
			return this.fromWireType(D[a >> 2]);
		}
		var U = {}, Ya = {};
		function V(a, b, c) {
			function d(k) {
				k = c(k);
				k.length !== a.length && Ta("Mismatched type converter count");
				for (var m = 0; m < a.length; ++m) W(a[m], k[m]);
			}
			a.forEach(function(k) {
				Ya[k] = b;
			});
			var e = Array(b.length), f = [], g = 0;
			b.forEach((k, m) => {
				R.hasOwnProperty(k) ? e[m] = R[k] : (f.push(k), U.hasOwnProperty(k) || (U[k] = []), U[k].push(() => {
					e[m] = R[k];
					++g;
					g === f.length && d(e);
				}));
			});
			0 === f.length && d(e);
		}
		function Za(a) {
			switch (a) {
				case 1: return 0;
				case 2: return 1;
				case 4: return 2;
				case 8: return 3;
				default: throw new TypeError("Unknown type size: " + a);
			}
		}
		function W(a, b, c = {}) {
			if (!("argPackAdvance" in b)) throw new TypeError("registerType registeredInstance requires argPackAdvance");
			var d = b.name;
			a || L("type \"" + d + "\" must have a positive integer typeid pointer");
			if (R.hasOwnProperty(a)) {
				if (c.ua) return;
				L("Cannot register type '" + d + "' twice");
			}
			R[a] = b;
			delete Ya[a];
			U.hasOwnProperty(a) && (b = U[a], delete U[a], b.forEach((e) => e()));
		}
		function $a(a) {
			L(a.M.P.N.name + " instance already deleted");
		}
		function X() {}
		function ab(a, b, c) {
			if (void 0 === a[b].S) {
				var d = a[b];
				a[b] = function() {
					a[b].S.hasOwnProperty(arguments.length) || L("Function '" + c + "' called with an invalid number of arguments (" + arguments.length + ") - expects one of (" + a[b].S + ")!");
					return a[b].S[arguments.length].apply(this, arguments);
				};
				a[b].S = [];
				a[b].S[d.Z] = d;
			}
		}
		function bb(a, b) {
			h.hasOwnProperty(a) ? (L("Cannot register public name '" + a + "' twice"), ab(h, a, a), h.hasOwnProperty(void 0) && L("Cannot register multiple overloads of a function with the same number of arguments (undefined)!"), h[a].S[void 0] = b) : h[a] = b;
		}
		function cb(a, b, c, d, e, f, g, k) {
			this.name = a;
			this.constructor = b;
			this.X = c;
			this.W = d;
			this.R = e;
			this.pa = f;
			this.ba = g;
			this.na = k;
			this.ja = [];
		}
		function db(a, b, c) {
			for (; b !== c;) b.ba || L("Expected null or instance of " + c.name + ", got an instance of " + b.name), a = b.ba(a), b = b.R;
			return a;
		}
		function eb(a, b) {
			if (null === b) return this.ea && L("null is not a valid " + this.name), 0;
			b.M || L("Cannot pass \"" + fb(b) + "\" as a " + this.name);
			b.M.O || L("Cannot pass deleted object as a pointer of type " + this.name);
			return db(b.M.O, b.M.P.N, this.N);
		}
		function gb(a, b) {
			if (null === b) {
				this.ea && L("null is not a valid " + this.name);
				if (this.da) {
					var c = this.fa();
					null !== a && a.push(this.W, c);
					return c;
				}
				return 0;
			}
			b.M || L("Cannot pass \"" + fb(b) + "\" as a " + this.name);
			b.M.O || L("Cannot pass deleted object as a pointer of type " + this.name);
			!this.ca && b.M.P.ca && L("Cannot convert argument of type " + (b.M.U ? b.M.U.name : b.M.P.name) + " to parameter type " + this.name);
			c = db(b.M.O, b.M.P.N, this.N);
			if (this.da) switch (void 0 === b.M.T && L("Passing raw pointer to smart pointer is illegal"), this.Ba) {
				case 0:
					b.M.U === this ? c = b.M.T : L("Cannot convert argument of type " + (b.M.U ? b.M.U.name : b.M.P.name) + " to parameter type " + this.name);
					break;
				case 1:
					c = b.M.T;
					break;
				case 2:
					if (b.M.U === this) c = b.M.T;
					else {
						var d = b.clone();
						c = this.xa(c, Ea(function() {
							d["delete"]();
						}));
						null !== a && a.push(this.W, c);
					}
					break;
				default: L("Unsupporting sharing policy");
			}
			return c;
		}
		function hb(a, b) {
			if (null === b) return this.ea && L("null is not a valid " + this.name), 0;
			b.M || L("Cannot pass \"" + fb(b) + "\" as a " + this.name);
			b.M.O || L("Cannot pass deleted object as a pointer of type " + this.name);
			b.M.P.ca && L("Cannot convert argument of type " + b.M.P.name + " to parameter type " + this.name);
			return db(b.M.O, b.M.P.N, this.N);
		}
		function Y(a, b, c, d) {
			this.name = a;
			this.N = b;
			this.ea = c;
			this.ca = d;
			this.da = !1;
			this.W = this.xa = this.fa = this.ka = this.Ba = this.wa = void 0;
			void 0 !== b.R ? this.toWireType = gb : (this.toWireType = d ? eb : hb, this.V = null);
		}
		function ib(a, b) {
			h.hasOwnProperty(a) || Ta("Replacing nonexistant public symbol");
			h[a] = b;
			h[a].Z = void 0;
		}
		function jb(a, b) {
			var c = [];
			return function() {
				c.length = 0;
				Object.assign(c, arguments);
				if (a.includes("j")) {
					var d = h["dynCall_" + a];
					d = c && c.length ? d.apply(null, [b].concat(c)) : d.call(null, b);
				} else d = oa.get(b).apply(null, c);
				return d;
			};
		}
		function Z(a, b) {
			a = N(a);
			var c = a.includes("j") ? jb(a, b) : oa.get(b);
			"function" != typeof c && L("unknown function pointer with signature " + a + ": " + b);
			return c;
		}
		var mb = void 0;
		function nb(a, b) {
			function c(f) {
				e[f] || R[f] || (Ya[f] ? Ya[f].forEach(c) : (d.push(f), e[f] = !0));
			}
			var d = [], e = {};
			b.forEach(c);
			throw new mb(a + ": " + d.map(Ja).join([", "]));
		}
		function ob(a, b, c, d, e) {
			var f = b.length;
			2 > f && L("argTypes array size mismatch! Must at least get return value and 'this' types!");
			var g = null !== b[1] && null !== c, k = !1;
			for (c = 1; c < b.length; ++c) if (null !== b[c] && void 0 === b[c].V) {
				k = !0;
				break;
			}
			var m = "void" !== b[0].name, l = f - 2, n = Array(l), p = [], r = [];
			return function() {
				arguments.length !== l && L("function " + a + " called with " + arguments.length + " arguments, expected " + l + " args!");
				r.length = 0;
				p.length = g ? 2 : 1;
				p[0] = e;
				if (g) {
					var u = b[1].toWireType(r, this);
					p[1] = u;
				}
				for (var t = 0; t < l; ++t) n[t] = b[t + 2].toWireType(r, arguments[t]), p.push(n[t]);
				t = d.apply(null, p);
				if (k) Wa(r);
				else for (var y = g ? 1 : 2; y < b.length; y++) {
					var B = 1 === y ? u : n[y - 2];
					null !== b[y].V && b[y].V(B);
				}
				u = m ? b[0].fromWireType(t) : void 0;
				return u;
			};
		}
		function pb(a, b) {
			for (var c = [], d = 0; d < a; d++) c.push(E[b + 4 * d >> 2]);
			return c;
		}
		function qb(a) {
			4 < a && 0 === --J[a].ga && (J[a] = void 0, Ca.push(a));
		}
		function fb(a) {
			if (null === a) return "null";
			var b = typeof a;
			return "object" === b || "array" === b || "function" === b ? a.toString() : "" + a;
		}
		function rb(a, b) {
			switch (b) {
				case 2: return function(c) {
					return this.fromWireType(la[c >> 2]);
				};
				case 3: return function(c) {
					return this.fromWireType(ma[c >> 3]);
				};
				default: throw new TypeError("Unknown float type: " + a);
			}
		}
		function sb(a, b, c) {
			switch (b) {
				case 0: return c ? function(d) {
					return ja[d];
				} : function(d) {
					return A[d];
				};
				case 1: return c ? function(d) {
					return C[d >> 1];
				} : function(d) {
					return ka[d >> 1];
				};
				case 2: return c ? function(d) {
					return D[d >> 2];
				} : function(d) {
					return E[d >> 2];
				};
				default: throw new TypeError("Unknown integer type: " + a);
			}
		}
		function tb(a, b) {
			for (var c = "", d = 0; !(d >= b / 2); ++d) {
				var e = C[a + 2 * d >> 1];
				if (0 == e) break;
				c += String.fromCharCode(e);
			}
			return c;
		}
		function ub(a, b, c) {
			void 0 === c && (c = 2147483647);
			if (2 > c) return 0;
			c -= 2;
			var d = b;
			c = c < 2 * a.length ? c / 2 : a.length;
			for (var e = 0; e < c; ++e) C[b >> 1] = a.charCodeAt(e), b += 2;
			C[b >> 1] = 0;
			return b - d;
		}
		function vb(a) {
			return 2 * a.length;
		}
		function wb(a, b) {
			for (var c = 0, d = ""; !(c >= b / 4);) {
				var e = D[a + 4 * c >> 2];
				if (0 == e) break;
				++c;
				65536 <= e ? (e -= 65536, d += String.fromCharCode(55296 | e >> 10, 56320 | e & 1023)) : d += String.fromCharCode(e);
			}
			return d;
		}
		function xb(a, b, c) {
			void 0 === c && (c = 2147483647);
			if (4 > c) return 0;
			var d = b;
			c = d + c - 4;
			for (var e = 0; e < a.length; ++e) {
				var f = a.charCodeAt(e);
				if (55296 <= f && 57343 >= f) {
					var g = a.charCodeAt(++e);
					f = 65536 + ((f & 1023) << 10) | g & 1023;
				}
				D[b >> 2] = f;
				b += 4;
				if (b + 4 > c) break;
			}
			D[b >> 2] = 0;
			return b - d;
		}
		function yb(a) {
			for (var b = 0, c = 0; c < a.length; ++c) {
				var d = a.charCodeAt(c);
				55296 <= d && 57343 >= d && ++c;
				b += 4;
			}
			return b;
		}
		var zb = {};
		function Ab(a) {
			var b = zb[a];
			return void 0 === b ? N(a) : b;
		}
		var Bb = [];
		function Cb(a) {
			var b = Bb.length;
			Bb.push(a);
			return b;
		}
		function Db(a, b) {
			for (var c = Array(a), d = 0; d < a; ++d) c[d] = La(E[b + 4 * d >> 2], "parameter " + d);
			return c;
		}
		var Eb = [], Fb = [
			null,
			[],
			[]
		];
		K = h.BindingError = Da("BindingError");
		h.count_emval_handles = function() {
			for (var a = 0, b = 5; b < J.length; ++b) void 0 !== J[b] && ++a;
			return a;
		};
		h.get_first_emval = function() {
			for (var a = 5; a < J.length; ++a) if (void 0 !== J[a]) return J[a];
			return null;
		};
		Fa = h.PureVirtualError = Da("PureVirtualError");
		for (var Gb = Array(256), Hb = 0; 256 > Hb; ++Hb) Gb[Hb] = String.fromCharCode(Hb);
		Ga = Gb;
		h.getInheritedInstanceCount = function() {
			return Object.keys(Q).length;
		};
		h.getLiveInheritedInstances = function() {
			var a = [], b;
			for (b in Q) Q.hasOwnProperty(b) && a.push(Q[b]);
			return a;
		};
		h.flushPendingDeletes = Ha;
		h.setDelayFunction = function(a) {
			P = a;
			O.length && P && P(Ha);
		};
		Sa = h.InternalError = Da("InternalError");
		X.prototype.isAliasOf = function(a) {
			if (!(this instanceof X && a instanceof X)) return !1;
			var b = this.M.P.N, c = this.M.O, d = a.M.P.N;
			for (a = a.M.O; b.R;) c = b.ba(c), b = b.R;
			for (; d.R;) a = d.ba(a), d = d.R;
			return b === d && c === a;
		};
		X.prototype.clone = function() {
			this.M.O || $a(this);
			if (this.M.aa) return this.M.count.value += 1, this;
			var a = T, b = Object, c = b.create, d = Object.getPrototypeOf(this), e = this.M;
			a = a(c.call(b, d, { M: { value: {
				count: e.count,
				$: e.$,
				aa: e.aa,
				O: e.O,
				P: e.P,
				T: e.T,
				U: e.U
			} } }));
			a.M.count.value += 1;
			a.M.$ = !1;
			return a;
		};
		X.prototype["delete"] = function() {
			this.M.O || $a(this);
			this.M.$ && !this.M.aa && L("Object already scheduled for deletion");
			Ma(this);
			Oa(this.M);
			this.M.aa || (this.M.T = void 0, this.M.O = void 0);
		};
		X.prototype.isDeleted = function() {
			return !this.M.O;
		};
		X.prototype.deleteLater = function() {
			this.M.O || $a(this);
			this.M.$ && !this.M.aa && L("Object already scheduled for deletion");
			O.push(this);
			1 === O.length && P && P(Ha);
			this.M.$ = !0;
			return this;
		};
		Y.prototype.qa = function(a) {
			this.ka && (a = this.ka(a));
			return a;
		};
		Y.prototype.ha = function(a) {
			this.W && this.W(a);
		};
		Y.prototype.argPackAdvance = 8;
		Y.prototype.readValueFromPointer = Xa;
		Y.prototype.deleteObject = function(a) {
			if (null !== a) a["delete"]();
		};
		Y.prototype.fromWireType = function(a) {
			function b() {
				return this.da ? Ua(this.N.X, {
					P: this.wa,
					O: c,
					U: this,
					T: a
				}) : Ua(this.N.X, {
					P: this,
					O: a
				});
			}
			var c = this.qa(a);
			if (!c) return this.ha(a), null;
			var d = Ra(this.N, c);
			if (void 0 !== d) {
				if (0 === d.M.count.value) return d.M.O = c, d.M.T = a, d.clone();
				d = d.clone();
				this.ha(a);
				return d;
			}
			d = this.N.pa(c);
			d = Qa[d];
			if (!d) return b.call(this);
			d = this.ca ? d.la : d.pointerType;
			var e = Pa(c, this.N, d.N);
			return null === e ? b.call(this) : this.da ? Ua(d.N.X, {
				P: d,
				O: e,
				U: this,
				T: a
			}) : Ua(d.N.X, {
				P: d,
				O: e
			});
		};
		mb = h.UnboundTypeError = Da("UnboundTypeError");
		var xa = "function" == typeof atob ? atob : function(a) {
			var b = "", c = 0;
			a = a.replace(/[^A-Za-z0-9\+\/=]/g, "");
			do {
				var d = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=".indexOf(a.charAt(c++));
				var e = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=".indexOf(a.charAt(c++));
				var f = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=".indexOf(a.charAt(c++));
				var g = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=".indexOf(a.charAt(c++));
				d = d << 2 | e >> 4;
				e = (e & 15) << 4 | f >> 2;
				var k = (f & 3) << 6 | g;
				b += String.fromCharCode(d);
				64 !== f && (b += String.fromCharCode(e));
				64 !== g && (b += String.fromCharCode(k));
			} while (c < a.length);
			return b;
		}, Jb = {
			l: function(a, b, c, d) {
				x("Assertion failed: " + (a ? z(A, a) : "") + ", at: " + [
					b ? b ? z(A, b) : "" : "unknown filename",
					c,
					d ? d ? z(A, d) : "" : "unknown function"
				]);
			},
			q: function(a, b, c) {
				a = N(a);
				b = La(b, "wrapper");
				c = M(c);
				var d = [].slice, e = b.N, f = e.X, g = e.R.X, k = e.R.constructor;
				a = Ba(a, function() {
					e.R.ja.forEach(function(l) {
						if (this[l] === g[l]) throw new Fa("Pure virtual function " + l + " must be implemented in JavaScript");
					}.bind(this));
					Object.defineProperty(this, "__parent", { value: f });
					this.__construct.apply(this, d.call(arguments));
				});
				f.__construct = function() {
					this === f && L("Pass correct 'this' to __construct");
					var l = k.implement.apply(void 0, [this].concat(d.call(arguments)));
					Ma(l);
					var n = l.M;
					l.notifyOnDestruction();
					n.aa = !0;
					Object.defineProperties(this, { M: { value: n } });
					T(this);
					l = n.O;
					l = Ia(e, l);
					Q.hasOwnProperty(l) ? L("Tried to register registered instance: " + l) : Q[l] = this;
				};
				f.__destruct = function() {
					this === f && L("Pass correct 'this' to __destruct");
					Ma(this);
					var l = this.M.O;
					l = Ia(e, l);
					Q.hasOwnProperty(l) ? delete Q[l] : L("Tried to unregister unregistered instance: " + l);
				};
				a.prototype = Object.create(f);
				for (var m in c) a.prototype[m] = c[m];
				return Ea(a);
			},
			j: function(a) {
				var b = Va[a];
				delete Va[a];
				var c = b.fa, d = b.W, e = b.ia, f = e.map((g) => g.ta).concat(e.map((g) => g.za));
				V([a], f, (g) => {
					var k = {};
					e.forEach((m, l) => {
						var n = g[l], p = m.ra, r = m.sa, u = g[l + e.length], t = m.ya, y = m.Aa;
						k[m.oa] = {
							read: (B) => n.fromWireType(p(r, B)),
							write: (B, ba) => {
								var I = [];
								t(y, B, u.toWireType(I, ba));
								Wa(I);
							}
						};
					});
					return [{
						name: b.name,
						fromWireType: function(m) {
							var l = {}, n;
							for (n in k) l[n] = k[n].read(m);
							d(m);
							return l;
						},
						toWireType: function(m, l) {
							for (var n in k) if (!(n in l)) throw new TypeError("Missing field:  \"" + n + "\"");
							var p = c();
							for (n in k) k[n].write(p, l[n]);
							null !== m && m.push(d, p);
							return p;
						},
						argPackAdvance: 8,
						readValueFromPointer: Xa,
						V: d
					}];
				});
			},
			v: function() {},
			B: function(a, b, c, d, e) {
				var f = Za(c);
				b = N(b);
				W(a, {
					name: b,
					fromWireType: function(g) {
						return !!g;
					},
					toWireType: function(g, k) {
						return k ? d : e;
					},
					argPackAdvance: 8,
					readValueFromPointer: function(g) {
						if (1 === c) var k = ja;
						else if (2 === c) k = C;
						else if (4 === c) k = D;
						else throw new TypeError("Unknown boolean type size: " + b);
						return this.fromWireType(k[g >> f]);
					},
					V: null
				});
			},
			f: function(a, b, c, d, e, f, g, k, m, l, n, p, r) {
				n = N(n);
				f = Z(e, f);
				k && (k = Z(g, k));
				l && (l = Z(m, l));
				r = Z(p, r);
				var u = Aa(n);
				bb(u, function() {
					nb("Cannot construct " + n + " due to unbound types", [d]);
				});
				V([
					a,
					b,
					c
				], d ? [d] : [], function(t) {
					t = t[0];
					if (d) {
						var y = t.N;
						var B = y.X;
					} else B = X.prototype;
					t = Ba(u, function() {
						if (Object.getPrototypeOf(this) !== ba) throw new K("Use 'new' to construct " + n);
						if (void 0 === I.Y) throw new K(n + " has no accessible constructor");
						var kb = I.Y[arguments.length];
						if (void 0 === kb) throw new K("Tried to invoke ctor of " + n + " with invalid number of parameters (" + arguments.length + ") - expected (" + Object.keys(I.Y).toString() + ") parameters instead!");
						return kb.apply(this, arguments);
					});
					var ba = Object.create(B, { constructor: { value: t } });
					t.prototype = ba;
					var I = new cb(n, t, ba, r, y, f, k, l);
					y = new Y(n, I, !0, !1);
					B = new Y(n + "*", I, !1, !1);
					var lb = new Y(n + " const*", I, !1, !0);
					Qa[a] = {
						pointerType: B,
						la: lb
					};
					ib(u, t);
					return [
						y,
						B,
						lb
					];
				});
			},
			d: function(a, b, c, d, e, f, g) {
				var k = pb(c, d);
				b = N(b);
				f = Z(e, f);
				V([], [a], function(m) {
					function l() {
						nb("Cannot call " + n + " due to unbound types", k);
					}
					m = m[0];
					var n = m.name + "." + b;
					b.startsWith("@@") && (b = Symbol[b.substring(2)]);
					var p = m.N.constructor;
					void 0 === p[b] ? (l.Z = c - 1, p[b] = l) : (ab(p, b, n), p[b].S[c - 1] = l);
					V([], k, function(r) {
						r = ob(n, [r[0], null].concat(r.slice(1)), null, f, g);
						void 0 === p[b].S ? (r.Z = c - 1, p[b] = r) : p[b].S[c - 1] = r;
						return [];
					});
					return [];
				});
			},
			p: function(a, b, c, d, e, f) {
				0 < b || x();
				var g = pb(b, c);
				e = Z(d, e);
				V([], [a], function(k) {
					k = k[0];
					var m = "constructor " + k.name;
					void 0 === k.N.Y && (k.N.Y = []);
					if (void 0 !== k.N.Y[b - 1]) throw new K("Cannot register multiple constructors with identical number of parameters (" + (b - 1) + ") for class '" + k.name + "'! Overload resolution is currently only performed using the parameter count, not actual type info!");
					k.N.Y[b - 1] = () => {
						nb("Cannot construct " + k.name + " due to unbound types", g);
					};
					V([], g, function(l) {
						l.splice(1, 0, null);
						k.N.Y[b - 1] = ob(m, l, null, e, f);
						return [];
					});
					return [];
				});
			},
			a: function(a, b, c, d, e, f, g, k) {
				var m = pb(c, d);
				b = N(b);
				f = Z(e, f);
				V([], [a], function(l) {
					function n() {
						nb("Cannot call " + p + " due to unbound types", m);
					}
					l = l[0];
					var p = l.name + "." + b;
					b.startsWith("@@") && (b = Symbol[b.substring(2)]);
					k && l.N.ja.push(b);
					var r = l.N.X, u = r[b];
					void 0 === u || void 0 === u.S && u.className !== l.name && u.Z === c - 2 ? (n.Z = c - 2, n.className = l.name, r[b] = n) : (ab(r, b, p), r[b].S[c - 2] = n);
					V([], m, function(t) {
						t = ob(p, t, l, f, g);
						void 0 === r[b].S ? (t.Z = c - 2, r[b] = t) : r[b].S[c - 2] = t;
						return [];
					});
					return [];
				});
			},
			A: function(a, b) {
				b = N(b);
				W(a, {
					name: b,
					fromWireType: function(c) {
						var d = M(c);
						qb(c);
						return d;
					},
					toWireType: function(c, d) {
						return Ea(d);
					},
					argPackAdvance: 8,
					readValueFromPointer: Xa,
					V: null
				});
			},
			n: function(a, b, c) {
				c = Za(c);
				b = N(b);
				W(a, {
					name: b,
					fromWireType: function(d) {
						return d;
					},
					toWireType: function(d, e) {
						return e;
					},
					argPackAdvance: 8,
					readValueFromPointer: rb(b, c),
					V: null
				});
			},
			e: function(a, b, c, d, e) {
				b = N(b);
				-1 === e && (e = 4294967295);
				e = Za(c);
				var f = (k) => k;
				if (0 === d) {
					var g = 32 - 8 * c;
					f = (k) => k << g >>> g;
				}
				c = b.includes("unsigned") ? function(k, m) {
					return m >>> 0;
				} : function(k, m) {
					return m;
				};
				W(a, {
					name: b,
					fromWireType: f,
					toWireType: c,
					argPackAdvance: 8,
					readValueFromPointer: sb(b, e, 0 !== d),
					V: null
				});
			},
			b: function(a, b, c) {
				function d(f) {
					f >>= 2;
					var g = E;
					return new e(ia, g[f + 1], g[f]);
				}
				var e = [
					Int8Array,
					Uint8Array,
					Int16Array,
					Uint16Array,
					Int32Array,
					Uint32Array,
					Float32Array,
					Float64Array
				][b];
				c = N(c);
				W(a, {
					name: c,
					fromWireType: d,
					argPackAdvance: 8,
					readValueFromPointer: d
				}, { ua: !0 });
			},
			o: function(a, b) {
				b = N(b);
				var c = "std::string" === b;
				W(a, {
					name: b,
					fromWireType: function(d) {
						var e = E[d >> 2], f = d + 4;
						if (c) for (var g = f, k = 0; k <= e; ++k) {
							var m = f + k;
							if (k == e || 0 == A[m]) {
								g = g ? z(A, g, m - g) : "";
								if (void 0 === l) var l = g;
								else l += String.fromCharCode(0), l += g;
								g = m + 1;
							}
						}
						else {
							l = Array(e);
							for (k = 0; k < e; ++k) l[k] = String.fromCharCode(A[f + k]);
							l = l.join("");
						}
						S(d);
						return l;
					},
					toWireType: function(d, e) {
						e instanceof ArrayBuffer && (e = new Uint8Array(e));
						var f, g = "string" == typeof e;
						g || e instanceof Uint8Array || e instanceof Uint8ClampedArray || e instanceof Int8Array || L("Cannot pass non-string to std::string");
						if (c && g) {
							var k = 0;
							for (f = 0; f < e.length; ++f) {
								var m = e.charCodeAt(f);
								127 >= m ? k++ : 2047 >= m ? k += 2 : 55296 <= m && 57343 >= m ? (k += 4, ++f) : k += 3;
							}
							f = k;
						} else f = e.length;
						k = Ib(4 + f + 1);
						m = k + 4;
						E[k >> 2] = f;
						if (c && g) {
							if (g = m, m = f + 1, f = A, 0 < m) {
								m = g + m - 1;
								for (var l = 0; l < e.length; ++l) {
									var n = e.charCodeAt(l);
									if (55296 <= n && 57343 >= n) {
										var p = e.charCodeAt(++l);
										n = 65536 + ((n & 1023) << 10) | p & 1023;
									}
									if (127 >= n) {
										if (g >= m) break;
										f[g++] = n;
									} else {
										if (2047 >= n) {
											if (g + 1 >= m) break;
											f[g++] = 192 | n >> 6;
										} else {
											if (65535 >= n) {
												if (g + 2 >= m) break;
												f[g++] = 224 | n >> 12;
											} else {
												if (g + 3 >= m) break;
												f[g++] = 240 | n >> 18;
												f[g++] = 128 | n >> 12 & 63;
											}
											f[g++] = 128 | n >> 6 & 63;
										}
										f[g++] = 128 | n & 63;
									}
								}
								f[g] = 0;
							}
						} else if (g) for (g = 0; g < f; ++g) l = e.charCodeAt(g), 255 < l && (S(m), L("String has UTF-16 code units that do not fit in 8 bits")), A[m + g] = l;
						else for (g = 0; g < f; ++g) A[m + g] = e[g];
						null !== d && d.push(S, k);
						return k;
					},
					argPackAdvance: 8,
					readValueFromPointer: Xa,
					V: function(d) {
						S(d);
					}
				});
			},
			i: function(a, b, c) {
				c = N(c);
				if (2 === b) {
					var d = tb;
					var e = ub;
					var f = vb;
					var g = () => ka;
					var k = 1;
				} else 4 === b && (d = wb, e = xb, f = yb, g = () => E, k = 2);
				W(a, {
					name: c,
					fromWireType: function(m) {
						for (var l = E[m >> 2], n = g(), p, r = m + 4, u = 0; u <= l; ++u) {
							var t = m + 4 + u * b;
							if (u == l || 0 == n[t >> k]) r = d(r, t - r), void 0 === p ? p = r : (p += String.fromCharCode(0), p += r), r = t + b;
						}
						S(m);
						return p;
					},
					toWireType: function(m, l) {
						"string" != typeof l && L("Cannot pass non-string to C++ string type " + c);
						var n = f(l), p = Ib(4 + n + b);
						E[p >> 2] = n >> k;
						e(l, p + 4, n + b);
						null !== m && m.push(S, p);
						return p;
					},
					argPackAdvance: 8,
					readValueFromPointer: Xa,
					V: function(m) {
						S(m);
					}
				});
			},
			k: function(a, b, c, d, e, f) {
				Va[a] = {
					name: N(b),
					fa: Z(c, d),
					W: Z(e, f),
					ia: []
				};
			},
			h: function(a, b, c, d, e, f, g, k, m, l) {
				Va[a].ia.push({
					oa: N(b),
					ta: c,
					ra: Z(d, e),
					sa: f,
					za: g,
					ya: Z(k, m),
					Aa: l
				});
			},
			C: function(a, b) {
				b = N(b);
				W(a, {
					va: !0,
					name: b,
					argPackAdvance: 0,
					fromWireType: function() {},
					toWireType: function() {}
				});
			},
			s: function(a, b, c, d, e) {
				a = Bb[a];
				b = M(b);
				c = Ab(c);
				var f = [];
				E[d >> 2] = Ea(f);
				return a(b, c, f, e);
			},
			t: function(a, b, c, d) {
				a = Bb[a];
				b = M(b);
				c = Ab(c);
				a(b, c, null, d);
			},
			g: qb,
			m: function(a, b) {
				var c = Db(a, b), d = c[0];
				b = d.name + "_$" + c.slice(1).map(function(g) {
					return g.name;
				}).join("_") + "$";
				var e = Eb[b];
				if (void 0 !== e) return e;
				var f = Array(a - 1);
				e = Cb((g, k, m, l) => {
					for (var n = 0, p = 0; p < a - 1; ++p) f[p] = c[p + 1].readValueFromPointer(l + n), n += c[p + 1].argPackAdvance;
					g = g[k].apply(g, f);
					for (p = 0; p < a - 1; ++p) c[p + 1].ma && c[p + 1].ma(f[p]);
					if (!d.va) return d.toWireType(m, g);
				});
				return Eb[b] = e;
			},
			D: function(a) {
				4 < a && (J[a].ga += 1);
			},
			r: function(a) {
				Wa(M(a));
				qb(a);
			},
			c: function() {
				x("");
			},
			x: function(a, b, c) {
				A.copyWithin(a, b, b + c);
			},
			w: function(a) {
				var b = A.length;
				a >>>= 0;
				if (2147483648 < a) return !1;
				for (var c = 1; 4 >= c; c *= 2) {
					var d = b * (1 + .2 / c);
					d = Math.min(d, a + 100663296);
					var e = Math;
					d = Math.max(a, d);
					e = e.min.call(e, 2147483648, d + (65536 - d % 65536) % 65536);
					a: {
						try {
							fa.grow(e - ia.byteLength + 65535 >>> 16);
							na();
							var f = 1;
							break a;
						} catch (g) {}
						f = void 0;
					}
					if (f) return !0;
				}
				return !1;
			},
			z: function() {
				return 52;
			},
			u: function() {
				return 70;
			},
			y: function(a, b, c, d) {
				for (var e = 0, f = 0; f < c; f++) {
					var g = E[b >> 2], k = E[b + 4 >> 2];
					b += 8;
					for (var m = 0; m < k; m++) {
						var l = A[g + m], n = Fb[a];
						0 === l || 10 === l ? ((1 === a ? ea : v)(z(n, 0)), n.length = 0) : n.push(l);
					}
					e += k;
				}
				E[d >> 2] = e;
				return 0;
			}
		};
		(function() {
			function a(e) {
				h.asm = e.exports;
				fa = h.asm.E;
				na();
				oa = h.asm.J;
				qa.unshift(h.asm.F);
				F--;
				h.monitorRunDependencies && h.monitorRunDependencies(F);
				0 == F && (null !== ta && (clearInterval(ta), ta = null), G && (e = G, G = null, e()));
			}
			function b(e) {
				a(e.instance);
			}
			function c(e) {
				return ya().then(function(f) {
					return WebAssembly.instantiate(f, d);
				}).then(function(f) {
					return f;
				}).then(e, function(f) {
					v("failed to asynchronously prepare wasm: " + f);
					x(f);
				});
			}
			var d = { a: Jb };
			F++;
			h.monitorRunDependencies && h.monitorRunDependencies(F);
			if (h.instantiateWasm) try {
				return h.instantiateWasm(d, a);
			} catch (e) {
				v("Module.instantiateWasm callback failed with error: " + e), ca(e);
			}
			(function() {
				return w || "function" != typeof WebAssembly.instantiateStreaming || ua(H) || "function" != typeof fetch ? c(b) : fetch(H, { credentials: "same-origin" }).then(function(e) {
					return WebAssembly.instantiateStreaming(e, d).then(b, function(f) {
						v("wasm streaming compile failed: " + f);
						v("falling back to ArrayBuffer instantiation");
						return c(b);
					});
				});
			})().catch(ca);
			return {};
		})();
		h.___wasm_call_ctors = function() {
			return (h.___wasm_call_ctors = h.asm.F).apply(null, arguments);
		};
		var Ka = h.___getTypeName = function() {
			return (Ka = h.___getTypeName = h.asm.G).apply(null, arguments);
		};
		h.__embind_initialize_bindings = function() {
			return (h.__embind_initialize_bindings = h.asm.H).apply(null, arguments);
		};
		var Ib = h._malloc = function() {
			return (Ib = h._malloc = h.asm.I).apply(null, arguments);
		}, S = h._free = function() {
			return (S = h._free = h.asm.K).apply(null, arguments);
		};
		h.dynCall_jiji = function() {
			return (h.dynCall_jiji = h.asm.L).apply(null, arguments);
		};
		var Kb;
		G = function Lb() {
			Kb || Mb();
			Kb || (G = Lb);
		};
		function Mb() {
			function a() {
				if (!Kb && (Kb = !0, h.calledRun = !0, !ha)) {
					za(qa);
					aa(h);
					if (h.onRuntimeInitialized) h.onRuntimeInitialized();
					if (h.postRun) for ("function" == typeof h.postRun && (h.postRun = [h.postRun]); h.postRun.length;) {
						var b = h.postRun.shift();
						ra.unshift(b);
					}
					za(ra);
				}
			}
			if (!(0 < F)) {
				if (h.preRun) for ("function" == typeof h.preRun && (h.preRun = [h.preRun]); h.preRun.length;) sa();
				za(pa);
				0 < F || (h.setStatus ? (h.setStatus("Running..."), setTimeout(function() {
					setTimeout(function() {
						h.setStatus("");
					}, 1);
					a();
				}, 1)) : a());
			}
		}
		if (h.preInit) for ("function" == typeof h.preInit && (h.preInit = [h.preInit]); 0 < h.preInit.length;) h.preInit.pop()();
		Mb();
		return loadYoga$1.ready;
	});
})();
var yoga_wasm_base64_esm_default = loadYoga;

//#endregion
//#region node_modules/yoga-layout/dist/src/generated/YGEnums.js
/**
* Copyright (c) Meta Platforms, Inc. and affiliates.
*
* This source code is licensed under the MIT license found in the
* LICENSE file in the root directory of this source tree.
*/
let Align = /* @__PURE__ */ function(Align$1) {
	Align$1[Align$1["Auto"] = 0] = "Auto";
	Align$1[Align$1["FlexStart"] = 1] = "FlexStart";
	Align$1[Align$1["Center"] = 2] = "Center";
	Align$1[Align$1["FlexEnd"] = 3] = "FlexEnd";
	Align$1[Align$1["Stretch"] = 4] = "Stretch";
	Align$1[Align$1["Baseline"] = 5] = "Baseline";
	Align$1[Align$1["SpaceBetween"] = 6] = "SpaceBetween";
	Align$1[Align$1["SpaceAround"] = 7] = "SpaceAround";
	Align$1[Align$1["SpaceEvenly"] = 8] = "SpaceEvenly";
	return Align$1;
}({});
let BoxSizing = /* @__PURE__ */ function(BoxSizing$1) {
	BoxSizing$1[BoxSizing$1["BorderBox"] = 0] = "BorderBox";
	BoxSizing$1[BoxSizing$1["ContentBox"] = 1] = "ContentBox";
	return BoxSizing$1;
}({});
let Dimension = /* @__PURE__ */ function(Dimension$1) {
	Dimension$1[Dimension$1["Width"] = 0] = "Width";
	Dimension$1[Dimension$1["Height"] = 1] = "Height";
	return Dimension$1;
}({});
let Direction = /* @__PURE__ */ function(Direction$1) {
	Direction$1[Direction$1["Inherit"] = 0] = "Inherit";
	Direction$1[Direction$1["LTR"] = 1] = "LTR";
	Direction$1[Direction$1["RTL"] = 2] = "RTL";
	return Direction$1;
}({});
let Display = /* @__PURE__ */ function(Display$1) {
	Display$1[Display$1["Flex"] = 0] = "Flex";
	Display$1[Display$1["None"] = 1] = "None";
	Display$1[Display$1["Contents"] = 2] = "Contents";
	return Display$1;
}({});
let Edge = /* @__PURE__ */ function(Edge$1) {
	Edge$1[Edge$1["Left"] = 0] = "Left";
	Edge$1[Edge$1["Top"] = 1] = "Top";
	Edge$1[Edge$1["Right"] = 2] = "Right";
	Edge$1[Edge$1["Bottom"] = 3] = "Bottom";
	Edge$1[Edge$1["Start"] = 4] = "Start";
	Edge$1[Edge$1["End"] = 5] = "End";
	Edge$1[Edge$1["Horizontal"] = 6] = "Horizontal";
	Edge$1[Edge$1["Vertical"] = 7] = "Vertical";
	Edge$1[Edge$1["All"] = 8] = "All";
	return Edge$1;
}({});
let Errata = /* @__PURE__ */ function(Errata$1) {
	Errata$1[Errata$1["None"] = 0] = "None";
	Errata$1[Errata$1["StretchFlexBasis"] = 1] = "StretchFlexBasis";
	Errata$1[Errata$1["AbsolutePositionWithoutInsetsExcludesPadding"] = 2] = "AbsolutePositionWithoutInsetsExcludesPadding";
	Errata$1[Errata$1["AbsolutePercentAgainstInnerSize"] = 4] = "AbsolutePercentAgainstInnerSize";
	Errata$1[Errata$1["All"] = 2147483647] = "All";
	Errata$1[Errata$1["Classic"] = 2147483646] = "Classic";
	return Errata$1;
}({});
let ExperimentalFeature = /* @__PURE__ */ function(ExperimentalFeature$1) {
	ExperimentalFeature$1[ExperimentalFeature$1["WebFlexBasis"] = 0] = "WebFlexBasis";
	return ExperimentalFeature$1;
}({});
let FlexDirection = /* @__PURE__ */ function(FlexDirection$1) {
	FlexDirection$1[FlexDirection$1["Column"] = 0] = "Column";
	FlexDirection$1[FlexDirection$1["ColumnReverse"] = 1] = "ColumnReverse";
	FlexDirection$1[FlexDirection$1["Row"] = 2] = "Row";
	FlexDirection$1[FlexDirection$1["RowReverse"] = 3] = "RowReverse";
	return FlexDirection$1;
}({});
let Gutter = /* @__PURE__ */ function(Gutter$1) {
	Gutter$1[Gutter$1["Column"] = 0] = "Column";
	Gutter$1[Gutter$1["Row"] = 1] = "Row";
	Gutter$1[Gutter$1["All"] = 2] = "All";
	return Gutter$1;
}({});
let Justify = /* @__PURE__ */ function(Justify$1) {
	Justify$1[Justify$1["FlexStart"] = 0] = "FlexStart";
	Justify$1[Justify$1["Center"] = 1] = "Center";
	Justify$1[Justify$1["FlexEnd"] = 2] = "FlexEnd";
	Justify$1[Justify$1["SpaceBetween"] = 3] = "SpaceBetween";
	Justify$1[Justify$1["SpaceAround"] = 4] = "SpaceAround";
	Justify$1[Justify$1["SpaceEvenly"] = 5] = "SpaceEvenly";
	return Justify$1;
}({});
let LogLevel = /* @__PURE__ */ function(LogLevel$1) {
	LogLevel$1[LogLevel$1["Error"] = 0] = "Error";
	LogLevel$1[LogLevel$1["Warn"] = 1] = "Warn";
	LogLevel$1[LogLevel$1["Info"] = 2] = "Info";
	LogLevel$1[LogLevel$1["Debug"] = 3] = "Debug";
	LogLevel$1[LogLevel$1["Verbose"] = 4] = "Verbose";
	LogLevel$1[LogLevel$1["Fatal"] = 5] = "Fatal";
	return LogLevel$1;
}({});
let MeasureMode = /* @__PURE__ */ function(MeasureMode$1) {
	MeasureMode$1[MeasureMode$1["Undefined"] = 0] = "Undefined";
	MeasureMode$1[MeasureMode$1["Exactly"] = 1] = "Exactly";
	MeasureMode$1[MeasureMode$1["AtMost"] = 2] = "AtMost";
	return MeasureMode$1;
}({});
let NodeType = /* @__PURE__ */ function(NodeType$1) {
	NodeType$1[NodeType$1["Default"] = 0] = "Default";
	NodeType$1[NodeType$1["Text"] = 1] = "Text";
	return NodeType$1;
}({});
let Overflow = /* @__PURE__ */ function(Overflow$1) {
	Overflow$1[Overflow$1["Visible"] = 0] = "Visible";
	Overflow$1[Overflow$1["Hidden"] = 1] = "Hidden";
	Overflow$1[Overflow$1["Scroll"] = 2] = "Scroll";
	return Overflow$1;
}({});
let PositionType = /* @__PURE__ */ function(PositionType$1) {
	PositionType$1[PositionType$1["Static"] = 0] = "Static";
	PositionType$1[PositionType$1["Relative"] = 1] = "Relative";
	PositionType$1[PositionType$1["Absolute"] = 2] = "Absolute";
	return PositionType$1;
}({});
let Unit = /* @__PURE__ */ function(Unit$1) {
	Unit$1[Unit$1["Undefined"] = 0] = "Undefined";
	Unit$1[Unit$1["Point"] = 1] = "Point";
	Unit$1[Unit$1["Percent"] = 2] = "Percent";
	Unit$1[Unit$1["Auto"] = 3] = "Auto";
	return Unit$1;
}({});
let Wrap = /* @__PURE__ */ function(Wrap$1) {
	Wrap$1[Wrap$1["NoWrap"] = 0] = "NoWrap";
	Wrap$1[Wrap$1["Wrap"] = 1] = "Wrap";
	Wrap$1[Wrap$1["WrapReverse"] = 2] = "WrapReverse";
	return Wrap$1;
}({});
const constants$3 = {
	ALIGN_AUTO: Align.Auto,
	ALIGN_FLEX_START: Align.FlexStart,
	ALIGN_CENTER: Align.Center,
	ALIGN_FLEX_END: Align.FlexEnd,
	ALIGN_STRETCH: Align.Stretch,
	ALIGN_BASELINE: Align.Baseline,
	ALIGN_SPACE_BETWEEN: Align.SpaceBetween,
	ALIGN_SPACE_AROUND: Align.SpaceAround,
	ALIGN_SPACE_EVENLY: Align.SpaceEvenly,
	BOX_SIZING_BORDER_BOX: BoxSizing.BorderBox,
	BOX_SIZING_CONTENT_BOX: BoxSizing.ContentBox,
	DIMENSION_WIDTH: Dimension.Width,
	DIMENSION_HEIGHT: Dimension.Height,
	DIRECTION_INHERIT: Direction.Inherit,
	DIRECTION_LTR: Direction.LTR,
	DIRECTION_RTL: Direction.RTL,
	DISPLAY_FLEX: Display.Flex,
	DISPLAY_NONE: Display.None,
	DISPLAY_CONTENTS: Display.Contents,
	EDGE_LEFT: Edge.Left,
	EDGE_TOP: Edge.Top,
	EDGE_RIGHT: Edge.Right,
	EDGE_BOTTOM: Edge.Bottom,
	EDGE_START: Edge.Start,
	EDGE_END: Edge.End,
	EDGE_HORIZONTAL: Edge.Horizontal,
	EDGE_VERTICAL: Edge.Vertical,
	EDGE_ALL: Edge.All,
	ERRATA_NONE: Errata.None,
	ERRATA_STRETCH_FLEX_BASIS: Errata.StretchFlexBasis,
	ERRATA_ABSOLUTE_POSITION_WITHOUT_INSETS_EXCLUDES_PADDING: Errata.AbsolutePositionWithoutInsetsExcludesPadding,
	ERRATA_ABSOLUTE_PERCENT_AGAINST_INNER_SIZE: Errata.AbsolutePercentAgainstInnerSize,
	ERRATA_ALL: Errata.All,
	ERRATA_CLASSIC: Errata.Classic,
	EXPERIMENTAL_FEATURE_WEB_FLEX_BASIS: ExperimentalFeature.WebFlexBasis,
	FLEX_DIRECTION_COLUMN: FlexDirection.Column,
	FLEX_DIRECTION_COLUMN_REVERSE: FlexDirection.ColumnReverse,
	FLEX_DIRECTION_ROW: FlexDirection.Row,
	FLEX_DIRECTION_ROW_REVERSE: FlexDirection.RowReverse,
	GUTTER_COLUMN: Gutter.Column,
	GUTTER_ROW: Gutter.Row,
	GUTTER_ALL: Gutter.All,
	JUSTIFY_FLEX_START: Justify.FlexStart,
	JUSTIFY_CENTER: Justify.Center,
	JUSTIFY_FLEX_END: Justify.FlexEnd,
	JUSTIFY_SPACE_BETWEEN: Justify.SpaceBetween,
	JUSTIFY_SPACE_AROUND: Justify.SpaceAround,
	JUSTIFY_SPACE_EVENLY: Justify.SpaceEvenly,
	LOG_LEVEL_ERROR: LogLevel.Error,
	LOG_LEVEL_WARN: LogLevel.Warn,
	LOG_LEVEL_INFO: LogLevel.Info,
	LOG_LEVEL_DEBUG: LogLevel.Debug,
	LOG_LEVEL_VERBOSE: LogLevel.Verbose,
	LOG_LEVEL_FATAL: LogLevel.Fatal,
	MEASURE_MODE_UNDEFINED: MeasureMode.Undefined,
	MEASURE_MODE_EXACTLY: MeasureMode.Exactly,
	MEASURE_MODE_AT_MOST: MeasureMode.AtMost,
	NODE_TYPE_DEFAULT: NodeType.Default,
	NODE_TYPE_TEXT: NodeType.Text,
	OVERFLOW_VISIBLE: Overflow.Visible,
	OVERFLOW_HIDDEN: Overflow.Hidden,
	OVERFLOW_SCROLL: Overflow.Scroll,
	POSITION_TYPE_STATIC: PositionType.Static,
	POSITION_TYPE_RELATIVE: PositionType.Relative,
	POSITION_TYPE_ABSOLUTE: PositionType.Absolute,
	UNIT_UNDEFINED: Unit.Undefined,
	UNIT_POINT: Unit.Point,
	UNIT_PERCENT: Unit.Percent,
	UNIT_AUTO: Unit.Auto,
	WRAP_NO_WRAP: Wrap.NoWrap,
	WRAP_WRAP: Wrap.Wrap,
	WRAP_WRAP_REVERSE: Wrap.WrapReverse
};
var YGEnums_default = constants$3;

//#endregion
//#region node_modules/yoga-layout/dist/src/wrapAssembly.js
function wrapAssembly(lib$4) {
	function patch(prototype, name, fn) {
		const original = prototype[name];
		prototype[name] = function() {
			for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];
			return fn.call(this, original, ...args);
		};
	}
	for (const fnName of [
		"setPosition",
		"setMargin",
		"setFlexBasis",
		"setWidth",
		"setHeight",
		"setMinWidth",
		"setMinHeight",
		"setMaxWidth",
		"setMaxHeight",
		"setPadding",
		"setGap"
	]) {
		const methods = {
			[Unit.Point]: lib$4.Node.prototype[fnName],
			[Unit.Percent]: lib$4.Node.prototype[`${fnName}Percent`],
			[Unit.Auto]: lib$4.Node.prototype[`${fnName}Auto`]
		};
		patch(lib$4.Node.prototype, fnName, function(original) {
			for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) args[_key2 - 1] = arguments[_key2];
			const value = args.pop();
			let unit, asNumber;
			if (value === "auto") {
				unit = Unit.Auto;
				asNumber = void 0;
			} else if (typeof value === "object") {
				unit = value.unit;
				asNumber = value.valueOf();
			} else {
				unit = typeof value === "string" && value.endsWith("%") ? Unit.Percent : Unit.Point;
				asNumber = parseFloat(value);
				if (value !== void 0 && !Number.isNaN(value) && Number.isNaN(asNumber)) throw new Error(`Invalid value ${value} for ${fnName}`);
			}
			if (!methods[unit]) throw new Error(`Failed to execute "${fnName}": Unsupported unit '${value}'`);
			if (asNumber !== void 0) return methods[unit].call(this, ...args, asNumber);
			else return methods[unit].call(this, ...args);
		});
	}
	function wrapMeasureFunction(measureFunction) {
		return lib$4.MeasureCallback.implement({ measure: function() {
			const { width, height } = measureFunction(...arguments);
			return {
				width: width ?? NaN,
				height: height ?? NaN
			};
		} });
	}
	patch(lib$4.Node.prototype, "setMeasureFunc", function(original, measureFunc) {
		if (measureFunc) return original.call(this, wrapMeasureFunction(measureFunc));
		else return this.unsetMeasureFunc();
	});
	function wrapDirtiedFunc(dirtiedFunction) {
		return lib$4.DirtiedCallback.implement({ dirtied: dirtiedFunction });
	}
	patch(lib$4.Node.prototype, "setDirtiedFunc", function(original, dirtiedFunc) {
		original.call(this, wrapDirtiedFunc(dirtiedFunc));
	});
	patch(lib$4.Config.prototype, "free", function() {
		lib$4.Config.destroy(this);
	});
	patch(lib$4.Node, "create", (_, config) => {
		return config ? lib$4.Node.createWithConfig(config) : lib$4.Node.createDefault();
	});
	patch(lib$4.Node.prototype, "free", function() {
		lib$4.Node.destroy(this);
	});
	patch(lib$4.Node.prototype, "freeRecursive", function() {
		for (let t = 0, T = this.getChildCount(); t < T; ++t) this.getChild(0).freeRecursive();
		this.free();
	});
	patch(lib$4.Node.prototype, "calculateLayout", function(original) {
		let width = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : NaN;
		let height = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : NaN;
		let direction = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : Direction.LTR;
		return original.call(this, width, height, direction);
	});
	return {
		Config: lib$4.Config,
		Node: lib$4.Node,
		...YGEnums_default
	};
}

//#endregion
//#region node_modules/yoga-layout/dist/src/index.js
const Yoga = wrapAssembly(await yoga_wasm_base64_esm_default());
var src_default = Yoga;

//#endregion
//#region node_modules/ansi-regex/index.js
function ansiRegex$1({ onlyFirst = false } = {}) {
	return new RegExp(`(?:\\u001B\\][\\s\\S]*?(?:\\u0007|\\u001B\\u005C|\\u009C))|[\\u001B\\u009B][[\\]()#;?]*(?:\\d{1,4}(?:[;:]\\d{0,4})*)?[\\dA-PR-TZcf-nq-uy=><~]`, onlyFirst ? void 0 : "g");
}

//#endregion
//#region node_modules/strip-ansi/index.js
const regex = ansiRegex$1();
function stripAnsi(string) {
	if (typeof string !== "string") throw new TypeError(`Expected a \`string\`, got \`${typeof string}\``);
	return string.replace(regex, "");
}

//#endregion
//#region node_modules/get-east-asian-width/lookup.js
function isAmbiguous(x) {
	return x === 161 || x === 164 || x === 167 || x === 168 || x === 170 || x === 173 || x === 174 || x >= 176 && x <= 180 || x >= 182 && x <= 186 || x >= 188 && x <= 191 || x === 198 || x === 208 || x === 215 || x === 216 || x >= 222 && x <= 225 || x === 230 || x >= 232 && x <= 234 || x === 236 || x === 237 || x === 240 || x === 242 || x === 243 || x >= 247 && x <= 250 || x === 252 || x === 254 || x === 257 || x === 273 || x === 275 || x === 283 || x === 294 || x === 295 || x === 299 || x >= 305 && x <= 307 || x === 312 || x >= 319 && x <= 322 || x === 324 || x >= 328 && x <= 331 || x === 333 || x === 338 || x === 339 || x === 358 || x === 359 || x === 363 || x === 462 || x === 464 || x === 466 || x === 468 || x === 470 || x === 472 || x === 474 || x === 476 || x === 593 || x === 609 || x === 708 || x === 711 || x >= 713 && x <= 715 || x === 717 || x === 720 || x >= 728 && x <= 731 || x === 733 || x === 735 || x >= 768 && x <= 879 || x >= 913 && x <= 929 || x >= 931 && x <= 937 || x >= 945 && x <= 961 || x >= 963 && x <= 969 || x === 1025 || x >= 1040 && x <= 1103 || x === 1105 || x === 8208 || x >= 8211 && x <= 8214 || x === 8216 || x === 8217 || x === 8220 || x === 8221 || x >= 8224 && x <= 8226 || x >= 8228 && x <= 8231 || x === 8240 || x === 8242 || x === 8243 || x === 8245 || x === 8251 || x === 8254 || x === 8308 || x === 8319 || x >= 8321 && x <= 8324 || x === 8364 || x === 8451 || x === 8453 || x === 8457 || x === 8467 || x === 8470 || x === 8481 || x === 8482 || x === 8486 || x === 8491 || x === 8531 || x === 8532 || x >= 8539 && x <= 8542 || x >= 8544 && x <= 8555 || x >= 8560 && x <= 8569 || x === 8585 || x >= 8592 && x <= 8601 || x === 8632 || x === 8633 || x === 8658 || x === 8660 || x === 8679 || x === 8704 || x === 8706 || x === 8707 || x === 8711 || x === 8712 || x === 8715 || x === 8719 || x === 8721 || x === 8725 || x === 8730 || x >= 8733 && x <= 8736 || x === 8739 || x === 8741 || x >= 8743 && x <= 8748 || x === 8750 || x >= 8756 && x <= 8759 || x === 8764 || x === 8765 || x === 8776 || x === 8780 || x === 8786 || x === 8800 || x === 8801 || x >= 8804 && x <= 8807 || x === 8810 || x === 8811 || x === 8814 || x === 8815 || x === 8834 || x === 8835 || x === 8838 || x === 8839 || x === 8853 || x === 8857 || x === 8869 || x === 8895 || x === 8978 || x >= 9312 && x <= 9449 || x >= 9451 && x <= 9547 || x >= 9552 && x <= 9587 || x >= 9600 && x <= 9615 || x >= 9618 && x <= 9621 || x === 9632 || x === 9633 || x >= 9635 && x <= 9641 || x === 9650 || x === 9651 || x === 9654 || x === 9655 || x === 9660 || x === 9661 || x === 9664 || x === 9665 || x >= 9670 && x <= 9672 || x === 9675 || x >= 9678 && x <= 9681 || x >= 9698 && x <= 9701 || x === 9711 || x === 9733 || x === 9734 || x === 9737 || x === 9742 || x === 9743 || x === 9756 || x === 9758 || x === 9792 || x === 9794 || x === 9824 || x === 9825 || x >= 9827 && x <= 9829 || x >= 9831 && x <= 9834 || x === 9836 || x === 9837 || x === 9839 || x === 9886 || x === 9887 || x === 9919 || x >= 9926 && x <= 9933 || x >= 9935 && x <= 9939 || x >= 9941 && x <= 9953 || x === 9955 || x === 9960 || x === 9961 || x >= 9963 && x <= 9969 || x === 9972 || x >= 9974 && x <= 9977 || x === 9979 || x === 9980 || x === 9982 || x === 9983 || x === 10045 || x >= 10102 && x <= 10111 || x >= 11094 && x <= 11097 || x >= 12872 && x <= 12879 || x >= 57344 && x <= 63743 || x >= 65024 && x <= 65039 || x === 65533 || x >= 127232 && x <= 127242 || x >= 127248 && x <= 127277 || x >= 127280 && x <= 127337 || x >= 127344 && x <= 127373 || x === 127375 || x === 127376 || x >= 127387 && x <= 127404 || x >= 917760 && x <= 917999 || x >= 983040 && x <= 1048573 || x >= 1048576 && x <= 1114109;
}
function isFullWidth(x) {
	return x === 12288 || x >= 65281 && x <= 65376 || x >= 65504 && x <= 65510;
}
function isWide(x) {
	return x >= 4352 && x <= 4447 || x === 8986 || x === 8987 || x === 9001 || x === 9002 || x >= 9193 && x <= 9196 || x === 9200 || x === 9203 || x === 9725 || x === 9726 || x === 9748 || x === 9749 || x >= 9776 && x <= 9783 || x >= 9800 && x <= 9811 || x === 9855 || x >= 9866 && x <= 9871 || x === 9875 || x === 9889 || x === 9898 || x === 9899 || x === 9917 || x === 9918 || x === 9924 || x === 9925 || x === 9934 || x === 9940 || x === 9962 || x === 9970 || x === 9971 || x === 9973 || x === 9978 || x === 9981 || x === 9989 || x === 9994 || x === 9995 || x === 10024 || x === 10060 || x === 10062 || x >= 10067 && x <= 10069 || x === 10071 || x >= 10133 && x <= 10135 || x === 10160 || x === 10175 || x === 11035 || x === 11036 || x === 11088 || x === 11093 || x >= 11904 && x <= 11929 || x >= 11931 && x <= 12019 || x >= 12032 && x <= 12245 || x >= 12272 && x <= 12287 || x >= 12289 && x <= 12350 || x >= 12353 && x <= 12438 || x >= 12441 && x <= 12543 || x >= 12549 && x <= 12591 || x >= 12593 && x <= 12686 || x >= 12688 && x <= 12773 || x >= 12783 && x <= 12830 || x >= 12832 && x <= 12871 || x >= 12880 && x <= 42124 || x >= 42128 && x <= 42182 || x >= 43360 && x <= 43388 || x >= 44032 && x <= 55203 || x >= 63744 && x <= 64255 || x >= 65040 && x <= 65049 || x >= 65072 && x <= 65106 || x >= 65108 && x <= 65126 || x >= 65128 && x <= 65131 || x >= 94176 && x <= 94180 || x >= 94192 && x <= 94198 || x >= 94208 && x <= 101589 || x >= 101631 && x <= 101662 || x >= 101760 && x <= 101874 || x >= 110576 && x <= 110579 || x >= 110581 && x <= 110587 || x === 110589 || x === 110590 || x >= 110592 && x <= 110882 || x === 110898 || x >= 110928 && x <= 110930 || x === 110933 || x >= 110948 && x <= 110951 || x >= 110960 && x <= 111355 || x >= 119552 && x <= 119638 || x >= 119648 && x <= 119670 || x === 126980 || x === 127183 || x === 127374 || x >= 127377 && x <= 127386 || x >= 127488 && x <= 127490 || x >= 127504 && x <= 127547 || x >= 127552 && x <= 127560 || x === 127568 || x === 127569 || x >= 127584 && x <= 127589 || x >= 127744 && x <= 127776 || x >= 127789 && x <= 127797 || x >= 127799 && x <= 127868 || x >= 127870 && x <= 127891 || x >= 127904 && x <= 127946 || x >= 127951 && x <= 127955 || x >= 127968 && x <= 127984 || x === 127988 || x >= 127992 && x <= 128062 || x === 128064 || x >= 128066 && x <= 128252 || x >= 128255 && x <= 128317 || x >= 128331 && x <= 128334 || x >= 128336 && x <= 128359 || x === 128378 || x === 128405 || x === 128406 || x === 128420 || x >= 128507 && x <= 128591 || x >= 128640 && x <= 128709 || x === 128716 || x >= 128720 && x <= 128722 || x >= 128725 && x <= 128728 || x >= 128732 && x <= 128735 || x === 128747 || x === 128748 || x >= 128756 && x <= 128764 || x >= 128992 && x <= 129003 || x === 129008 || x >= 129292 && x <= 129338 || x >= 129340 && x <= 129349 || x >= 129351 && x <= 129535 || x >= 129648 && x <= 129660 || x >= 129664 && x <= 129674 || x >= 129678 && x <= 129734 || x === 129736 || x >= 129741 && x <= 129756 || x >= 129759 && x <= 129770 || x >= 129775 && x <= 129784 || x >= 131072 && x <= 196605 || x >= 196608 && x <= 262141;
}

//#endregion
//#region node_modules/get-east-asian-width/index.js
function validate$1(codePoint) {
	if (!Number.isSafeInteger(codePoint)) throw new TypeError(`Expected a code point, got \`${typeof codePoint}\`.`);
}
function eastAsianWidth(codePoint, { ambiguousAsWide = false } = {}) {
	validate$1(codePoint);
	if (isFullWidth(codePoint) || isWide(codePoint) || ambiguousAsWide && isAmbiguous(codePoint)) return 2;
	return 1;
}

//#endregion
//#region node_modules/emoji-regex/index.js
var require_emoji_regex = /* @__PURE__ */ __commonJS({ "node_modules/emoji-regex/index.js": ((exports, module) => {
	module.exports = () => {
		return /[#*0-9]\uFE0F?\u20E3|[\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u231A\u231B\u2328\u23CF\u23ED-\u23EF\u23F1\u23F2\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB\u25FC\u25FE\u2600-\u2604\u260E\u2611\u2614\u2615\u2618\u2620\u2622\u2623\u2626\u262A\u262E\u262F\u2638-\u263A\u2640\u2642\u2648-\u2653\u265F\u2660\u2663\u2665\u2666\u2668\u267B\u267E\u267F\u2692\u2694-\u2697\u2699\u269B\u269C\u26A0\u26A7\u26AA\u26B0\u26B1\u26BD\u26BE\u26C4\u26C8\u26CF\u26D1\u26E9\u26F0-\u26F5\u26F7\u26F8\u26FA\u2702\u2708\u2709\u270F\u2712\u2714\u2716\u271D\u2721\u2733\u2734\u2744\u2747\u2757\u2763\u27A1\u2934\u2935\u2B05-\u2B07\u2B1B\u2B1C\u2B55\u3030\u303D\u3297\u3299]\uFE0F?|[\u261D\u270C\u270D](?:\uD83C[\uDFFB-\uDFFF]|\uFE0F)?|[\u270A\u270B](?:\uD83C[\uDFFB-\uDFFF])?|[\u23E9-\u23EC\u23F0\u23F3\u25FD\u2693\u26A1\u26AB\u26C5\u26CE\u26D4\u26EA\u26FD\u2705\u2728\u274C\u274E\u2753-\u2755\u2795-\u2797\u27B0\u27BF\u2B50]|\u26D3\uFE0F?(?:\u200D\uD83D\uDCA5)?|\u26F9(?:\uD83C[\uDFFB-\uDFFF]|\uFE0F)?(?:\u200D[\u2640\u2642]\uFE0F?)?|\u2764\uFE0F?(?:\u200D(?:\uD83D\uDD25|\uD83E\uDE79))?|\uD83C(?:[\uDC04\uDD70\uDD71\uDD7E\uDD7F\uDE02\uDE37\uDF21\uDF24-\uDF2C\uDF36\uDF7D\uDF96\uDF97\uDF99-\uDF9B\uDF9E\uDF9F\uDFCD\uDFCE\uDFD4-\uDFDF\uDFF5\uDFF7]\uFE0F?|[\uDF85\uDFC2\uDFC7](?:\uD83C[\uDFFB-\uDFFF])?|[\uDFC4\uDFCA](?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDFCB\uDFCC](?:\uD83C[\uDFFB-\uDFFF]|\uFE0F)?(?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDCCF\uDD8E\uDD91-\uDD9A\uDE01\uDE1A\uDE2F\uDE32-\uDE36\uDE38-\uDE3A\uDE50\uDE51\uDF00-\uDF20\uDF2D-\uDF35\uDF37-\uDF43\uDF45-\uDF4A\uDF4C-\uDF7C\uDF7E-\uDF84\uDF86-\uDF93\uDFA0-\uDFC1\uDFC5\uDFC6\uDFC8\uDFC9\uDFCF-\uDFD3\uDFE0-\uDFF0\uDFF8-\uDFFF]|\uDDE6\uD83C[\uDDE8-\uDDEC\uDDEE\uDDF1\uDDF2\uDDF4\uDDF6-\uDDFA\uDDFC\uDDFD\uDDFF]|\uDDE7\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEF\uDDF1-\uDDF4\uDDF6-\uDDF9\uDDFB\uDDFC\uDDFE\uDDFF]|\uDDE8\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDEE\uDDF0-\uDDF7\uDDFA-\uDDFF]|\uDDE9\uD83C[\uDDEA\uDDEC\uDDEF\uDDF0\uDDF2\uDDF4\uDDFF]|\uDDEA\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDED\uDDF7-\uDDFA]|\uDDEB\uD83C[\uDDEE-\uDDF0\uDDF2\uDDF4\uDDF7]|\uDDEC\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEE\uDDF1-\uDDF3\uDDF5-\uDDFA\uDDFC\uDDFE]|\uDDED\uD83C[\uDDF0\uDDF2\uDDF3\uDDF7\uDDF9\uDDFA]|\uDDEE\uD83C[\uDDE8-\uDDEA\uDDF1-\uDDF4\uDDF6-\uDDF9]|\uDDEF\uD83C[\uDDEA\uDDF2\uDDF4\uDDF5]|\uDDF0\uD83C[\uDDEA\uDDEC-\uDDEE\uDDF2\uDDF3\uDDF5\uDDF7\uDDFC\uDDFE\uDDFF]|\uDDF1\uD83C[\uDDE6-\uDDE8\uDDEE\uDDF0\uDDF7-\uDDFB\uDDFE]|\uDDF2\uD83C[\uDDE6\uDDE8-\uDDED\uDDF0-\uDDFF]|\uDDF3\uD83C[\uDDE6\uDDE8\uDDEA-\uDDEC\uDDEE\uDDF1\uDDF4\uDDF5\uDDF7\uDDFA\uDDFF]|\uDDF4\uD83C\uDDF2|\uDDF5\uD83C[\uDDE6\uDDEA-\uDDED\uDDF0-\uDDF3\uDDF7-\uDDF9\uDDFC\uDDFE]|\uDDF6\uD83C\uDDE6|\uDDF7\uD83C[\uDDEA\uDDF4\uDDF8\uDDFA\uDDFC]|\uDDF8\uD83C[\uDDE6-\uDDEA\uDDEC-\uDDF4\uDDF7-\uDDF9\uDDFB\uDDFD-\uDDFF]|\uDDF9\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDED\uDDEF-\uDDF4\uDDF7\uDDF9\uDDFB\uDDFC\uDDFF]|\uDDFA\uD83C[\uDDE6\uDDEC\uDDF2\uDDF3\uDDF8\uDDFE\uDDFF]|\uDDFB\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDEE\uDDF3\uDDFA]|\uDDFC\uD83C[\uDDEB\uDDF8]|\uDDFD\uD83C\uDDF0|\uDDFE\uD83C[\uDDEA\uDDF9]|\uDDFF\uD83C[\uDDE6\uDDF2\uDDFC]|\uDF44(?:\u200D\uD83D\uDFEB)?|\uDF4B(?:\u200D\uD83D\uDFE9)?|\uDFC3(?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D(?:[\u2640\u2642]\uFE0F?(?:\u200D\u27A1\uFE0F?)?|\u27A1\uFE0F?))?|\uDFF3\uFE0F?(?:\u200D(?:\u26A7\uFE0F?|\uD83C\uDF08))?|\uDFF4(?:\u200D\u2620\uFE0F?|\uDB40\uDC67\uDB40\uDC62\uDB40(?:\uDC65\uDB40\uDC6E\uDB40\uDC67|\uDC73\uDB40\uDC63\uDB40\uDC74|\uDC77\uDB40\uDC6C\uDB40\uDC73)\uDB40\uDC7F)?)|\uD83D(?:[\uDC3F\uDCFD\uDD49\uDD4A\uDD6F\uDD70\uDD73\uDD76-\uDD79\uDD87\uDD8A-\uDD8D\uDDA5\uDDA8\uDDB1\uDDB2\uDDBC\uDDC2-\uDDC4\uDDD1-\uDDD3\uDDDC-\uDDDE\uDDE1\uDDE3\uDDE8\uDDEF\uDDF3\uDDFA\uDECB\uDECD-\uDECF\uDEE0-\uDEE5\uDEE9\uDEF0\uDEF3]\uFE0F?|[\uDC42\uDC43\uDC46-\uDC50\uDC66\uDC67\uDC6B-\uDC6D\uDC72\uDC74-\uDC76\uDC78\uDC7C\uDC83\uDC85\uDC8F\uDC91\uDCAA\uDD7A\uDD95\uDD96\uDE4C\uDE4F\uDEC0\uDECC](?:\uD83C[\uDFFB-\uDFFF])?|[\uDC6E-\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4\uDEB5](?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDD74\uDD90](?:\uD83C[\uDFFB-\uDFFF]|\uFE0F)?|[\uDC00-\uDC07\uDC09-\uDC14\uDC16-\uDC25\uDC27-\uDC3A\uDC3C-\uDC3E\uDC40\uDC44\uDC45\uDC51-\uDC65\uDC6A\uDC79-\uDC7B\uDC7D-\uDC80\uDC84\uDC88-\uDC8E\uDC90\uDC92-\uDCA9\uDCAB-\uDCFC\uDCFF-\uDD3D\uDD4B-\uDD4E\uDD50-\uDD67\uDDA4\uDDFB-\uDE2D\uDE2F-\uDE34\uDE37-\uDE41\uDE43\uDE44\uDE48-\uDE4A\uDE80-\uDEA2\uDEA4-\uDEB3\uDEB7-\uDEBF\uDEC1-\uDEC5\uDED0-\uDED2\uDED5-\uDED8\uDEDC-\uDEDF\uDEEB\uDEEC\uDEF4-\uDEFC\uDFE0-\uDFEB\uDFF0]|\uDC08(?:\u200D\u2B1B)?|\uDC15(?:\u200D\uD83E\uDDBA)?|\uDC26(?:\u200D(?:\u2B1B|\uD83D\uDD25))?|\uDC3B(?:\u200D\u2744\uFE0F?)?|\uDC41\uFE0F?(?:\u200D\uD83D\uDDE8\uFE0F?)?|\uDC68(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDC68\uDC69]\u200D\uD83D(?:\uDC66(?:\u200D\uD83D\uDC66)?|\uDC67(?:\u200D\uD83D[\uDC66\uDC67])?)|[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC66(?:\u200D\uD83D\uDC66)?|\uDC67(?:\u200D\uD83D[\uDC66\uDC67])?)|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]))|\uD83C(?:\uDFFB(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC30\u200D\uD83D\uDC68\uD83C[\uDFFC-\uDFFF])|\uD83E(?:[\uDD1D\uDEEF]\u200D\uD83D\uDC68\uD83C[\uDFFC-\uDFFF]|[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3])))?|\uDFFC(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC30\u200D\uD83D\uDC68\uD83C[\uDFFB\uDFFD-\uDFFF])|\uD83E(?:[\uDD1D\uDEEF]\u200D\uD83D\uDC68\uD83C[\uDFFB\uDFFD-\uDFFF]|[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3])))?|\uDFFD(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC30\u200D\uD83D\uDC68\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])|\uD83E(?:[\uDD1D\uDEEF]\u200D\uD83D\uDC68\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF]|[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3])))?|\uDFFE(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC30\u200D\uD83D\uDC68\uD83C[\uDFFB-\uDFFD\uDFFF])|\uD83E(?:[\uDD1D\uDEEF]\u200D\uD83D\uDC68\uD83C[\uDFFB-\uDFFD\uDFFF]|[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3])))?|\uDFFF(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC30\u200D\uD83D\uDC68\uD83C[\uDFFB-\uDFFE])|\uD83E(?:[\uDD1D\uDEEF]\u200D\uD83D\uDC68\uD83C[\uDFFB-\uDFFE]|[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3])))?))?|\uDC69(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?[\uDC68\uDC69]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC66(?:\u200D\uD83D\uDC66)?|\uDC67(?:\u200D\uD83D[\uDC66\uDC67])?|\uDC69\u200D\uD83D(?:\uDC66(?:\u200D\uD83D\uDC66)?|\uDC67(?:\u200D\uD83D[\uDC66\uDC67])?))|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]))|\uD83C(?:\uDFFB(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC30\u200D\uD83D\uDC69\uD83C[\uDFFC-\uDFFF])|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFC-\uDFFF]|\uDEEF\u200D\uD83D\uDC69\uD83C[\uDFFC-\uDFFF])))?|\uDFFC(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC30\u200D\uD83D\uDC69\uD83C[\uDFFB\uDFFD-\uDFFF])|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFB\uDFFD-\uDFFF]|\uDEEF\u200D\uD83D\uDC69\uD83C[\uDFFB\uDFFD-\uDFFF])))?|\uDFFD(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC30\u200D\uD83D\uDC69\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF]|\uDEEF\u200D\uD83D\uDC69\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])))?|\uDFFE(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC30\u200D\uD83D\uDC69\uD83C[\uDFFB-\uDFFD\uDFFF])|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFB-\uDFFD\uDFFF]|\uDEEF\u200D\uD83D\uDC69\uD83C[\uDFFB-\uDFFD\uDFFF])))?|\uDFFF(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC30\u200D\uD83D\uDC69\uD83C[\uDFFB-\uDFFE])|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFB-\uDFFE]|\uDEEF\u200D\uD83D\uDC69\uD83C[\uDFFB-\uDFFE])))?))?|\uDD75(?:\uD83C[\uDFFB-\uDFFF]|\uFE0F)?(?:\u200D[\u2640\u2642]\uFE0F?)?|\uDE2E(?:\u200D\uD83D\uDCA8)?|\uDE35(?:\u200D\uD83D\uDCAB)?|\uDE36(?:\u200D\uD83C\uDF2B\uFE0F?)?|\uDE42(?:\u200D[\u2194\u2195]\uFE0F?)?|\uDEB6(?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D(?:[\u2640\u2642]\uFE0F?(?:\u200D\u27A1\uFE0F?)?|\u27A1\uFE0F?))?)|\uD83E(?:[\uDD0C\uDD0F\uDD18-\uDD1F\uDD30-\uDD34\uDD36\uDD77\uDDB5\uDDB6\uDDBB\uDDD2\uDDD3\uDDD5\uDEC3-\uDEC5\uDEF0\uDEF2-\uDEF8](?:\uD83C[\uDFFB-\uDFFF])?|[\uDD26\uDD35\uDD37-\uDD39\uDD3C-\uDD3E\uDDB8\uDDB9\uDDCD\uDDCF\uDDD4\uDDD6-\uDDDD](?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDDDE\uDDDF](?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDD0D\uDD0E\uDD10-\uDD17\uDD20-\uDD25\uDD27-\uDD2F\uDD3A\uDD3F-\uDD45\uDD47-\uDD76\uDD78-\uDDB4\uDDB7\uDDBA\uDDBC-\uDDCC\uDDD0\uDDE0-\uDDFF\uDE70-\uDE7C\uDE80-\uDE8A\uDE8E-\uDEC2\uDEC6\uDEC8\uDECD-\uDEDC\uDEDF-\uDEEA\uDEEF]|\uDDCE(?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D(?:[\u2640\u2642]\uFE0F?(?:\u200D\u27A1\uFE0F?)?|\u27A1\uFE0F?))?|\uDDD1(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3\uDE70]|\uDD1D\u200D\uD83E\uDDD1|\uDDD1\u200D\uD83E\uDDD2(?:\u200D\uD83E\uDDD2)?|\uDDD2(?:\u200D\uD83E\uDDD2)?))|\uD83C(?:\uDFFB(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFC-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC30\u200D\uD83E\uDDD1\uD83C[\uDFFC-\uDFFF])|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3\uDE70]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF]|\uDEEF\u200D\uD83E\uDDD1\uD83C[\uDFFC-\uDFFF])))?|\uDFFC(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFB\uDFFD-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC30\u200D\uD83E\uDDD1\uD83C[\uDFFB\uDFFD-\uDFFF])|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3\uDE70]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF]|\uDEEF\u200D\uD83E\uDDD1\uD83C[\uDFFB\uDFFD-\uDFFF])))?|\uDFFD(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC30\u200D\uD83E\uDDD1\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3\uDE70]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF]|\uDEEF\u200D\uD83E\uDDD1\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])))?|\uDFFE(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFB-\uDFFD\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC30\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFD\uDFFF])|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3\uDE70]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF]|\uDEEF\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFD\uDFFF])))?|\uDFFF(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFB-\uDFFE]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC30\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFE])|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3\uDE70]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF]|\uDEEF\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFE])))?))?|\uDEF1(?:\uD83C(?:\uDFFB(?:\u200D\uD83E\uDEF2\uD83C[\uDFFC-\uDFFF])?|\uDFFC(?:\u200D\uD83E\uDEF2\uD83C[\uDFFB\uDFFD-\uDFFF])?|\uDFFD(?:\u200D\uD83E\uDEF2\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])?|\uDFFE(?:\u200D\uD83E\uDEF2\uD83C[\uDFFB-\uDFFD\uDFFF])?|\uDFFF(?:\u200D\uD83E\uDEF2\uD83C[\uDFFB-\uDFFE])?))?)/g;
	};
}) });

//#endregion
//#region node_modules/string-width/index.js
var import_emoji_regex = /* @__PURE__ */ __toESM(require_emoji_regex(), 1);
const segmenter = new Intl.Segmenter();
const defaultIgnorableCodePointRegex = /^\p{Default_Ignorable_Code_Point}$/u;
function stringWidth(string, options = {}) {
	if (typeof string !== "string" || string.length === 0) return 0;
	const { ambiguousIsNarrow = true, countAnsiEscapeCodes = false } = options;
	if (!countAnsiEscapeCodes) string = stripAnsi(string);
	if (string.length === 0) return 0;
	let width = 0;
	const eastAsianWidthOptions = { ambiguousAsWide: !ambiguousIsNarrow };
	for (const { segment: character } of segmenter.segment(string)) {
		const codePoint = character.codePointAt(0);
		if (codePoint <= 31 || codePoint >= 127 && codePoint <= 159) continue;
		if (codePoint >= 8203 && codePoint <= 8207 || codePoint === 65279) continue;
		if (codePoint >= 768 && codePoint <= 879 || codePoint >= 6832 && codePoint <= 6911 || codePoint >= 7616 && codePoint <= 7679 || codePoint >= 8400 && codePoint <= 8447 || codePoint >= 65056 && codePoint <= 65071) continue;
		if (codePoint >= 55296 && codePoint <= 57343) continue;
		if (codePoint >= 65024 && codePoint <= 65039) continue;
		if (defaultIgnorableCodePointRegex.test(character)) continue;
		if ((0, import_emoji_regex.default)().test(character)) {
			width += 2;
			continue;
		}
		width += eastAsianWidth(codePoint, eastAsianWidthOptions);
	}
	return width;
}

//#endregion
//#region node_modules/ansi-styles/index.js
const ANSI_BACKGROUND_OFFSET$1 = 10;
const wrapAnsi16$1 = (offset = 0) => (code) => `\u001B[${code + offset}m`;
const wrapAnsi256$1 = (offset = 0) => (code) => `\u001B[${38 + offset};5;${code}m`;
const wrapAnsi16m$1 = (offset = 0) => (red, green, blue) => `\u001B[${38 + offset};2;${red};${green};${blue}m`;
const styles$3 = {
	modifier: {
		reset: [0, 0],
		bold: [1, 22],
		dim: [2, 22],
		italic: [3, 23],
		underline: [4, 24],
		overline: [53, 55],
		inverse: [7, 27],
		hidden: [8, 28],
		strikethrough: [9, 29]
	},
	color: {
		black: [30, 39],
		red: [31, 39],
		green: [32, 39],
		yellow: [33, 39],
		blue: [34, 39],
		magenta: [35, 39],
		cyan: [36, 39],
		white: [37, 39],
		blackBright: [90, 39],
		gray: [90, 39],
		grey: [90, 39],
		redBright: [91, 39],
		greenBright: [92, 39],
		yellowBright: [93, 39],
		blueBright: [94, 39],
		magentaBright: [95, 39],
		cyanBright: [96, 39],
		whiteBright: [97, 39]
	},
	bgColor: {
		bgBlack: [40, 49],
		bgRed: [41, 49],
		bgGreen: [42, 49],
		bgYellow: [43, 49],
		bgBlue: [44, 49],
		bgMagenta: [45, 49],
		bgCyan: [46, 49],
		bgWhite: [47, 49],
		bgBlackBright: [100, 49],
		bgGray: [100, 49],
		bgGrey: [100, 49],
		bgRedBright: [101, 49],
		bgGreenBright: [102, 49],
		bgYellowBright: [103, 49],
		bgBlueBright: [104, 49],
		bgMagentaBright: [105, 49],
		bgCyanBright: [106, 49],
		bgWhiteBright: [107, 49]
	}
};
const modifierNames$1 = Object.keys(styles$3.modifier);
const foregroundColorNames$1 = Object.keys(styles$3.color);
const backgroundColorNames$1 = Object.keys(styles$3.bgColor);
const colorNames$1 = [...foregroundColorNames$1, ...backgroundColorNames$1];
function assembleStyles$1() {
	const codes = /* @__PURE__ */ new Map();
	for (const [groupName, group] of Object.entries(styles$3)) {
		for (const [styleName, style] of Object.entries(group)) {
			styles$3[styleName] = {
				open: `\u001B[${style[0]}m`,
				close: `\u001B[${style[1]}m`
			};
			group[styleName] = styles$3[styleName];
			codes.set(style[0], style[1]);
		}
		Object.defineProperty(styles$3, groupName, {
			value: group,
			enumerable: false
		});
	}
	Object.defineProperty(styles$3, "codes", {
		value: codes,
		enumerable: false
	});
	styles$3.color.close = "\x1B[39m";
	styles$3.bgColor.close = "\x1B[49m";
	styles$3.color.ansi = wrapAnsi16$1();
	styles$3.color.ansi256 = wrapAnsi256$1();
	styles$3.color.ansi16m = wrapAnsi16m$1();
	styles$3.bgColor.ansi = wrapAnsi16$1(ANSI_BACKGROUND_OFFSET$1);
	styles$3.bgColor.ansi256 = wrapAnsi256$1(ANSI_BACKGROUND_OFFSET$1);
	styles$3.bgColor.ansi16m = wrapAnsi16m$1(ANSI_BACKGROUND_OFFSET$1);
	Object.defineProperties(styles$3, {
		rgbToAnsi256: {
			value(red, green, blue) {
				if (red === green && green === blue) {
					if (red < 8) return 16;
					if (red > 248) return 231;
					return Math.round((red - 8) / 247 * 24) + 232;
				}
				return 16 + 36 * Math.round(red / 255 * 5) + 6 * Math.round(green / 255 * 5) + Math.round(blue / 255 * 5);
			},
			enumerable: false
		},
		hexToRgb: {
			value(hex) {
				const matches = /[a-f\d]{6}|[a-f\d]{3}/i.exec(hex.toString(16));
				if (!matches) return [
					0,
					0,
					0
				];
				let [colorString] = matches;
				if (colorString.length === 3) colorString = [...colorString].map((character) => character + character).join("");
				const integer = Number.parseInt(colorString, 16);
				return [
					integer >> 16 & 255,
					integer >> 8 & 255,
					integer & 255
				];
			},
			enumerable: false
		},
		hexToAnsi256: {
			value: (hex) => styles$3.rgbToAnsi256(...styles$3.hexToRgb(hex)),
			enumerable: false
		},
		ansi256ToAnsi: {
			value(code) {
				if (code < 8) return 30 + code;
				if (code < 16) return 90 + (code - 8);
				let red;
				let green;
				let blue;
				if (code >= 232) {
					red = ((code - 232) * 10 + 8) / 255;
					green = red;
					blue = red;
				} else {
					code -= 16;
					const remainder = code % 36;
					red = Math.floor(code / 36) / 5;
					green = Math.floor(remainder / 6) / 5;
					blue = remainder % 6 / 5;
				}
				const value = Math.max(red, green, blue) * 2;
				if (value === 0) return 30;
				let result = 30 + (Math.round(blue) << 2 | Math.round(green) << 1 | Math.round(red));
				if (value === 2) result += 60;
				return result;
			},
			enumerable: false
		},
		rgbToAnsi: {
			value: (red, green, blue) => styles$3.ansi256ToAnsi(styles$3.rgbToAnsi256(red, green, blue)),
			enumerable: false
		},
		hexToAnsi: {
			value: (hex) => styles$3.ansi256ToAnsi(styles$3.hexToAnsi256(hex)),
			enumerable: false
		}
	});
	return styles$3;
}
const ansiStyles$1 = assembleStyles$1();
var ansi_styles_default = ansiStyles$1;

//#endregion
//#region node_modules/wrap-ansi/index.js
const ESCAPES$3 = new Set(["\x1B", ""]);
const END_CODE = 39;
const ANSI_ESCAPE_BELL = "\x07";
const ANSI_CSI = "[";
const ANSI_OSC = "]";
const ANSI_SGR_TERMINATOR = "m";
const ANSI_ESCAPE_LINK = `${ANSI_OSC}8;;`;
const wrapAnsiCode = (code) => `${ESCAPES$3.values().next().value}${ANSI_CSI}${code}${ANSI_SGR_TERMINATOR}`;
const wrapAnsiHyperlink = (url) => `${ESCAPES$3.values().next().value}${ANSI_ESCAPE_LINK}${url}${ANSI_ESCAPE_BELL}`;
const wordLengths = (string) => string.split(" ").map((character) => stringWidth(character));
const wrapWord = (rows, word, columns) => {
	const characters = [...word];
	let isInsideEscape = false;
	let isInsideLinkEscape = false;
	let visible = stringWidth(stripAnsi(rows.at(-1)));
	for (const [index, character] of characters.entries()) {
		const characterLength = stringWidth(character);
		if (visible + characterLength <= columns) rows[rows.length - 1] += character;
		else {
			rows.push(character);
			visible = 0;
		}
		if (ESCAPES$3.has(character)) {
			isInsideEscape = true;
			isInsideLinkEscape = characters.slice(index + 1, index + 1 + ANSI_ESCAPE_LINK.length).join("") === ANSI_ESCAPE_LINK;
		}
		if (isInsideEscape) {
			if (isInsideLinkEscape) {
				if (character === ANSI_ESCAPE_BELL) {
					isInsideEscape = false;
					isInsideLinkEscape = false;
				}
			} else if (character === ANSI_SGR_TERMINATOR) isInsideEscape = false;
			continue;
		}
		visible += characterLength;
		if (visible === columns && index < characters.length - 1) {
			rows.push("");
			visible = 0;
		}
	}
	if (!visible && rows.at(-1).length > 0 && rows.length > 1) rows[rows.length - 2] += rows.pop();
};
const stringVisibleTrimSpacesRight = (string) => {
	const words = string.split(" ");
	let last = words.length;
	while (last > 0) {
		if (stringWidth(words[last - 1]) > 0) break;
		last--;
	}
	if (last === words.length) return string;
	return words.slice(0, last).join(" ") + words.slice(last).join("");
};
const exec = (string, columns, options = {}) => {
	if (options.trim !== false && string.trim() === "") return "";
	let returnValue = "";
	let escapeCode;
	let escapeUrl;
	const lengths = wordLengths(string);
	let rows = [""];
	for (const [index, word] of string.split(" ").entries()) {
		if (options.trim !== false) rows[rows.length - 1] = rows.at(-1).trimStart();
		let rowLength = stringWidth(rows.at(-1));
		if (index !== 0) {
			if (rowLength >= columns && (options.wordWrap === false || options.trim === false)) {
				rows.push("");
				rowLength = 0;
			}
			if (rowLength > 0 || options.trim === false) {
				rows[rows.length - 1] += " ";
				rowLength++;
			}
		}
		if (options.hard && lengths[index] > columns) {
			const remainingColumns = columns - rowLength;
			const breaksStartingThisLine = 1 + Math.floor((lengths[index] - remainingColumns - 1) / columns);
			if (Math.floor((lengths[index] - 1) / columns) < breaksStartingThisLine) rows.push("");
			wrapWord(rows, word, columns);
			continue;
		}
		if (rowLength + lengths[index] > columns && rowLength > 0 && lengths[index] > 0) {
			if (options.wordWrap === false && rowLength < columns) {
				wrapWord(rows, word, columns);
				continue;
			}
			rows.push("");
		}
		if (rowLength + lengths[index] > columns && options.wordWrap === false) {
			wrapWord(rows, word, columns);
			continue;
		}
		rows[rows.length - 1] += word;
	}
	if (options.trim !== false) rows = rows.map((row) => stringVisibleTrimSpacesRight(row));
	const preString = rows.join("\n");
	const pre = [...preString];
	let preStringIndex = 0;
	for (const [index, character] of pre.entries()) {
		returnValue += character;
		if (ESCAPES$3.has(character)) {
			const { groups } = (/* @__PURE__ */ new RegExp(`(?:\\${ANSI_CSI}(?<code>\\d+)m|\\${ANSI_ESCAPE_LINK}(?<uri>.*)${ANSI_ESCAPE_BELL})`)).exec(preString.slice(preStringIndex)) || { groups: {} };
			if (groups.code !== void 0) {
				const code$1 = Number.parseFloat(groups.code);
				escapeCode = code$1 === END_CODE ? void 0 : code$1;
			} else if (groups.uri !== void 0) escapeUrl = groups.uri.length === 0 ? void 0 : groups.uri;
		}
		const code = ansi_styles_default.codes.get(Number(escapeCode));
		if (pre[index + 1] === "\n") {
			if (escapeUrl) returnValue += wrapAnsiHyperlink("");
			if (escapeCode && code) returnValue += wrapAnsiCode(code);
		} else if (character === "\n") {
			if (escapeCode && code) returnValue += wrapAnsiCode(escapeCode);
			if (escapeUrl) returnValue += wrapAnsiHyperlink(escapeUrl);
		}
		preStringIndex += character.length;
	}
	return returnValue;
};
function wrapAnsi(string, columns, options) {
	return String(string).normalize().replaceAll("\r\n", "\n").split("\n").map((line) => exec(line, columns, options)).join("\n");
}

//#endregion
//#region node_modules/scheduler/cjs/scheduler.production.js
var require_scheduler_production = /* @__PURE__ */ __commonJS({ "node_modules/scheduler/cjs/scheduler.production.js": ((exports) => {
	function push$1(heap, node) {
		var index = heap.length;
		heap.push(node);
		a: for (; 0 < index;) {
			var parentIndex = index - 1 >>> 1, parent = heap[parentIndex];
			if (0 < compare(parent, node)) heap[parentIndex] = node, heap[index] = parent, index = parentIndex;
			else break a;
		}
	}
	function peek(heap) {
		return 0 === heap.length ? null : heap[0];
	}
	function pop(heap) {
		if (0 === heap.length) return null;
		var first = heap[0], last = heap.pop();
		if (last !== first) {
			heap[0] = last;
			a: for (var index = 0, length = heap.length, halfLength = length >>> 1; index < halfLength;) {
				var leftIndex = 2 * (index + 1) - 1, left = heap[leftIndex], rightIndex = leftIndex + 1, right = heap[rightIndex];
				if (0 > compare(left, last)) rightIndex < length && 0 > compare(right, left) ? (heap[index] = right, heap[rightIndex] = last, index = rightIndex) : (heap[index] = left, heap[leftIndex] = last, index = leftIndex);
				else if (rightIndex < length && 0 > compare(right, last)) heap[index] = right, heap[rightIndex] = last, index = rightIndex;
				else break a;
			}
		}
		return first;
	}
	function compare(a, b) {
		var diff$1 = a.sortIndex - b.sortIndex;
		return 0 !== diff$1 ? diff$1 : a.id - b.id;
	}
	exports.unstable_now = void 0;
	if ("object" === typeof performance && "function" === typeof performance.now) {
		var localPerformance = performance;
		exports.unstable_now = function() {
			return localPerformance.now();
		};
	} else {
		var localDate = Date, initialTime = localDate.now();
		exports.unstable_now = function() {
			return localDate.now() - initialTime;
		};
	}
	var taskQueue = [], timerQueue = [], taskIdCounter = 1, currentTask = null, currentPriorityLevel = 3, isPerformingWork = !1, isHostCallbackScheduled = !1, isHostTimeoutScheduled = !1, needsPaint = !1, localSetTimeout = "function" === typeof setTimeout ? setTimeout : null, localClearTimeout = "function" === typeof clearTimeout ? clearTimeout : null, localSetImmediate = "undefined" !== typeof setImmediate ? setImmediate : null;
	function advanceTimers(currentTime) {
		for (var timer = peek(timerQueue); null !== timer;) {
			if (null === timer.callback) pop(timerQueue);
			else if (timer.startTime <= currentTime) pop(timerQueue), timer.sortIndex = timer.expirationTime, push$1(taskQueue, timer);
			else break;
			timer = peek(timerQueue);
		}
	}
	function handleTimeout(currentTime) {
		isHostTimeoutScheduled = !1;
		advanceTimers(currentTime);
		if (!isHostCallbackScheduled) if (null !== peek(taskQueue)) isHostCallbackScheduled = !0, isMessageLoopRunning || (isMessageLoopRunning = !0, schedulePerformWorkUntilDeadline());
		else {
			var firstTimer = peek(timerQueue);
			null !== firstTimer && requestHostTimeout(handleTimeout, firstTimer.startTime - currentTime);
		}
	}
	var isMessageLoopRunning = !1, taskTimeoutID = -1, frameInterval = 5, startTime = -1;
	function shouldYieldToHost() {
		return needsPaint ? !0 : exports.unstable_now() - startTime < frameInterval ? !1 : !0;
	}
	function performWorkUntilDeadline() {
		needsPaint = !1;
		if (isMessageLoopRunning) {
			var currentTime = exports.unstable_now();
			startTime = currentTime;
			var hasMoreWork = !0;
			try {
				a: {
					isHostCallbackScheduled = !1;
					isHostTimeoutScheduled && (isHostTimeoutScheduled = !1, localClearTimeout(taskTimeoutID), taskTimeoutID = -1);
					isPerformingWork = !0;
					var previousPriorityLevel = currentPriorityLevel;
					try {
						b: {
							advanceTimers(currentTime);
							for (currentTask = peek(taskQueue); null !== currentTask && !(currentTask.expirationTime > currentTime && shouldYieldToHost());) {
								var callback = currentTask.callback;
								if ("function" === typeof callback) {
									currentTask.callback = null;
									currentPriorityLevel = currentTask.priorityLevel;
									var continuationCallback = callback(currentTask.expirationTime <= currentTime);
									currentTime = exports.unstable_now();
									if ("function" === typeof continuationCallback) {
										currentTask.callback = continuationCallback;
										advanceTimers(currentTime);
										hasMoreWork = !0;
										break b;
									}
									currentTask === peek(taskQueue) && pop(taskQueue);
									advanceTimers(currentTime);
								} else pop(taskQueue);
								currentTask = peek(taskQueue);
							}
							if (null !== currentTask) hasMoreWork = !0;
							else {
								var firstTimer = peek(timerQueue);
								null !== firstTimer && requestHostTimeout(handleTimeout, firstTimer.startTime - currentTime);
								hasMoreWork = !1;
							}
						}
						break a;
					} finally {
						currentTask = null, currentPriorityLevel = previousPriorityLevel, isPerformingWork = !1;
					}
					hasMoreWork = void 0;
				}
			} finally {
				hasMoreWork ? schedulePerformWorkUntilDeadline() : isMessageLoopRunning = !1;
			}
		}
	}
	var schedulePerformWorkUntilDeadline;
	if ("function" === typeof localSetImmediate) schedulePerformWorkUntilDeadline = function() {
		localSetImmediate(performWorkUntilDeadline);
	};
	else if ("undefined" !== typeof MessageChannel) {
		var channel = new MessageChannel(), port = channel.port2;
		channel.port1.onmessage = performWorkUntilDeadline;
		schedulePerformWorkUntilDeadline = function() {
			port.postMessage(null);
		};
	} else schedulePerformWorkUntilDeadline = function() {
		localSetTimeout(performWorkUntilDeadline, 0);
	};
	function requestHostTimeout(callback, ms) {
		taskTimeoutID = localSetTimeout(function() {
			callback(exports.unstable_now());
		}, ms);
	}
	exports.unstable_IdlePriority = 5;
	exports.unstable_ImmediatePriority = 1;
	exports.unstable_LowPriority = 4;
	exports.unstable_NormalPriority = 3;
	exports.unstable_Profiling = null;
	exports.unstable_UserBlockingPriority = 2;
	exports.unstable_cancelCallback = function(task) {
		task.callback = null;
	};
	exports.unstable_forceFrameRate = function(fps) {
		0 > fps || 125 < fps ? console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported") : frameInterval = 0 < fps ? Math.floor(1e3 / fps) : 5;
	};
	exports.unstable_getCurrentPriorityLevel = function() {
		return currentPriorityLevel;
	};
	exports.unstable_next = function(eventHandler) {
		switch (currentPriorityLevel) {
			case 1:
			case 2:
			case 3:
				var priorityLevel = 3;
				break;
			default: priorityLevel = currentPriorityLevel;
		}
		var previousPriorityLevel = currentPriorityLevel;
		currentPriorityLevel = priorityLevel;
		try {
			return eventHandler();
		} finally {
			currentPriorityLevel = previousPriorityLevel;
		}
	};
	exports.unstable_requestPaint = function() {
		needsPaint = !0;
	};
	exports.unstable_runWithPriority = function(priorityLevel, eventHandler) {
		switch (priorityLevel) {
			case 1:
			case 2:
			case 3:
			case 4:
			case 5: break;
			default: priorityLevel = 3;
		}
		var previousPriorityLevel = currentPriorityLevel;
		currentPriorityLevel = priorityLevel;
		try {
			return eventHandler();
		} finally {
			currentPriorityLevel = previousPriorityLevel;
		}
	};
	exports.unstable_scheduleCallback = function(priorityLevel, callback, options) {
		var currentTime = exports.unstable_now();
		"object" === typeof options && null !== options ? (options = options.delay, options = "number" === typeof options && 0 < options ? currentTime + options : currentTime) : options = currentTime;
		switch (priorityLevel) {
			case 1:
				var timeout = -1;
				break;
			case 2:
				timeout = 250;
				break;
			case 5:
				timeout = 1073741823;
				break;
			case 4:
				timeout = 1e4;
				break;
			default: timeout = 5e3;
		}
		timeout = options + timeout;
		priorityLevel = {
			id: taskIdCounter++,
			callback,
			priorityLevel,
			startTime: options,
			expirationTime: timeout,
			sortIndex: -1
		};
		options > currentTime ? (priorityLevel.sortIndex = options, push$1(timerQueue, priorityLevel), null === peek(taskQueue) && priorityLevel === peek(timerQueue) && (isHostTimeoutScheduled ? (localClearTimeout(taskTimeoutID), taskTimeoutID = -1) : isHostTimeoutScheduled = !0, requestHostTimeout(handleTimeout, options - currentTime))) : (priorityLevel.sortIndex = timeout, push$1(taskQueue, priorityLevel), isHostCallbackScheduled || isPerformingWork || (isHostCallbackScheduled = !0, isMessageLoopRunning || (isMessageLoopRunning = !0, schedulePerformWorkUntilDeadline())));
		return priorityLevel;
	};
	exports.unstable_shouldYield = shouldYieldToHost;
	exports.unstable_wrapCallback = function(callback) {
		var parentPriorityLevel = currentPriorityLevel;
		return function() {
			var previousPriorityLevel = currentPriorityLevel;
			currentPriorityLevel = parentPriorityLevel;
			try {
				return callback.apply(this, arguments);
			} finally {
				currentPriorityLevel = previousPriorityLevel;
			}
		};
	};
}) });

//#endregion
//#region node_modules/scheduler/index.js
var require_scheduler = /* @__PURE__ */ __commonJS({ "node_modules/scheduler/index.js": ((exports, module) => {
	module.exports = require_scheduler_production();
}) });

//#endregion
//#region node_modules/react-reconciler/cjs/react-reconciler.production.js
var require_react_reconciler_production = /* @__PURE__ */ __commonJS({ "node_modules/react-reconciler/cjs/react-reconciler.production.js": ((exports, module) => {
	module.exports = function($$$config) {
		function createFiber(tag, pendingProps, key, mode) {
			return new FiberNode(tag, pendingProps, key, mode);
		}
		function noop$2() {}
		function formatProdErrorMessage(code) {
			var url = "https://react.dev/errors/" + code;
			if (1 < arguments.length) {
				url += "?args[]=" + encodeURIComponent(arguments[1]);
				for (var i = 2; i < arguments.length; i++) url += "&args[]=" + encodeURIComponent(arguments[i]);
			}
			return "Minified React error #" + code + "; visit " + url + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
		}
		function getNearestMountedFiber(fiber) {
			var node = fiber, nearestMounted = fiber;
			if (fiber.alternate) for (; node.return;) node = node.return;
			else {
				fiber = node;
				do
					node = fiber, 0 !== (node.flags & 4098) && (nearestMounted = node.return), fiber = node.return;
				while (fiber);
			}
			return 3 === node.tag ? nearestMounted : null;
		}
		function assertIsMounted(fiber) {
			if (getNearestMountedFiber(fiber) !== fiber) throw Error(formatProdErrorMessage(188));
		}
		function findCurrentFiberUsingSlowPath(fiber) {
			var alternate = fiber.alternate;
			if (!alternate) {
				alternate = getNearestMountedFiber(fiber);
				if (null === alternate) throw Error(formatProdErrorMessage(188));
				return alternate !== fiber ? null : fiber;
			}
			for (var a = fiber, b = alternate;;) {
				var parentA = a.return;
				if (null === parentA) break;
				var parentB = parentA.alternate;
				if (null === parentB) {
					b = parentA.return;
					if (null !== b) {
						a = b;
						continue;
					}
					break;
				}
				if (parentA.child === parentB.child) {
					for (parentB = parentA.child; parentB;) {
						if (parentB === a) return assertIsMounted(parentA), fiber;
						if (parentB === b) return assertIsMounted(parentA), alternate;
						parentB = parentB.sibling;
					}
					throw Error(formatProdErrorMessage(188));
				}
				if (a.return !== b.return) a = parentA, b = parentB;
				else {
					for (var didFindChild = !1, child$0 = parentA.child; child$0;) {
						if (child$0 === a) {
							didFindChild = !0;
							a = parentA;
							b = parentB;
							break;
						}
						if (child$0 === b) {
							didFindChild = !0;
							b = parentA;
							a = parentB;
							break;
						}
						child$0 = child$0.sibling;
					}
					if (!didFindChild) {
						for (child$0 = parentB.child; child$0;) {
							if (child$0 === a) {
								didFindChild = !0;
								a = parentB;
								b = parentA;
								break;
							}
							if (child$0 === b) {
								didFindChild = !0;
								b = parentB;
								a = parentA;
								break;
							}
							child$0 = child$0.sibling;
						}
						if (!didFindChild) throw Error(formatProdErrorMessage(189));
					}
				}
				if (a.alternate !== b) throw Error(formatProdErrorMessage(190));
			}
			if (3 !== a.tag) throw Error(formatProdErrorMessage(188));
			return a.stateNode.current === a ? fiber : alternate;
		}
		function findCurrentHostFiberImpl(node) {
			var tag = node.tag;
			if (5 === tag || 26 === tag || 27 === tag || 6 === tag) return node;
			for (node = node.child; null !== node;) {
				tag = findCurrentHostFiberImpl(node);
				if (null !== tag) return tag;
				node = node.sibling;
			}
			return null;
		}
		function findCurrentHostFiberWithNoPortalsImpl(node) {
			var tag = node.tag;
			if (5 === tag || 26 === tag || 27 === tag || 6 === tag) return node;
			for (node = node.child; null !== node;) {
				if (4 !== node.tag && (tag = findCurrentHostFiberWithNoPortalsImpl(node), null !== tag)) return tag;
				node = node.sibling;
			}
			return null;
		}
		function getIteratorFn$1(maybeIterable) {
			if (null === maybeIterable || "object" !== typeof maybeIterable) return null;
			maybeIterable = MAYBE_ITERATOR_SYMBOL$1 && maybeIterable[MAYBE_ITERATOR_SYMBOL$1] || maybeIterable["@@iterator"];
			return "function" === typeof maybeIterable ? maybeIterable : null;
		}
		function getComponentNameFromType(type) {
			if (null == type) return null;
			if ("function" === typeof type) return type.$$typeof === REACT_CLIENT_REFERENCE ? null : type.displayName || type.name || null;
			if ("string" === typeof type) return type;
			switch (type) {
				case REACT_FRAGMENT_TYPE$2: return "Fragment";
				case REACT_PROFILER_TYPE$1: return "Profiler";
				case REACT_STRICT_MODE_TYPE$1: return "StrictMode";
				case REACT_SUSPENSE_TYPE$1: return "Suspense";
				case REACT_SUSPENSE_LIST_TYPE: return "SuspenseList";
				case REACT_ACTIVITY_TYPE$1: return "Activity";
			}
			if ("object" === typeof type) switch (type.$$typeof) {
				case REACT_PORTAL_TYPE$1: return "Portal";
				case REACT_CONTEXT_TYPE$1: return (type.displayName || "Context") + ".Provider";
				case REACT_CONSUMER_TYPE$1: return (type._context.displayName || "Context") + ".Consumer";
				case REACT_FORWARD_REF_TYPE$1:
					var innerType = type.render;
					type = type.displayName;
					type || (type = innerType.displayName || innerType.name || "", type = "" !== type ? "ForwardRef(" + type + ")" : "ForwardRef");
					return type;
				case REACT_MEMO_TYPE$1: return innerType = type.displayName || null, null !== innerType ? innerType : getComponentNameFromType(type.type) || "Memo";
				case REACT_LAZY_TYPE$1:
					innerType = type._payload;
					type = type._init;
					try {
						return getComponentNameFromType(type(innerType));
					} catch (x) {}
			}
			return null;
		}
		function createCursor(defaultValue) {
			return { current: defaultValue };
		}
		function pop$1(cursor) {
			0 > index$jscomp$0 || (cursor.current = valueStack[index$jscomp$0], valueStack[index$jscomp$0] = null, index$jscomp$0--);
		}
		function push$2(cursor, value) {
			index$jscomp$0++;
			valueStack[index$jscomp$0] = cursor.current;
			cursor.current = value;
		}
		function clz32Fallback(x) {
			x >>>= 0;
			return 0 === x ? 32 : 31 - (log$1(x) / LN2 | 0) | 0;
		}
		function getHighestPriorityLanes(lanes) {
			var pendingSyncLanes = lanes & 42;
			if (0 !== pendingSyncLanes) return pendingSyncLanes;
			switch (lanes & -lanes) {
				case 1: return 1;
				case 2: return 2;
				case 4: return 4;
				case 8: return 8;
				case 16: return 16;
				case 32: return 32;
				case 64: return 64;
				case 128: return 128;
				case 256:
				case 512:
				case 1024:
				case 2048:
				case 4096:
				case 8192:
				case 16384:
				case 32768:
				case 65536:
				case 131072:
				case 262144:
				case 524288:
				case 1048576:
				case 2097152: return lanes & 4194048;
				case 4194304:
				case 8388608:
				case 16777216:
				case 33554432: return lanes & 62914560;
				case 67108864: return 67108864;
				case 134217728: return 134217728;
				case 268435456: return 268435456;
				case 536870912: return 536870912;
				case 1073741824: return 0;
				default: return lanes;
			}
		}
		function getNextLanes(root, wipLanes, rootHasPendingCommit) {
			var pendingLanes = root.pendingLanes;
			if (0 === pendingLanes) return 0;
			var nextLanes = 0, suspendedLanes = root.suspendedLanes, pingedLanes = root.pingedLanes;
			root = root.warmLanes;
			var nonIdlePendingLanes = pendingLanes & 134217727;
			0 !== nonIdlePendingLanes ? (pendingLanes = nonIdlePendingLanes & ~suspendedLanes, 0 !== pendingLanes ? nextLanes = getHighestPriorityLanes(pendingLanes) : (pingedLanes &= nonIdlePendingLanes, 0 !== pingedLanes ? nextLanes = getHighestPriorityLanes(pingedLanes) : rootHasPendingCommit || (rootHasPendingCommit = nonIdlePendingLanes & ~root, 0 !== rootHasPendingCommit && (nextLanes = getHighestPriorityLanes(rootHasPendingCommit))))) : (nonIdlePendingLanes = pendingLanes & ~suspendedLanes, 0 !== nonIdlePendingLanes ? nextLanes = getHighestPriorityLanes(nonIdlePendingLanes) : 0 !== pingedLanes ? nextLanes = getHighestPriorityLanes(pingedLanes) : rootHasPendingCommit || (rootHasPendingCommit = pendingLanes & ~root, 0 !== rootHasPendingCommit && (nextLanes = getHighestPriorityLanes(rootHasPendingCommit))));
			return 0 === nextLanes ? 0 : 0 !== wipLanes && wipLanes !== nextLanes && 0 === (wipLanes & suspendedLanes) && (suspendedLanes = nextLanes & -nextLanes, rootHasPendingCommit = wipLanes & -wipLanes, suspendedLanes >= rootHasPendingCommit || 32 === suspendedLanes && 0 !== (rootHasPendingCommit & 4194048)) ? wipLanes : nextLanes;
		}
		function checkIfRootIsPrerendering(root, renderLanes$1) {
			return 0 === (root.pendingLanes & ~(root.suspendedLanes & ~root.pingedLanes) & renderLanes$1);
		}
		function computeExpirationTime(lane, currentTime) {
			switch (lane) {
				case 1:
				case 2:
				case 4:
				case 8:
				case 64: return currentTime + 250;
				case 16:
				case 32:
				case 128:
				case 256:
				case 512:
				case 1024:
				case 2048:
				case 4096:
				case 8192:
				case 16384:
				case 32768:
				case 65536:
				case 131072:
				case 262144:
				case 524288:
				case 1048576:
				case 2097152: return currentTime + 5e3;
				case 4194304:
				case 8388608:
				case 16777216:
				case 33554432: return -1;
				case 67108864:
				case 134217728:
				case 268435456:
				case 536870912:
				case 1073741824: return -1;
				default: return -1;
			}
		}
		function claimNextTransitionLane() {
			var lane = nextTransitionLane;
			nextTransitionLane <<= 1;
			0 === (nextTransitionLane & 4194048) && (nextTransitionLane = 256);
			return lane;
		}
		function claimNextRetryLane() {
			var lane = nextRetryLane;
			nextRetryLane <<= 1;
			0 === (nextRetryLane & 62914560) && (nextRetryLane = 4194304);
			return lane;
		}
		function createLaneMap(initial) {
			for (var laneMap = [], i = 0; 31 > i; i++) laneMap.push(initial);
			return laneMap;
		}
		function markRootUpdated$1(root, updateLane) {
			root.pendingLanes |= updateLane;
			268435456 !== updateLane && (root.suspendedLanes = 0, root.pingedLanes = 0, root.warmLanes = 0);
		}
		function markRootFinished(root, finishedLanes, remainingLanes, spawnedLane, updatedLanes, suspendedRetryLanes) {
			var previouslyPendingLanes = root.pendingLanes;
			root.pendingLanes = remainingLanes;
			root.suspendedLanes = 0;
			root.pingedLanes = 0;
			root.warmLanes = 0;
			root.expiredLanes &= remainingLanes;
			root.entangledLanes &= remainingLanes;
			root.errorRecoveryDisabledLanes &= remainingLanes;
			root.shellSuspendCounter = 0;
			var entanglements = root.entanglements, expirationTimes = root.expirationTimes, hiddenUpdates = root.hiddenUpdates;
			for (remainingLanes = previouslyPendingLanes & ~remainingLanes; 0 < remainingLanes;) {
				var index$5 = 31 - clz32(remainingLanes), lane = 1 << index$5;
				entanglements[index$5] = 0;
				expirationTimes[index$5] = -1;
				var hiddenUpdatesForLane = hiddenUpdates[index$5];
				if (null !== hiddenUpdatesForLane) for (hiddenUpdates[index$5] = null, index$5 = 0; index$5 < hiddenUpdatesForLane.length; index$5++) {
					var update = hiddenUpdatesForLane[index$5];
					null !== update && (update.lane &= -536870913);
				}
				remainingLanes &= ~lane;
			}
			0 !== spawnedLane && markSpawnedDeferredLane(root, spawnedLane, 0);
			0 !== suspendedRetryLanes && 0 === updatedLanes && 0 !== root.tag && (root.suspendedLanes |= suspendedRetryLanes & ~(previouslyPendingLanes & ~finishedLanes));
		}
		function markSpawnedDeferredLane(root, spawnedLane, entangledLanes) {
			root.pendingLanes |= spawnedLane;
			root.suspendedLanes &= ~spawnedLane;
			var spawnedLaneIndex = 31 - clz32(spawnedLane);
			root.entangledLanes |= spawnedLane;
			root.entanglements[spawnedLaneIndex] = root.entanglements[spawnedLaneIndex] | 1073741824 | entangledLanes & 4194090;
		}
		function markRootEntangled(root, entangledLanes) {
			var rootEntangledLanes = root.entangledLanes |= entangledLanes;
			for (root = root.entanglements; rootEntangledLanes;) {
				var index$6 = 31 - clz32(rootEntangledLanes), lane = 1 << index$6;
				lane & entangledLanes | root[index$6] & entangledLanes && (root[index$6] |= entangledLanes);
				rootEntangledLanes &= ~lane;
			}
		}
		function getBumpedLaneForHydrationByLane(lane) {
			switch (lane) {
				case 2:
					lane = 1;
					break;
				case 8:
					lane = 4;
					break;
				case 32:
					lane = 16;
					break;
				case 256:
				case 512:
				case 1024:
				case 2048:
				case 4096:
				case 8192:
				case 16384:
				case 32768:
				case 65536:
				case 131072:
				case 262144:
				case 524288:
				case 1048576:
				case 2097152:
				case 4194304:
				case 8388608:
				case 16777216:
				case 33554432:
					lane = 128;
					break;
				case 268435456:
					lane = 134217728;
					break;
				default: lane = 0;
			}
			return lane;
		}
		function lanesToEventPriority(lanes) {
			lanes &= -lanes;
			return 2 < lanes ? 8 < lanes ? 0 !== (lanes & 134217727) ? 32 : 268435456 : 8 : 2;
		}
		function setIsStrictModeForDevtools(newIsStrictMode) {
			"function" === typeof log && unstable_setDisableYieldValue(newIsStrictMode);
			if (injectedHook && "function" === typeof injectedHook.setStrictMode) try {
				injectedHook.setStrictMode(rendererID, newIsStrictMode);
			} catch (err) {}
		}
		function describeBuiltInComponentFrame(name) {
			if (void 0 === prefix) try {
				throw Error();
			} catch (x) {
				var match = x.stack.trim().match(/\n( *(at )?)/);
				prefix = match && match[1] || "";
				suffix = -1 < x.stack.indexOf("\n    at") ? " (<anonymous>)" : -1 < x.stack.indexOf("@") ? "@unknown:0:0" : "";
			}
			return "\n" + prefix + name + suffix;
		}
		function describeNativeComponentFrame(fn, construct) {
			if (!fn || reentry) return "";
			reentry = !0;
			var previousPrepareStackTrace = Error.prepareStackTrace;
			Error.prepareStackTrace = void 0;
			try {
				var RunInRootFrame = { DetermineComponentFrameRoot: function() {
					try {
						if (construct) {
							var Fake = function() {
								throw Error();
							};
							Object.defineProperty(Fake.prototype, "props", { set: function() {
								throw Error();
							} });
							if ("object" === typeof Reflect && Reflect.construct) {
								try {
									Reflect.construct(Fake, []);
								} catch (x) {
									var control = x;
								}
								Reflect.construct(fn, [], Fake);
							} else {
								try {
									Fake.call();
								} catch (x$8) {
									control = x$8;
								}
								fn.call(Fake.prototype);
							}
						} else {
							try {
								throw Error();
							} catch (x$9) {
								control = x$9;
							}
							(Fake = fn()) && "function" === typeof Fake.catch && Fake.catch(function() {});
						}
					} catch (sample) {
						if (sample && control && "string" === typeof sample.stack) return [sample.stack, control.stack];
					}
					return [null, null];
				} };
				RunInRootFrame.DetermineComponentFrameRoot.displayName = "DetermineComponentFrameRoot";
				var namePropDescriptor = Object.getOwnPropertyDescriptor(RunInRootFrame.DetermineComponentFrameRoot, "name");
				namePropDescriptor && namePropDescriptor.configurable && Object.defineProperty(RunInRootFrame.DetermineComponentFrameRoot, "name", { value: "DetermineComponentFrameRoot" });
				var _RunInRootFrame$Deter = RunInRootFrame.DetermineComponentFrameRoot(), sampleStack = _RunInRootFrame$Deter[0], controlStack = _RunInRootFrame$Deter[1];
				if (sampleStack && controlStack) {
					var sampleLines = sampleStack.split("\n"), controlLines = controlStack.split("\n");
					for (namePropDescriptor = RunInRootFrame = 0; RunInRootFrame < sampleLines.length && !sampleLines[RunInRootFrame].includes("DetermineComponentFrameRoot");) RunInRootFrame++;
					for (; namePropDescriptor < controlLines.length && !controlLines[namePropDescriptor].includes("DetermineComponentFrameRoot");) namePropDescriptor++;
					if (RunInRootFrame === sampleLines.length || namePropDescriptor === controlLines.length) for (RunInRootFrame = sampleLines.length - 1, namePropDescriptor = controlLines.length - 1; 1 <= RunInRootFrame && 0 <= namePropDescriptor && sampleLines[RunInRootFrame] !== controlLines[namePropDescriptor];) namePropDescriptor--;
					for (; 1 <= RunInRootFrame && 0 <= namePropDescriptor; RunInRootFrame--, namePropDescriptor--) if (sampleLines[RunInRootFrame] !== controlLines[namePropDescriptor]) {
						if (1 !== RunInRootFrame || 1 !== namePropDescriptor) do
							if (RunInRootFrame--, namePropDescriptor--, 0 > namePropDescriptor || sampleLines[RunInRootFrame] !== controlLines[namePropDescriptor]) {
								var frame = "\n" + sampleLines[RunInRootFrame].replace(" at new ", " at ");
								fn.displayName && frame.includes("<anonymous>") && (frame = frame.replace("<anonymous>", fn.displayName));
								return frame;
							}
						while (1 <= RunInRootFrame && 0 <= namePropDescriptor);
						break;
					}
				}
			} finally {
				reentry = !1, Error.prepareStackTrace = previousPrepareStackTrace;
			}
			return (previousPrepareStackTrace = fn ? fn.displayName || fn.name : "") ? describeBuiltInComponentFrame(previousPrepareStackTrace) : "";
		}
		function describeFiber(fiber) {
			switch (fiber.tag) {
				case 26:
				case 27:
				case 5: return describeBuiltInComponentFrame(fiber.type);
				case 16: return describeBuiltInComponentFrame("Lazy");
				case 13: return describeBuiltInComponentFrame("Suspense");
				case 19: return describeBuiltInComponentFrame("SuspenseList");
				case 0:
				case 15: return describeNativeComponentFrame(fiber.type, !1);
				case 11: return describeNativeComponentFrame(fiber.type.render, !1);
				case 1: return describeNativeComponentFrame(fiber.type, !0);
				case 31: return describeBuiltInComponentFrame("Activity");
				default: return "";
			}
		}
		function getStackByFiberInDevAndProd(workInProgress$1) {
			try {
				var info = "";
				do
					info += describeFiber(workInProgress$1), workInProgress$1 = workInProgress$1.return;
				while (workInProgress$1);
				return info;
			} catch (x) {
				return "\nError generating stack: " + x.message + "\n" + x.stack;
			}
		}
		function createCapturedValueAtFiber(value, source) {
			if ("object" === typeof value && null !== value) {
				var existing = CapturedStacks.get(value);
				if (void 0 !== existing) return existing;
				source = {
					value,
					source,
					stack: getStackByFiberInDevAndProd(source)
				};
				CapturedStacks.set(value, source);
				return source;
			}
			return {
				value,
				source,
				stack: getStackByFiberInDevAndProd(source)
			};
		}
		function pushTreeFork(workInProgress$1, totalChildren) {
			forkStack[forkStackIndex++] = treeForkCount;
			forkStack[forkStackIndex++] = treeForkProvider;
			treeForkProvider = workInProgress$1;
			treeForkCount = totalChildren;
		}
		function pushTreeId(workInProgress$1, totalChildren, index) {
			idStack[idStackIndex++] = treeContextId;
			idStack[idStackIndex++] = treeContextOverflow;
			idStack[idStackIndex++] = treeContextProvider;
			treeContextProvider = workInProgress$1;
			var baseIdWithLeadingBit = treeContextId;
			workInProgress$1 = treeContextOverflow;
			var baseLength = 32 - clz32(baseIdWithLeadingBit) - 1;
			baseIdWithLeadingBit &= ~(1 << baseLength);
			index += 1;
			var length = 32 - clz32(totalChildren) + baseLength;
			if (30 < length) {
				var numberOfOverflowBits = baseLength - baseLength % 5;
				length = (baseIdWithLeadingBit & (1 << numberOfOverflowBits) - 1).toString(32);
				baseIdWithLeadingBit >>= numberOfOverflowBits;
				baseLength -= numberOfOverflowBits;
				treeContextId = 1 << 32 - clz32(totalChildren) + baseLength | index << baseLength | baseIdWithLeadingBit;
				treeContextOverflow = length + workInProgress$1;
			} else treeContextId = 1 << length | index << baseLength | baseIdWithLeadingBit, treeContextOverflow = workInProgress$1;
		}
		function pushMaterializedTreeId(workInProgress$1) {
			null !== workInProgress$1.return && (pushTreeFork(workInProgress$1, 1), pushTreeId(workInProgress$1, 1, 0));
		}
		function popTreeContext(workInProgress$1) {
			for (; workInProgress$1 === treeForkProvider;) treeForkProvider = forkStack[--forkStackIndex], forkStack[forkStackIndex] = null, treeForkCount = forkStack[--forkStackIndex], forkStack[forkStackIndex] = null;
			for (; workInProgress$1 === treeContextProvider;) treeContextProvider = idStack[--idStackIndex], idStack[idStackIndex] = null, treeContextOverflow = idStack[--idStackIndex], idStack[idStackIndex] = null, treeContextId = idStack[--idStackIndex], idStack[idStackIndex] = null;
		}
		function pushHostContainer(fiber, nextRootInstance) {
			push$2(rootInstanceStackCursor, nextRootInstance);
			push$2(contextFiberStackCursor, fiber);
			push$2(contextStackCursor, null);
			fiber = getRootHostContext(nextRootInstance);
			pop$1(contextStackCursor);
			push$2(contextStackCursor, fiber);
		}
		function popHostContainer() {
			pop$1(contextStackCursor);
			pop$1(contextFiberStackCursor);
			pop$1(rootInstanceStackCursor);
		}
		function pushHostContext(fiber) {
			null !== fiber.memoizedState && push$2(hostTransitionProviderCursor, fiber);
			var context = contextStackCursor.current, nextContext = getChildHostContext(context, fiber.type);
			context !== nextContext && (push$2(contextFiberStackCursor, fiber), push$2(contextStackCursor, nextContext));
		}
		function popHostContext(fiber) {
			contextFiberStackCursor.current === fiber && (pop$1(contextStackCursor), pop$1(contextFiberStackCursor));
			hostTransitionProviderCursor.current === fiber && (pop$1(hostTransitionProviderCursor), isPrimaryRenderer ? HostTransitionContext._currentValue = NotPendingTransition : HostTransitionContext._currentValue2 = NotPendingTransition);
		}
		function throwOnHydrationMismatch(fiber) {
			queueHydrationError(createCapturedValueAtFiber(Error(formatProdErrorMessage(418, "")), fiber));
			throw HydrationMismatchException;
		}
		function prepareToHydrateHostInstance(fiber, hostContext) {
			if (!supportsHydration) throw Error(formatProdErrorMessage(175));
			hydrateInstance(fiber.stateNode, fiber.type, fiber.memoizedProps, hostContext, fiber) || throwOnHydrationMismatch(fiber);
		}
		function popToNextHostParent(fiber) {
			for (hydrationParentFiber = fiber.return; hydrationParentFiber;) switch (hydrationParentFiber.tag) {
				case 5:
				case 13:
					rootOrSingletonContext = !1;
					return;
				case 27:
				case 3:
					rootOrSingletonContext = !0;
					return;
				default: hydrationParentFiber = hydrationParentFiber.return;
			}
		}
		function popHydrationState(fiber) {
			if (!supportsHydration || fiber !== hydrationParentFiber) return !1;
			if (!isHydrating) return popToNextHostParent(fiber), isHydrating = !0, !1;
			var tag = fiber.tag;
			supportsSingletons ? 3 !== tag && 27 !== tag && (5 !== tag || shouldDeleteUnhydratedTailInstances(fiber.type) && !shouldSetTextContent(fiber.type, fiber.memoizedProps)) && nextHydratableInstance && throwOnHydrationMismatch(fiber) : 3 !== tag && (5 !== tag || shouldDeleteUnhydratedTailInstances(fiber.type) && !shouldSetTextContent(fiber.type, fiber.memoizedProps)) && nextHydratableInstance && throwOnHydrationMismatch(fiber);
			popToNextHostParent(fiber);
			if (13 === tag) {
				if (!supportsHydration) throw Error(formatProdErrorMessage(316));
				fiber = fiber.memoizedState;
				fiber = null !== fiber ? fiber.dehydrated : null;
				if (!fiber) throw Error(formatProdErrorMessage(317));
				nextHydratableInstance = getNextHydratableInstanceAfterSuspenseInstance(fiber);
			} else nextHydratableInstance = supportsSingletons && 27 === tag ? getNextHydratableSiblingAfterSingleton(fiber.type, nextHydratableInstance) : hydrationParentFiber ? getNextHydratableSibling(fiber.stateNode) : null;
			return !0;
		}
		function resetHydrationState() {
			supportsHydration && (nextHydratableInstance = hydrationParentFiber = null, isHydrating = !1);
		}
		function upgradeHydrationErrorsToRecoverable() {
			var queuedErrors = hydrationErrors;
			null !== queuedErrors && (null === workInProgressRootRecoverableErrors ? workInProgressRootRecoverableErrors = queuedErrors : workInProgressRootRecoverableErrors.push.apply(workInProgressRootRecoverableErrors, queuedErrors), hydrationErrors = null);
			return queuedErrors;
		}
		function queueHydrationError(error) {
			null === hydrationErrors ? hydrationErrors = [error] : hydrationErrors.push(error);
		}
		function is(x, y) {
			return x === y && (0 !== x || 1 / x === 1 / y) || x !== x && y !== y;
		}
		function pushProvider(providerFiber, context, nextValue) {
			isPrimaryRenderer ? (push$2(valueCursor, context._currentValue), context._currentValue = nextValue) : (push$2(valueCursor, context._currentValue2), context._currentValue2 = nextValue);
		}
		function popProvider(context) {
			var currentValue = valueCursor.current;
			isPrimaryRenderer ? context._currentValue = currentValue : context._currentValue2 = currentValue;
			pop$1(valueCursor);
		}
		function scheduleContextWorkOnParentPath(parent, renderLanes$1, propagationRoot) {
			for (; null !== parent;) {
				var alternate = parent.alternate;
				(parent.childLanes & renderLanes$1) !== renderLanes$1 ? (parent.childLanes |= renderLanes$1, null !== alternate && (alternate.childLanes |= renderLanes$1)) : null !== alternate && (alternate.childLanes & renderLanes$1) !== renderLanes$1 && (alternate.childLanes |= renderLanes$1);
				if (parent === propagationRoot) break;
				parent = parent.return;
			}
		}
		function propagateContextChanges(workInProgress$1, contexts, renderLanes$1, forcePropagateEntireTree) {
			var fiber = workInProgress$1.child;
			null !== fiber && (fiber.return = workInProgress$1);
			for (; null !== fiber;) {
				var list = fiber.dependencies;
				if (null !== list) {
					var nextFiber = fiber.child;
					list = list.firstContext;
					a: for (; null !== list;) {
						var dependency = list;
						list = fiber;
						for (var i = 0; i < contexts.length; i++) if (dependency.context === contexts[i]) {
							list.lanes |= renderLanes$1;
							dependency = list.alternate;
							null !== dependency && (dependency.lanes |= renderLanes$1);
							scheduleContextWorkOnParentPath(list.return, renderLanes$1, workInProgress$1);
							forcePropagateEntireTree || (nextFiber = null);
							break a;
						}
						list = dependency.next;
					}
				} else if (18 === fiber.tag) {
					nextFiber = fiber.return;
					if (null === nextFiber) throw Error(formatProdErrorMessage(341));
					nextFiber.lanes |= renderLanes$1;
					list = nextFiber.alternate;
					null !== list && (list.lanes |= renderLanes$1);
					scheduleContextWorkOnParentPath(nextFiber, renderLanes$1, workInProgress$1);
					nextFiber = null;
				} else nextFiber = fiber.child;
				if (null !== nextFiber) nextFiber.return = fiber;
				else for (nextFiber = fiber; null !== nextFiber;) {
					if (nextFiber === workInProgress$1) {
						nextFiber = null;
						break;
					}
					fiber = nextFiber.sibling;
					if (null !== fiber) {
						fiber.return = nextFiber.return;
						nextFiber = fiber;
						break;
					}
					nextFiber = nextFiber.return;
				}
				fiber = nextFiber;
			}
		}
		function propagateParentContextChanges(current, workInProgress$1, renderLanes$1, forcePropagateEntireTree) {
			current = null;
			for (var parent = workInProgress$1, isInsidePropagationBailout = !1; null !== parent;) {
				if (!isInsidePropagationBailout) {
					if (0 !== (parent.flags & 524288)) isInsidePropagationBailout = !0;
					else if (0 !== (parent.flags & 262144)) break;
				}
				if (10 === parent.tag) {
					var currentParent = parent.alternate;
					if (null === currentParent) throw Error(formatProdErrorMessage(387));
					currentParent = currentParent.memoizedProps;
					if (null !== currentParent) {
						var context = parent.type;
						objectIs(parent.pendingProps.value, currentParent.value) || (null !== current ? current.push(context) : current = [context]);
					}
				} else if (parent === hostTransitionProviderCursor.current) {
					currentParent = parent.alternate;
					if (null === currentParent) throw Error(formatProdErrorMessage(387));
					currentParent.memoizedState.memoizedState !== parent.memoizedState.memoizedState && (null !== current ? current.push(HostTransitionContext) : current = [HostTransitionContext]);
				}
				parent = parent.return;
			}
			null !== current && propagateContextChanges(workInProgress$1, current, renderLanes$1, forcePropagateEntireTree);
			workInProgress$1.flags |= 262144;
		}
		function checkIfContextChanged(currentDependencies) {
			for (currentDependencies = currentDependencies.firstContext; null !== currentDependencies;) {
				var context = currentDependencies.context;
				if (!objectIs(isPrimaryRenderer ? context._currentValue : context._currentValue2, currentDependencies.memoizedValue)) return !0;
				currentDependencies = currentDependencies.next;
			}
			return !1;
		}
		function prepareToReadContext(workInProgress$1) {
			currentlyRenderingFiber$1 = workInProgress$1;
			lastContextDependency = null;
			workInProgress$1 = workInProgress$1.dependencies;
			null !== workInProgress$1 && (workInProgress$1.firstContext = null);
		}
		function readContext(context) {
			return readContextForConsumer(currentlyRenderingFiber$1, context);
		}
		function readContextDuringReconciliation(consumer, context) {
			null === currentlyRenderingFiber$1 && prepareToReadContext(consumer);
			return readContextForConsumer(consumer, context);
		}
		function readContextForConsumer(consumer, context) {
			var value = isPrimaryRenderer ? context._currentValue : context._currentValue2;
			context = {
				context,
				memoizedValue: value,
				next: null
			};
			if (null === lastContextDependency) {
				if (null === consumer) throw Error(formatProdErrorMessage(308));
				lastContextDependency = context;
				consumer.dependencies = {
					lanes: 0,
					firstContext: context
				};
				consumer.flags |= 524288;
			} else lastContextDependency = lastContextDependency.next = context;
			return value;
		}
		function createCache() {
			return {
				controller: new AbortControllerLocal(),
				data: /* @__PURE__ */ new Map(),
				refCount: 0
			};
		}
		function releaseCache(cache$4) {
			cache$4.refCount--;
			0 === cache$4.refCount && scheduleCallback$2(NormalPriority, function() {
				cache$4.controller.abort();
			});
		}
		function ensureRootIsScheduled(root) {
			root !== lastScheduledRoot && null === root.next && (null === lastScheduledRoot ? firstScheduledRoot = lastScheduledRoot = root : lastScheduledRoot = lastScheduledRoot.next = root);
			mightHavePendingSyncWork = !0;
			didScheduleMicrotask || (didScheduleMicrotask = !0, scheduleImmediateRootScheduleTask());
		}
		function flushSyncWorkAcrossRoots_impl(syncTransitionLanes, onlyLegacy) {
			if (!isFlushingWork && mightHavePendingSyncWork) {
				isFlushingWork = !0;
				do {
					var didPerformSomeWork = !1;
					for (var root = firstScheduledRoot; null !== root;) {
						if (!onlyLegacy) if (0 !== syncTransitionLanes) {
							var pendingLanes = root.pendingLanes;
							if (0 === pendingLanes) var JSCompiler_inline_result = 0;
							else {
								var suspendedLanes = root.suspendedLanes, pingedLanes = root.pingedLanes;
								JSCompiler_inline_result = (1 << 31 - clz32(42 | syncTransitionLanes) + 1) - 1;
								JSCompiler_inline_result &= pendingLanes & ~(suspendedLanes & ~pingedLanes);
								JSCompiler_inline_result = JSCompiler_inline_result & 201326741 ? JSCompiler_inline_result & 201326741 | 1 : JSCompiler_inline_result ? JSCompiler_inline_result | 2 : 0;
							}
							0 !== JSCompiler_inline_result && (didPerformSomeWork = !0, performSyncWorkOnRoot(root, JSCompiler_inline_result));
						} else JSCompiler_inline_result = workInProgressRootRenderLanes, JSCompiler_inline_result = getNextLanes(root, root === workInProgressRoot ? JSCompiler_inline_result : 0, null !== root.cancelPendingCommit || root.timeoutHandle !== noTimeout), 0 === (JSCompiler_inline_result & 3) || checkIfRootIsPrerendering(root, JSCompiler_inline_result) || (didPerformSomeWork = !0, performSyncWorkOnRoot(root, JSCompiler_inline_result));
						root = root.next;
					}
				} while (didPerformSomeWork);
				isFlushingWork = !1;
			}
		}
		function processRootScheduleInImmediateTask() {
			processRootScheduleInMicrotask();
		}
		function processRootScheduleInMicrotask() {
			mightHavePendingSyncWork = didScheduleMicrotask = !1;
			var syncTransitionLanes = 0;
			0 !== currentEventTransitionLane && (shouldAttemptEagerTransition() && (syncTransitionLanes = currentEventTransitionLane), currentEventTransitionLane = 0);
			for (var currentTime = now(), prev = null, root = firstScheduledRoot; null !== root;) {
				var next = root.next, nextLanes = scheduleTaskForRootDuringMicrotask(root, currentTime);
				if (0 === nextLanes) root.next = null, null === prev ? firstScheduledRoot = next : prev.next = next, null === next && (lastScheduledRoot = prev);
				else if (prev = root, 0 !== syncTransitionLanes || 0 !== (nextLanes & 3)) mightHavePendingSyncWork = !0;
				root = next;
			}
			flushSyncWorkAcrossRoots_impl(syncTransitionLanes, !1);
		}
		function scheduleTaskForRootDuringMicrotask(root, currentTime) {
			for (var suspendedLanes = root.suspendedLanes, pingedLanes = root.pingedLanes, expirationTimes = root.expirationTimes, lanes = root.pendingLanes & -62914561; 0 < lanes;) {
				var index$3 = 31 - clz32(lanes), lane = 1 << index$3, expirationTime = expirationTimes[index$3];
				if (-1 === expirationTime) {
					if (0 === (lane & suspendedLanes) || 0 !== (lane & pingedLanes)) expirationTimes[index$3] = computeExpirationTime(lane, currentTime);
				} else expirationTime <= currentTime && (root.expiredLanes |= lane);
				lanes &= ~lane;
			}
			currentTime = workInProgressRoot;
			suspendedLanes = workInProgressRootRenderLanes;
			suspendedLanes = getNextLanes(root, root === currentTime ? suspendedLanes : 0, null !== root.cancelPendingCommit || root.timeoutHandle !== noTimeout);
			pingedLanes = root.callbackNode;
			if (0 === suspendedLanes || root === currentTime && (2 === workInProgressSuspendedReason || 9 === workInProgressSuspendedReason) || null !== root.cancelPendingCommit) return null !== pingedLanes && null !== pingedLanes && cancelCallback$1(pingedLanes), root.callbackNode = null, root.callbackPriority = 0;
			if (0 === (suspendedLanes & 3) || checkIfRootIsPrerendering(root, suspendedLanes)) {
				currentTime = suspendedLanes & -suspendedLanes;
				if (currentTime === root.callbackPriority) return currentTime;
				null !== pingedLanes && cancelCallback$1(pingedLanes);
				switch (lanesToEventPriority(suspendedLanes)) {
					case 2:
					case 8:
						suspendedLanes = UserBlockingPriority;
						break;
					case 32:
						suspendedLanes = NormalPriority$1;
						break;
					case 268435456:
						suspendedLanes = IdlePriority;
						break;
					default: suspendedLanes = NormalPriority$1;
				}
				pingedLanes = performWorkOnRootViaSchedulerTask.bind(null, root);
				suspendedLanes = scheduleCallback$3(suspendedLanes, pingedLanes);
				root.callbackPriority = currentTime;
				root.callbackNode = suspendedLanes;
				return currentTime;
			}
			null !== pingedLanes && null !== pingedLanes && cancelCallback$1(pingedLanes);
			root.callbackPriority = 2;
			root.callbackNode = null;
			return 2;
		}
		function performWorkOnRootViaSchedulerTask(root, didTimeout) {
			if (0 !== pendingEffectsStatus && 5 !== pendingEffectsStatus) return root.callbackNode = null, root.callbackPriority = 0, null;
			var originalCallbackNode = root.callbackNode;
			if (flushPendingEffects(!0) && root.callbackNode !== originalCallbackNode) return null;
			var workInProgressRootRenderLanes$jscomp$0 = workInProgressRootRenderLanes;
			workInProgressRootRenderLanes$jscomp$0 = getNextLanes(root, root === workInProgressRoot ? workInProgressRootRenderLanes$jscomp$0 : 0, null !== root.cancelPendingCommit || root.timeoutHandle !== noTimeout);
			if (0 === workInProgressRootRenderLanes$jscomp$0) return null;
			performWorkOnRoot(root, workInProgressRootRenderLanes$jscomp$0, didTimeout);
			scheduleTaskForRootDuringMicrotask(root, now());
			return null != root.callbackNode && root.callbackNode === originalCallbackNode ? performWorkOnRootViaSchedulerTask.bind(null, root) : null;
		}
		function performSyncWorkOnRoot(root, lanes) {
			if (flushPendingEffects()) return null;
			performWorkOnRoot(root, lanes, !0);
		}
		function scheduleImmediateRootScheduleTask() {
			supportsMicrotasks ? scheduleMicrotask(function() {
				0 !== (executionContext & 6) ? scheduleCallback$3(ImmediatePriority, processRootScheduleInImmediateTask) : processRootScheduleInMicrotask();
			}) : scheduleCallback$3(ImmediatePriority, processRootScheduleInImmediateTask);
		}
		function requestTransitionLane() {
			0 === currentEventTransitionLane && (currentEventTransitionLane = claimNextTransitionLane());
			return currentEventTransitionLane;
		}
		function entangleAsyncAction(transition, thenable) {
			if (null === currentEntangledListeners) {
				var entangledListeners = currentEntangledListeners = [];
				currentEntangledPendingCount = 0;
				currentEntangledLane = requestTransitionLane();
				currentEntangledActionThenable = {
					status: "pending",
					value: void 0,
					then: function(resolve$1) {
						entangledListeners.push(resolve$1);
					}
				};
			}
			currentEntangledPendingCount++;
			thenable.then(pingEngtangledActionScope, pingEngtangledActionScope);
			return thenable;
		}
		function pingEngtangledActionScope() {
			if (0 === --currentEntangledPendingCount && null !== currentEntangledListeners) {
				null !== currentEntangledActionThenable && (currentEntangledActionThenable.status = "fulfilled");
				var listeners = currentEntangledListeners;
				currentEntangledListeners = null;
				currentEntangledLane = 0;
				currentEntangledActionThenable = null;
				for (var i = 0; i < listeners.length; i++) (0, listeners[i])();
			}
		}
		function chainThenableValue(thenable, result) {
			var listeners = [], thenableWithOverride = {
				status: "pending",
				value: null,
				reason: null,
				then: function(resolve$1) {
					listeners.push(resolve$1);
				}
			};
			thenable.then(function() {
				thenableWithOverride.status = "fulfilled";
				thenableWithOverride.value = result;
				for (var i = 0; i < listeners.length; i++) (0, listeners[i])(result);
			}, function(error) {
				thenableWithOverride.status = "rejected";
				thenableWithOverride.reason = error;
				for (error = 0; error < listeners.length; error++) (0, listeners[error])(void 0);
			});
			return thenableWithOverride;
		}
		function peekCacheFromPool() {
			var cacheResumedFromPreviousRender = resumedCache.current;
			return null !== cacheResumedFromPreviousRender ? cacheResumedFromPreviousRender : workInProgressRoot.pooledCache;
		}
		function pushTransition(offscreenWorkInProgress, prevCachePool) {
			null === prevCachePool ? push$2(resumedCache, resumedCache.current) : push$2(resumedCache, prevCachePool.pool);
		}
		function getSuspendedCache() {
			var cacheFromPool = peekCacheFromPool();
			return null === cacheFromPool ? null : {
				parent: isPrimaryRenderer ? CacheContext._currentValue : CacheContext._currentValue2,
				pool: cacheFromPool
			};
		}
		function shallowEqual(objA, objB) {
			if (objectIs(objA, objB)) return !0;
			if ("object" !== typeof objA || null === objA || "object" !== typeof objB || null === objB) return !1;
			var keysA = Object.keys(objA), keysB = Object.keys(objB);
			if (keysA.length !== keysB.length) return !1;
			for (keysB = 0; keysB < keysA.length; keysB++) {
				var currentKey = keysA[keysB];
				if (!hasOwnProperty$1.call(objB, currentKey) || !objectIs(objA[currentKey], objB[currentKey])) return !1;
			}
			return !0;
		}
		function isThenableResolved(thenable) {
			thenable = thenable.status;
			return "fulfilled" === thenable || "rejected" === thenable;
		}
		function noop$1$1() {}
		function trackUsedThenable(thenableState$2, thenable, index) {
			index = thenableState$2[index];
			void 0 === index ? thenableState$2.push(thenable) : index !== thenable && (thenable.then(noop$1$1, noop$1$1), thenable = index);
			switch (thenable.status) {
				case "fulfilled": return thenable.value;
				case "rejected": throw thenableState$2 = thenable.reason, checkIfUseWrappedInAsyncCatch(thenableState$2), thenableState$2;
				default:
					if ("string" === typeof thenable.status) thenable.then(noop$1$1, noop$1$1);
					else {
						thenableState$2 = workInProgressRoot;
						if (null !== thenableState$2 && 100 < thenableState$2.shellSuspendCounter) throw Error(formatProdErrorMessage(482));
						thenableState$2 = thenable;
						thenableState$2.status = "pending";
						thenableState$2.then(function(fulfilledValue) {
							if ("pending" === thenable.status) {
								var fulfilledThenable = thenable;
								fulfilledThenable.status = "fulfilled";
								fulfilledThenable.value = fulfilledValue;
							}
						}, function(error) {
							if ("pending" === thenable.status) {
								var rejectedThenable = thenable;
								rejectedThenable.status = "rejected";
								rejectedThenable.reason = error;
							}
						});
					}
					switch (thenable.status) {
						case "fulfilled": return thenable.value;
						case "rejected": throw thenableState$2 = thenable.reason, checkIfUseWrappedInAsyncCatch(thenableState$2), thenableState$2;
					}
					suspendedThenable = thenable;
					throw SuspenseException;
			}
		}
		function getSuspendedThenable() {
			if (null === suspendedThenable) throw Error(formatProdErrorMessage(459));
			var thenable = suspendedThenable;
			suspendedThenable = null;
			return thenable;
		}
		function checkIfUseWrappedInAsyncCatch(rejectedReason) {
			if (rejectedReason === SuspenseException || rejectedReason === SuspenseActionException) throw Error(formatProdErrorMessage(483));
		}
		function finishQueueingConcurrentUpdates() {
			for (var endIndex = concurrentQueuesIndex, i = concurrentlyUpdatedLanes = concurrentQueuesIndex = 0; i < endIndex;) {
				var fiber = concurrentQueues[i];
				concurrentQueues[i++] = null;
				var queue = concurrentQueues[i];
				concurrentQueues[i++] = null;
				var update = concurrentQueues[i];
				concurrentQueues[i++] = null;
				var lane = concurrentQueues[i];
				concurrentQueues[i++] = null;
				if (null !== queue && null !== update) {
					var pending = queue.pending;
					null === pending ? update.next = update : (update.next = pending.next, pending.next = update);
					queue.pending = update;
				}
				0 !== lane && markUpdateLaneFromFiberToRoot(fiber, update, lane);
			}
		}
		function enqueueUpdate$1(fiber, queue, update, lane) {
			concurrentQueues[concurrentQueuesIndex++] = fiber;
			concurrentQueues[concurrentQueuesIndex++] = queue;
			concurrentQueues[concurrentQueuesIndex++] = update;
			concurrentQueues[concurrentQueuesIndex++] = lane;
			concurrentlyUpdatedLanes |= lane;
			fiber.lanes |= lane;
			fiber = fiber.alternate;
			null !== fiber && (fiber.lanes |= lane);
		}
		function enqueueConcurrentHookUpdate(fiber, queue, update, lane) {
			enqueueUpdate$1(fiber, queue, update, lane);
			return getRootForUpdatedFiber(fiber);
		}
		function enqueueConcurrentRenderForLane(fiber, lane) {
			enqueueUpdate$1(fiber, null, null, lane);
			return getRootForUpdatedFiber(fiber);
		}
		function markUpdateLaneFromFiberToRoot(sourceFiber, update, lane) {
			sourceFiber.lanes |= lane;
			var alternate = sourceFiber.alternate;
			null !== alternate && (alternate.lanes |= lane);
			for (var isHidden$1 = !1, parent = sourceFiber.return; null !== parent;) parent.childLanes |= lane, alternate = parent.alternate, null !== alternate && (alternate.childLanes |= lane), 22 === parent.tag && (sourceFiber = parent.stateNode, null === sourceFiber || sourceFiber._visibility & 1 || (isHidden$1 = !0)), sourceFiber = parent, parent = parent.return;
			return 3 === sourceFiber.tag ? (parent = sourceFiber.stateNode, isHidden$1 && null !== update && (isHidden$1 = 31 - clz32(lane), sourceFiber = parent.hiddenUpdates, alternate = sourceFiber[isHidden$1], null === alternate ? sourceFiber[isHidden$1] = [update] : alternate.push(update), update.lane = lane | 536870912), parent) : null;
		}
		function getRootForUpdatedFiber(sourceFiber) {
			if (50 < nestedUpdateCount) throw nestedUpdateCount = 0, rootWithNestedUpdates = null, Error(formatProdErrorMessage(185));
			for (var parent = sourceFiber.return; null !== parent;) sourceFiber = parent, parent = sourceFiber.return;
			return 3 === sourceFiber.tag ? sourceFiber.stateNode : null;
		}
		function initializeUpdateQueue(fiber) {
			fiber.updateQueue = {
				baseState: fiber.memoizedState,
				firstBaseUpdate: null,
				lastBaseUpdate: null,
				shared: {
					pending: null,
					lanes: 0,
					hiddenCallbacks: null
				},
				callbacks: null
			};
		}
		function cloneUpdateQueue(current, workInProgress$1) {
			current = current.updateQueue;
			workInProgress$1.updateQueue === current && (workInProgress$1.updateQueue = {
				baseState: current.baseState,
				firstBaseUpdate: current.firstBaseUpdate,
				lastBaseUpdate: current.lastBaseUpdate,
				shared: current.shared,
				callbacks: null
			});
		}
		function createUpdate(lane) {
			return {
				lane,
				tag: 0,
				payload: null,
				callback: null,
				next: null
			};
		}
		function enqueueUpdate(fiber, update, lane) {
			var updateQueue = fiber.updateQueue;
			if (null === updateQueue) return null;
			updateQueue = updateQueue.shared;
			if (0 !== (executionContext & 2)) {
				var pending = updateQueue.pending;
				null === pending ? update.next = update : (update.next = pending.next, pending.next = update);
				updateQueue.pending = update;
				update = getRootForUpdatedFiber(fiber);
				markUpdateLaneFromFiberToRoot(fiber, null, lane);
				return update;
			}
			enqueueUpdate$1(fiber, updateQueue, update, lane);
			return getRootForUpdatedFiber(fiber);
		}
		function entangleTransitions(root, fiber, lane) {
			fiber = fiber.updateQueue;
			if (null !== fiber && (fiber = fiber.shared, 0 !== (lane & 4194048))) {
				var queueLanes = fiber.lanes;
				queueLanes &= root.pendingLanes;
				lane |= queueLanes;
				fiber.lanes = lane;
				markRootEntangled(root, lane);
			}
		}
		function enqueueCapturedUpdate(workInProgress$1, capturedUpdate) {
			var queue = workInProgress$1.updateQueue, current = workInProgress$1.alternate;
			if (null !== current && (current = current.updateQueue, queue === current)) {
				var newFirst = null, newLast = null;
				queue = queue.firstBaseUpdate;
				if (null !== queue) {
					do {
						var clone = {
							lane: queue.lane,
							tag: queue.tag,
							payload: queue.payload,
							callback: null,
							next: null
						};
						null === newLast ? newFirst = newLast = clone : newLast = newLast.next = clone;
						queue = queue.next;
					} while (null !== queue);
					null === newLast ? newFirst = newLast = capturedUpdate : newLast = newLast.next = capturedUpdate;
				} else newFirst = newLast = capturedUpdate;
				queue = {
					baseState: current.baseState,
					firstBaseUpdate: newFirst,
					lastBaseUpdate: newLast,
					shared: current.shared,
					callbacks: current.callbacks
				};
				workInProgress$1.updateQueue = queue;
				return;
			}
			workInProgress$1 = queue.lastBaseUpdate;
			null === workInProgress$1 ? queue.firstBaseUpdate = capturedUpdate : workInProgress$1.next = capturedUpdate;
			queue.lastBaseUpdate = capturedUpdate;
		}
		function suspendIfUpdateReadFromEntangledAsyncAction() {
			if (didReadFromEntangledAsyncAction) {
				var entangledActionThenable = currentEntangledActionThenable;
				if (null !== entangledActionThenable) throw entangledActionThenable;
			}
		}
		function processUpdateQueue(workInProgress$jscomp$0, props, instance$jscomp$0, renderLanes$1) {
			didReadFromEntangledAsyncAction = !1;
			var queue = workInProgress$jscomp$0.updateQueue;
			hasForceUpdate = !1;
			var firstBaseUpdate = queue.firstBaseUpdate, lastBaseUpdate = queue.lastBaseUpdate, pendingQueue = queue.shared.pending;
			if (null !== pendingQueue) {
				queue.shared.pending = null;
				var lastPendingUpdate = pendingQueue, firstPendingUpdate = lastPendingUpdate.next;
				lastPendingUpdate.next = null;
				null === lastBaseUpdate ? firstBaseUpdate = firstPendingUpdate : lastBaseUpdate.next = firstPendingUpdate;
				lastBaseUpdate = lastPendingUpdate;
				var current = workInProgress$jscomp$0.alternate;
				null !== current && (current = current.updateQueue, pendingQueue = current.lastBaseUpdate, pendingQueue !== lastBaseUpdate && (null === pendingQueue ? current.firstBaseUpdate = firstPendingUpdate : pendingQueue.next = firstPendingUpdate, current.lastBaseUpdate = lastPendingUpdate));
			}
			if (null !== firstBaseUpdate) {
				var newState = queue.baseState;
				lastBaseUpdate = 0;
				current = firstPendingUpdate = lastPendingUpdate = null;
				pendingQueue = firstBaseUpdate;
				do {
					var updateLane = pendingQueue.lane & -536870913, isHiddenUpdate = updateLane !== pendingQueue.lane;
					if (isHiddenUpdate ? (workInProgressRootRenderLanes & updateLane) === updateLane : (renderLanes$1 & updateLane) === updateLane) {
						0 !== updateLane && updateLane === currentEntangledLane && (didReadFromEntangledAsyncAction = !0);
						null !== current && (current = current.next = {
							lane: 0,
							tag: pendingQueue.tag,
							payload: pendingQueue.payload,
							callback: null,
							next: null
						});
						a: {
							var workInProgress$1 = workInProgress$jscomp$0, update = pendingQueue;
							updateLane = props;
							var instance = instance$jscomp$0;
							switch (update.tag) {
								case 1:
									workInProgress$1 = update.payload;
									if ("function" === typeof workInProgress$1) {
										newState = workInProgress$1.call(instance, newState, updateLane);
										break a;
									}
									newState = workInProgress$1;
									break a;
								case 3: workInProgress$1.flags = workInProgress$1.flags & -65537 | 128;
								case 0:
									workInProgress$1 = update.payload;
									updateLane = "function" === typeof workInProgress$1 ? workInProgress$1.call(instance, newState, updateLane) : workInProgress$1;
									if (null === updateLane || void 0 === updateLane) break a;
									newState = assign$1({}, newState, updateLane);
									break a;
								case 2: hasForceUpdate = !0;
							}
						}
						updateLane = pendingQueue.callback;
						null !== updateLane && (workInProgress$jscomp$0.flags |= 64, isHiddenUpdate && (workInProgress$jscomp$0.flags |= 8192), isHiddenUpdate = queue.callbacks, null === isHiddenUpdate ? queue.callbacks = [updateLane] : isHiddenUpdate.push(updateLane));
					} else isHiddenUpdate = {
						lane: updateLane,
						tag: pendingQueue.tag,
						payload: pendingQueue.payload,
						callback: pendingQueue.callback,
						next: null
					}, null === current ? (firstPendingUpdate = current = isHiddenUpdate, lastPendingUpdate = newState) : current = current.next = isHiddenUpdate, lastBaseUpdate |= updateLane;
					pendingQueue = pendingQueue.next;
					if (null === pendingQueue) if (pendingQueue = queue.shared.pending, null === pendingQueue) break;
					else isHiddenUpdate = pendingQueue, pendingQueue = isHiddenUpdate.next, isHiddenUpdate.next = null, queue.lastBaseUpdate = isHiddenUpdate, queue.shared.pending = null;
				} while (1);
				null === current && (lastPendingUpdate = newState);
				queue.baseState = lastPendingUpdate;
				queue.firstBaseUpdate = firstPendingUpdate;
				queue.lastBaseUpdate = current;
				null === firstBaseUpdate && (queue.shared.lanes = 0);
				workInProgressRootSkippedLanes |= lastBaseUpdate;
				workInProgress$jscomp$0.lanes = lastBaseUpdate;
				workInProgress$jscomp$0.memoizedState = newState;
			}
		}
		function callCallback(callback, context) {
			if ("function" !== typeof callback) throw Error(formatProdErrorMessage(191, callback));
			callback.call(context);
		}
		function commitCallbacks(updateQueue, context) {
			var callbacks = updateQueue.callbacks;
			if (null !== callbacks) for (updateQueue.callbacks = null, updateQueue = 0; updateQueue < callbacks.length; updateQueue++) callCallback(callbacks[updateQueue], context);
		}
		function pushHiddenContext(fiber, context) {
			fiber = entangledRenderLanes;
			push$2(prevEntangledRenderLanesCursor, fiber);
			push$2(currentTreeHiddenStackCursor, context);
			entangledRenderLanes = fiber | context.baseLanes;
		}
		function reuseHiddenContextOnStack() {
			push$2(prevEntangledRenderLanesCursor, entangledRenderLanes);
			push$2(currentTreeHiddenStackCursor, currentTreeHiddenStackCursor.current);
		}
		function popHiddenContext() {
			entangledRenderLanes = prevEntangledRenderLanesCursor.current;
			pop$1(currentTreeHiddenStackCursor);
			pop$1(prevEntangledRenderLanesCursor);
		}
		function throwInvalidHookError() {
			throw Error(formatProdErrorMessage(321));
		}
		function areHookInputsEqual(nextDeps, prevDeps) {
			if (null === prevDeps) return !1;
			for (var i = 0; i < prevDeps.length && i < nextDeps.length; i++) if (!objectIs(nextDeps[i], prevDeps[i])) return !1;
			return !0;
		}
		function renderWithHooks(current, workInProgress$1, Component$1, props, secondArg, nextRenderLanes) {
			renderLanes = nextRenderLanes;
			currentlyRenderingFiber = workInProgress$1;
			workInProgress$1.memoizedState = null;
			workInProgress$1.updateQueue = null;
			workInProgress$1.lanes = 0;
			ReactSharedInternals$1.H = null === current || null === current.memoizedState ? HooksDispatcherOnMount : HooksDispatcherOnUpdate;
			shouldDoubleInvokeUserFnsInHooksDEV = !1;
			nextRenderLanes = Component$1(props, secondArg);
			shouldDoubleInvokeUserFnsInHooksDEV = !1;
			didScheduleRenderPhaseUpdateDuringThisPass && (nextRenderLanes = renderWithHooksAgain(workInProgress$1, Component$1, props, secondArg));
			finishRenderingHooks(current);
			return nextRenderLanes;
		}
		function finishRenderingHooks(current) {
			ReactSharedInternals$1.H = ContextOnlyDispatcher;
			var didRenderTooFewHooks = null !== currentHook && null !== currentHook.next;
			renderLanes = 0;
			workInProgressHook = currentHook = currentlyRenderingFiber = null;
			didScheduleRenderPhaseUpdate = !1;
			thenableIndexCounter$1 = 0;
			thenableState$1 = null;
			if (didRenderTooFewHooks) throw Error(formatProdErrorMessage(300));
			null === current || didReceiveUpdate || (current = current.dependencies, null !== current && checkIfContextChanged(current) && (didReceiveUpdate = !0));
		}
		function renderWithHooksAgain(workInProgress$1, Component$1, props, secondArg) {
			currentlyRenderingFiber = workInProgress$1;
			var numberOfReRenders = 0;
			do {
				didScheduleRenderPhaseUpdateDuringThisPass && (thenableState$1 = null);
				thenableIndexCounter$1 = 0;
				didScheduleRenderPhaseUpdateDuringThisPass = !1;
				if (25 <= numberOfReRenders) throw Error(formatProdErrorMessage(301));
				numberOfReRenders += 1;
				workInProgressHook = currentHook = null;
				if (null != workInProgress$1.updateQueue) {
					var children = workInProgress$1.updateQueue;
					children.lastEffect = null;
					children.events = null;
					children.stores = null;
					null != children.memoCache && (children.memoCache.index = 0);
				}
				ReactSharedInternals$1.H = HooksDispatcherOnRerender;
				children = Component$1(props, secondArg);
			} while (didScheduleRenderPhaseUpdateDuringThisPass);
			return children;
		}
		function TransitionAwareHostComponent() {
			var dispatcher = ReactSharedInternals$1.H, maybeThenable = dispatcher.useState()[0];
			maybeThenable = "function" === typeof maybeThenable.then ? useThenable(maybeThenable) : maybeThenable;
			dispatcher = dispatcher.useState()[0];
			(null !== currentHook ? currentHook.memoizedState : null) !== dispatcher && (currentlyRenderingFiber.flags |= 1024);
			return maybeThenable;
		}
		function checkDidRenderIdHook() {
			var didRenderIdHook = 0 !== localIdCounter;
			localIdCounter = 0;
			return didRenderIdHook;
		}
		function bailoutHooks(current, workInProgress$1, lanes) {
			workInProgress$1.updateQueue = current.updateQueue;
			workInProgress$1.flags &= -2053;
			current.lanes &= ~lanes;
		}
		function resetHooksOnUnwind(workInProgress$1) {
			if (didScheduleRenderPhaseUpdate) {
				for (workInProgress$1 = workInProgress$1.memoizedState; null !== workInProgress$1;) {
					var queue = workInProgress$1.queue;
					null !== queue && (queue.pending = null);
					workInProgress$1 = workInProgress$1.next;
				}
				didScheduleRenderPhaseUpdate = !1;
			}
			renderLanes = 0;
			workInProgressHook = currentHook = currentlyRenderingFiber = null;
			didScheduleRenderPhaseUpdateDuringThisPass = !1;
			thenableIndexCounter$1 = localIdCounter = 0;
			thenableState$1 = null;
		}
		function mountWorkInProgressHook() {
			var hook = {
				memoizedState: null,
				baseState: null,
				baseQueue: null,
				queue: null,
				next: null
			};
			null === workInProgressHook ? currentlyRenderingFiber.memoizedState = workInProgressHook = hook : workInProgressHook = workInProgressHook.next = hook;
			return workInProgressHook;
		}
		function updateWorkInProgressHook() {
			if (null === currentHook) {
				var nextCurrentHook = currentlyRenderingFiber.alternate;
				nextCurrentHook = null !== nextCurrentHook ? nextCurrentHook.memoizedState : null;
			} else nextCurrentHook = currentHook.next;
			var nextWorkInProgressHook = null === workInProgressHook ? currentlyRenderingFiber.memoizedState : workInProgressHook.next;
			if (null !== nextWorkInProgressHook) workInProgressHook = nextWorkInProgressHook, currentHook = nextCurrentHook;
			else {
				if (null === nextCurrentHook) {
					if (null === currentlyRenderingFiber.alternate) throw Error(formatProdErrorMessage(467));
					throw Error(formatProdErrorMessage(310));
				}
				currentHook = nextCurrentHook;
				nextCurrentHook = {
					memoizedState: currentHook.memoizedState,
					baseState: currentHook.baseState,
					baseQueue: currentHook.baseQueue,
					queue: currentHook.queue,
					next: null
				};
				null === workInProgressHook ? currentlyRenderingFiber.memoizedState = workInProgressHook = nextCurrentHook : workInProgressHook = workInProgressHook.next = nextCurrentHook;
			}
			return workInProgressHook;
		}
		function createFunctionComponentUpdateQueue() {
			return {
				lastEffect: null,
				events: null,
				stores: null,
				memoCache: null
			};
		}
		function useThenable(thenable) {
			var index = thenableIndexCounter$1;
			thenableIndexCounter$1 += 1;
			null === thenableState$1 && (thenableState$1 = []);
			thenable = trackUsedThenable(thenableState$1, thenable, index);
			index = currentlyRenderingFiber;
			null === (null === workInProgressHook ? index.memoizedState : workInProgressHook.next) && (index = index.alternate, ReactSharedInternals$1.H = null === index || null === index.memoizedState ? HooksDispatcherOnMount : HooksDispatcherOnUpdate);
			return thenable;
		}
		function use(usable) {
			if (null !== usable && "object" === typeof usable) {
				if ("function" === typeof usable.then) return useThenable(usable);
				if (usable.$$typeof === REACT_CONTEXT_TYPE$1) return readContext(usable);
			}
			throw Error(formatProdErrorMessage(438, String(usable)));
		}
		function useMemoCache(size) {
			var memoCache = null, updateQueue = currentlyRenderingFiber.updateQueue;
			null !== updateQueue && (memoCache = updateQueue.memoCache);
			if (null == memoCache) {
				var current = currentlyRenderingFiber.alternate;
				null !== current && (current = current.updateQueue, null !== current && (current = current.memoCache, null != current && (memoCache = {
					data: current.data.map(function(array) {
						return array.slice();
					}),
					index: 0
				})));
			}
			memoCache ??= {
				data: [],
				index: 0
			};
			null === updateQueue && (updateQueue = createFunctionComponentUpdateQueue(), currentlyRenderingFiber.updateQueue = updateQueue);
			updateQueue.memoCache = memoCache;
			updateQueue = memoCache.data[memoCache.index];
			if (void 0 === updateQueue) for (updateQueue = memoCache.data[memoCache.index] = Array(size), current = 0; current < size; current++) updateQueue[current] = REACT_MEMO_CACHE_SENTINEL;
			memoCache.index++;
			return updateQueue;
		}
		function basicStateReducer(state, action) {
			return "function" === typeof action ? action(state) : action;
		}
		function updateReducer(reducer) {
			return updateReducerImpl(updateWorkInProgressHook(), currentHook, reducer);
		}
		function updateReducerImpl(hook, current, reducer) {
			var queue = hook.queue;
			if (null === queue) throw Error(formatProdErrorMessage(311));
			queue.lastRenderedReducer = reducer;
			var baseQueue = hook.baseQueue, pendingQueue = queue.pending;
			if (null !== pendingQueue) {
				if (null !== baseQueue) {
					var baseFirst = baseQueue.next;
					baseQueue.next = pendingQueue.next;
					pendingQueue.next = baseFirst;
				}
				current.baseQueue = baseQueue = pendingQueue;
				queue.pending = null;
			}
			pendingQueue = hook.baseState;
			if (null === baseQueue) hook.memoizedState = pendingQueue;
			else {
				current = baseQueue.next;
				var newBaseQueueFirst = baseFirst = null, newBaseQueueLast = null, update = current, didReadFromEntangledAsyncAction$23 = !1;
				do {
					var updateLane = update.lane & -536870913;
					if (updateLane !== update.lane ? (workInProgressRootRenderLanes & updateLane) === updateLane : (renderLanes & updateLane) === updateLane) {
						var revertLane = update.revertLane;
						if (0 === revertLane) null !== newBaseQueueLast && (newBaseQueueLast = newBaseQueueLast.next = {
							lane: 0,
							revertLane: 0,
							action: update.action,
							hasEagerState: update.hasEagerState,
							eagerState: update.eagerState,
							next: null
						}), updateLane === currentEntangledLane && (didReadFromEntangledAsyncAction$23 = !0);
						else if ((renderLanes & revertLane) === revertLane) {
							update = update.next;
							revertLane === currentEntangledLane && (didReadFromEntangledAsyncAction$23 = !0);
							continue;
						} else updateLane = {
							lane: 0,
							revertLane: update.revertLane,
							action: update.action,
							hasEagerState: update.hasEagerState,
							eagerState: update.eagerState,
							next: null
						}, null === newBaseQueueLast ? (newBaseQueueFirst = newBaseQueueLast = updateLane, baseFirst = pendingQueue) : newBaseQueueLast = newBaseQueueLast.next = updateLane, currentlyRenderingFiber.lanes |= revertLane, workInProgressRootSkippedLanes |= revertLane;
						updateLane = update.action;
						shouldDoubleInvokeUserFnsInHooksDEV && reducer(pendingQueue, updateLane);
						pendingQueue = update.hasEagerState ? update.eagerState : reducer(pendingQueue, updateLane);
					} else revertLane = {
						lane: updateLane,
						revertLane: update.revertLane,
						action: update.action,
						hasEagerState: update.hasEagerState,
						eagerState: update.eagerState,
						next: null
					}, null === newBaseQueueLast ? (newBaseQueueFirst = newBaseQueueLast = revertLane, baseFirst = pendingQueue) : newBaseQueueLast = newBaseQueueLast.next = revertLane, currentlyRenderingFiber.lanes |= updateLane, workInProgressRootSkippedLanes |= updateLane;
					update = update.next;
				} while (null !== update && update !== current);
				null === newBaseQueueLast ? baseFirst = pendingQueue : newBaseQueueLast.next = newBaseQueueFirst;
				if (!objectIs(pendingQueue, hook.memoizedState) && (didReceiveUpdate = !0, didReadFromEntangledAsyncAction$23 && (reducer = currentEntangledActionThenable, null !== reducer))) throw reducer;
				hook.memoizedState = pendingQueue;
				hook.baseState = baseFirst;
				hook.baseQueue = newBaseQueueLast;
				queue.lastRenderedState = pendingQueue;
			}
			null === baseQueue && (queue.lanes = 0);
			return [hook.memoizedState, queue.dispatch];
		}
		function rerenderReducer(reducer) {
			var hook = updateWorkInProgressHook(), queue = hook.queue;
			if (null === queue) throw Error(formatProdErrorMessage(311));
			queue.lastRenderedReducer = reducer;
			var dispatch = queue.dispatch, lastRenderPhaseUpdate = queue.pending, newState = hook.memoizedState;
			if (null !== lastRenderPhaseUpdate) {
				queue.pending = null;
				var update = lastRenderPhaseUpdate = lastRenderPhaseUpdate.next;
				do
					newState = reducer(newState, update.action), update = update.next;
				while (update !== lastRenderPhaseUpdate);
				objectIs(newState, hook.memoizedState) || (didReceiveUpdate = !0);
				hook.memoizedState = newState;
				null === hook.baseQueue && (hook.baseState = newState);
				queue.lastRenderedState = newState;
			}
			return [newState, dispatch];
		}
		function updateSyncExternalStore(subscribe, getSnapshot, getServerSnapshot) {
			var fiber = currentlyRenderingFiber, hook = updateWorkInProgressHook(), isHydrating$jscomp$0 = isHydrating;
			if (isHydrating$jscomp$0) {
				if (void 0 === getServerSnapshot) throw Error(formatProdErrorMessage(407));
				getServerSnapshot = getServerSnapshot();
			} else getServerSnapshot = getSnapshot();
			var snapshotChanged = !objectIs((currentHook || hook).memoizedState, getServerSnapshot);
			snapshotChanged && (hook.memoizedState = getServerSnapshot, didReceiveUpdate = !0);
			hook = hook.queue;
			updateEffectImpl(2048, 8, subscribeToStore.bind(null, fiber, hook, subscribe), [subscribe]);
			if (hook.getSnapshot !== getSnapshot || snapshotChanged || null !== workInProgressHook && workInProgressHook.memoizedState.tag & 1) {
				fiber.flags |= 2048;
				pushSimpleEffect(9, createEffectInstance(), updateStoreInstance.bind(null, fiber, hook, getServerSnapshot, getSnapshot), null);
				if (null === workInProgressRoot) throw Error(formatProdErrorMessage(349));
				isHydrating$jscomp$0 || 0 !== (renderLanes & 124) || pushStoreConsistencyCheck(fiber, getSnapshot, getServerSnapshot);
			}
			return getServerSnapshot;
		}
		function pushStoreConsistencyCheck(fiber, getSnapshot, renderedSnapshot) {
			fiber.flags |= 16384;
			fiber = {
				getSnapshot,
				value: renderedSnapshot
			};
			getSnapshot = currentlyRenderingFiber.updateQueue;
			null === getSnapshot ? (getSnapshot = createFunctionComponentUpdateQueue(), currentlyRenderingFiber.updateQueue = getSnapshot, getSnapshot.stores = [fiber]) : (renderedSnapshot = getSnapshot.stores, null === renderedSnapshot ? getSnapshot.stores = [fiber] : renderedSnapshot.push(fiber));
		}
		function updateStoreInstance(fiber, inst, nextSnapshot, getSnapshot) {
			inst.value = nextSnapshot;
			inst.getSnapshot = getSnapshot;
			checkIfSnapshotChanged(inst) && forceStoreRerender(fiber);
		}
		function subscribeToStore(fiber, inst, subscribe) {
			return subscribe(function() {
				checkIfSnapshotChanged(inst) && forceStoreRerender(fiber);
			});
		}
		function checkIfSnapshotChanged(inst) {
			var latestGetSnapshot = inst.getSnapshot;
			inst = inst.value;
			try {
				var nextValue = latestGetSnapshot();
				return !objectIs(inst, nextValue);
			} catch (error) {
				return !0;
			}
		}
		function forceStoreRerender(fiber) {
			var root = enqueueConcurrentRenderForLane(fiber, 2);
			null !== root && scheduleUpdateOnFiber(root, fiber, 2);
		}
		function mountStateImpl(initialState) {
			var hook = mountWorkInProgressHook();
			if ("function" === typeof initialState) {
				var initialStateInitializer = initialState;
				initialState = initialStateInitializer();
				if (shouldDoubleInvokeUserFnsInHooksDEV) {
					setIsStrictModeForDevtools(!0);
					try {
						initialStateInitializer();
					} finally {
						setIsStrictModeForDevtools(!1);
					}
				}
			}
			hook.memoizedState = hook.baseState = initialState;
			hook.queue = {
				pending: null,
				lanes: 0,
				dispatch: null,
				lastRenderedReducer: basicStateReducer,
				lastRenderedState: initialState
			};
			return hook;
		}
		function updateOptimisticImpl(hook, current, passthrough, reducer) {
			hook.baseState = passthrough;
			return updateReducerImpl(hook, currentHook, "function" === typeof reducer ? reducer : basicStateReducer);
		}
		function dispatchActionState(fiber, actionQueue, setPendingState, setState, payload) {
			if (isRenderPhaseUpdate(fiber)) throw Error(formatProdErrorMessage(485));
			fiber = actionQueue.action;
			if (null !== fiber) {
				var actionNode = {
					payload,
					action: fiber,
					next: null,
					isTransition: !0,
					status: "pending",
					value: null,
					reason: null,
					listeners: [],
					then: function(listener) {
						actionNode.listeners.push(listener);
					}
				};
				null !== ReactSharedInternals$1.T ? setPendingState(!0) : actionNode.isTransition = !1;
				setState(actionNode);
				setPendingState = actionQueue.pending;
				null === setPendingState ? (actionNode.next = actionQueue.pending = actionNode, runActionStateAction(actionQueue, actionNode)) : (actionNode.next = setPendingState.next, actionQueue.pending = setPendingState.next = actionNode);
			}
		}
		function runActionStateAction(actionQueue, node) {
			var action = node.action, payload = node.payload, prevState = actionQueue.state;
			if (node.isTransition) {
				var prevTransition = ReactSharedInternals$1.T, currentTransition = {};
				ReactSharedInternals$1.T = currentTransition;
				try {
					var returnValue = action(prevState, payload), onStartTransitionFinish = ReactSharedInternals$1.S;
					null !== onStartTransitionFinish && onStartTransitionFinish(currentTransition, returnValue);
					handleActionReturnValue(actionQueue, node, returnValue);
				} catch (error) {
					onActionError(actionQueue, node, error);
				} finally {
					ReactSharedInternals$1.T = prevTransition;
				}
			} else try {
				prevTransition = action(prevState, payload), handleActionReturnValue(actionQueue, node, prevTransition);
			} catch (error$27) {
				onActionError(actionQueue, node, error$27);
			}
		}
		function handleActionReturnValue(actionQueue, node, returnValue) {
			null !== returnValue && "object" === typeof returnValue && "function" === typeof returnValue.then ? returnValue.then(function(nextState) {
				onActionSuccess(actionQueue, node, nextState);
			}, function(error) {
				return onActionError(actionQueue, node, error);
			}) : onActionSuccess(actionQueue, node, returnValue);
		}
		function onActionSuccess(actionQueue, actionNode, nextState) {
			actionNode.status = "fulfilled";
			actionNode.value = nextState;
			notifyActionListeners(actionNode);
			actionQueue.state = nextState;
			actionNode = actionQueue.pending;
			null !== actionNode && (nextState = actionNode.next, nextState === actionNode ? actionQueue.pending = null : (nextState = nextState.next, actionNode.next = nextState, runActionStateAction(actionQueue, nextState)));
		}
		function onActionError(actionQueue, actionNode, error) {
			var last = actionQueue.pending;
			actionQueue.pending = null;
			if (null !== last) {
				last = last.next;
				do
					actionNode.status = "rejected", actionNode.reason = error, notifyActionListeners(actionNode), actionNode = actionNode.next;
				while (actionNode !== last);
			}
			actionQueue.action = null;
		}
		function notifyActionListeners(actionNode) {
			actionNode = actionNode.listeners;
			for (var i = 0; i < actionNode.length; i++) (0, actionNode[i])();
		}
		function actionStateReducer(oldState, newState) {
			return newState;
		}
		function mountActionState(action, initialStateProp) {
			if (isHydrating) {
				var ssrFormState = workInProgressRoot.formState;
				if (null !== ssrFormState) {
					a: {
						var JSCompiler_inline_result = currentlyRenderingFiber;
						if (isHydrating) {
							if (nextHydratableInstance) {
								var markerInstance = canHydrateFormStateMarker(nextHydratableInstance, rootOrSingletonContext);
								if (markerInstance) {
									nextHydratableInstance = getNextHydratableSibling(markerInstance);
									JSCompiler_inline_result = isFormStateMarkerMatching(markerInstance);
									break a;
								}
							}
							throwOnHydrationMismatch(JSCompiler_inline_result);
						}
						JSCompiler_inline_result = !1;
					}
					JSCompiler_inline_result && (initialStateProp = ssrFormState[0]);
				}
			}
			ssrFormState = mountWorkInProgressHook();
			ssrFormState.memoizedState = ssrFormState.baseState = initialStateProp;
			JSCompiler_inline_result = {
				pending: null,
				lanes: 0,
				dispatch: null,
				lastRenderedReducer: actionStateReducer,
				lastRenderedState: initialStateProp
			};
			ssrFormState.queue = JSCompiler_inline_result;
			ssrFormState = dispatchSetState.bind(null, currentlyRenderingFiber, JSCompiler_inline_result);
			JSCompiler_inline_result.dispatch = ssrFormState;
			JSCompiler_inline_result = mountStateImpl(!1);
			var setPendingState = dispatchOptimisticSetState.bind(null, currentlyRenderingFiber, !1, JSCompiler_inline_result.queue);
			JSCompiler_inline_result = mountWorkInProgressHook();
			markerInstance = {
				state: initialStateProp,
				dispatch: null,
				action,
				pending: null
			};
			JSCompiler_inline_result.queue = markerInstance;
			ssrFormState = dispatchActionState.bind(null, currentlyRenderingFiber, markerInstance, setPendingState, ssrFormState);
			markerInstance.dispatch = ssrFormState;
			JSCompiler_inline_result.memoizedState = action;
			return [
				initialStateProp,
				ssrFormState,
				!1
			];
		}
		function updateActionState(action) {
			return updateActionStateImpl(updateWorkInProgressHook(), currentHook, action);
		}
		function updateActionStateImpl(stateHook, currentStateHook, action) {
			currentStateHook = updateReducerImpl(stateHook, currentStateHook, actionStateReducer)[0];
			stateHook = updateReducer(basicStateReducer)[0];
			if ("object" === typeof currentStateHook && null !== currentStateHook && "function" === typeof currentStateHook.then) try {
				var state = useThenable(currentStateHook);
			} catch (x) {
				if (x === SuspenseException) throw SuspenseActionException;
				throw x;
			}
			else state = currentStateHook;
			currentStateHook = updateWorkInProgressHook();
			var actionQueue = currentStateHook.queue, dispatch = actionQueue.dispatch;
			action !== currentStateHook.memoizedState && (currentlyRenderingFiber.flags |= 2048, pushSimpleEffect(9, createEffectInstance(), actionStateActionEffect.bind(null, actionQueue, action), null));
			return [
				state,
				dispatch,
				stateHook
			];
		}
		function actionStateActionEffect(actionQueue, action) {
			actionQueue.action = action;
		}
		function rerenderActionState(action) {
			var stateHook = updateWorkInProgressHook(), currentStateHook = currentHook;
			if (null !== currentStateHook) return updateActionStateImpl(stateHook, currentStateHook, action);
			updateWorkInProgressHook();
			stateHook = stateHook.memoizedState;
			currentStateHook = updateWorkInProgressHook();
			var dispatch = currentStateHook.queue.dispatch;
			currentStateHook.memoizedState = action;
			return [
				stateHook,
				dispatch,
				!1
			];
		}
		function pushSimpleEffect(tag, inst, create$1, createDeps) {
			tag = {
				tag,
				create: create$1,
				deps: createDeps,
				inst,
				next: null
			};
			inst = currentlyRenderingFiber.updateQueue;
			null === inst && (inst = createFunctionComponentUpdateQueue(), currentlyRenderingFiber.updateQueue = inst);
			create$1 = inst.lastEffect;
			null === create$1 ? inst.lastEffect = tag.next = tag : (createDeps = create$1.next, create$1.next = tag, tag.next = createDeps, inst.lastEffect = tag);
			return tag;
		}
		function createEffectInstance() {
			return {
				destroy: void 0,
				resource: void 0
			};
		}
		function updateRef() {
			return updateWorkInProgressHook().memoizedState;
		}
		function mountEffectImpl(fiberFlags, hookFlags, create$1, createDeps) {
			var hook = mountWorkInProgressHook();
			createDeps = void 0 === createDeps ? null : createDeps;
			currentlyRenderingFiber.flags |= fiberFlags;
			hook.memoizedState = pushSimpleEffect(1 | hookFlags, createEffectInstance(), create$1, createDeps);
		}
		function updateEffectImpl(fiberFlags, hookFlags, create$1, deps) {
			var hook = updateWorkInProgressHook();
			deps = void 0 === deps ? null : deps;
			var inst = hook.memoizedState.inst;
			null !== currentHook && null !== deps && areHookInputsEqual(deps, currentHook.memoizedState.deps) ? hook.memoizedState = pushSimpleEffect(hookFlags, inst, create$1, deps) : (currentlyRenderingFiber.flags |= fiberFlags, hook.memoizedState = pushSimpleEffect(1 | hookFlags, inst, create$1, deps));
		}
		function mountEffect(create$1, createDeps) {
			mountEffectImpl(8390656, 8, create$1, createDeps);
		}
		function updateEffect(create$1, createDeps) {
			updateEffectImpl(2048, 8, create$1, createDeps);
		}
		function updateInsertionEffect(create$1, deps) {
			return updateEffectImpl(4, 2, create$1, deps);
		}
		function updateLayoutEffect(create$1, deps) {
			return updateEffectImpl(4, 4, create$1, deps);
		}
		function imperativeHandleEffect(create$1, ref) {
			if ("function" === typeof ref) {
				create$1 = create$1();
				var refCleanup = ref(create$1);
				return function() {
					"function" === typeof refCleanup ? refCleanup() : ref(null);
				};
			}
			if (null !== ref && void 0 !== ref) return create$1 = create$1(), ref.current = create$1, function() {
				ref.current = null;
			};
		}
		function updateImperativeHandle(ref, create$1, deps) {
			deps = null !== deps && void 0 !== deps ? deps.concat([ref]) : null;
			updateEffectImpl(4, 4, imperativeHandleEffect.bind(null, create$1, ref), deps);
		}
		function mountDebugValue() {}
		function updateCallback(callback, deps) {
			var hook = updateWorkInProgressHook();
			deps = void 0 === deps ? null : deps;
			var prevState = hook.memoizedState;
			if (null !== deps && areHookInputsEqual(deps, prevState[1])) return prevState[0];
			hook.memoizedState = [callback, deps];
			return callback;
		}
		function updateMemo(nextCreate, deps) {
			var hook = updateWorkInProgressHook();
			deps = void 0 === deps ? null : deps;
			var prevState = hook.memoizedState;
			if (null !== deps && areHookInputsEqual(deps, prevState[1])) return prevState[0];
			prevState = nextCreate();
			if (shouldDoubleInvokeUserFnsInHooksDEV) {
				setIsStrictModeForDevtools(!0);
				try {
					nextCreate();
				} finally {
					setIsStrictModeForDevtools(!1);
				}
			}
			hook.memoizedState = [prevState, deps];
			return prevState;
		}
		function mountDeferredValueImpl(hook, value, initialValue) {
			if (void 0 === initialValue || 0 !== (renderLanes & 1073741824)) return hook.memoizedState = value;
			hook.memoizedState = initialValue;
			hook = requestDeferredLane();
			currentlyRenderingFiber.lanes |= hook;
			workInProgressRootSkippedLanes |= hook;
			return initialValue;
		}
		function updateDeferredValueImpl(hook, prevValue, value, initialValue) {
			if (objectIs(value, prevValue)) return value;
			if (null !== currentTreeHiddenStackCursor.current) return hook = mountDeferredValueImpl(hook, value, initialValue), objectIs(hook, prevValue) || (didReceiveUpdate = !0), hook;
			if (0 === (renderLanes & 42)) return didReceiveUpdate = !0, hook.memoizedState = value;
			hook = requestDeferredLane();
			currentlyRenderingFiber.lanes |= hook;
			workInProgressRootSkippedLanes |= hook;
			return prevValue;
		}
		function startTransition(fiber, queue, pendingState, finishedState, callback) {
			var previousPriority = getCurrentUpdatePriority();
			setCurrentUpdatePriority(0 !== previousPriority && 8 > previousPriority ? previousPriority : 8);
			var prevTransition = ReactSharedInternals$1.T, currentTransition = {};
			ReactSharedInternals$1.T = currentTransition;
			dispatchOptimisticSetState(fiber, !1, queue, pendingState);
			try {
				var returnValue = callback(), onStartTransitionFinish = ReactSharedInternals$1.S;
				null !== onStartTransitionFinish && onStartTransitionFinish(currentTransition, returnValue);
				if (null !== returnValue && "object" === typeof returnValue && "function" === typeof returnValue.then) dispatchSetStateInternal(fiber, queue, chainThenableValue(returnValue, finishedState), requestUpdateLane(fiber));
				else dispatchSetStateInternal(fiber, queue, finishedState, requestUpdateLane(fiber));
			} catch (error) {
				dispatchSetStateInternal(fiber, queue, {
					then: function() {},
					status: "rejected",
					reason: error
				}, requestUpdateLane());
			} finally {
				setCurrentUpdatePriority(previousPriority), ReactSharedInternals$1.T = prevTransition;
			}
		}
		function ensureFormComponentIsStateful(formFiber) {
			var existingStateHook = formFiber.memoizedState;
			if (null !== existingStateHook) return existingStateHook;
			existingStateHook = {
				memoizedState: NotPendingTransition,
				baseState: NotPendingTransition,
				baseQueue: null,
				queue: {
					pending: null,
					lanes: 0,
					dispatch: null,
					lastRenderedReducer: basicStateReducer,
					lastRenderedState: NotPendingTransition
				},
				next: null
			};
			var initialResetState = {};
			existingStateHook.next = {
				memoizedState: initialResetState,
				baseState: initialResetState,
				baseQueue: null,
				queue: {
					pending: null,
					lanes: 0,
					dispatch: null,
					lastRenderedReducer: basicStateReducer,
					lastRenderedState: initialResetState
				},
				next: null
			};
			formFiber.memoizedState = existingStateHook;
			formFiber = formFiber.alternate;
			null !== formFiber && (formFiber.memoizedState = existingStateHook);
			return existingStateHook;
		}
		function useHostTransitionStatus() {
			return readContext(HostTransitionContext);
		}
		function updateId() {
			return updateWorkInProgressHook().memoizedState;
		}
		function updateRefresh() {
			return updateWorkInProgressHook().memoizedState;
		}
		function refreshCache(fiber) {
			for (var provider = fiber.return; null !== provider;) {
				switch (provider.tag) {
					case 24:
					case 3:
						var lane = requestUpdateLane();
						fiber = createUpdate(lane);
						var root = enqueueUpdate(provider, fiber, lane);
						null !== root && (scheduleUpdateOnFiber(root, provider, lane), entangleTransitions(root, provider, lane));
						provider = { cache: createCache() };
						fiber.payload = provider;
						return;
				}
				provider = provider.return;
			}
		}
		function dispatchReducerAction(fiber, queue, action) {
			var lane = requestUpdateLane();
			action = {
				lane,
				revertLane: 0,
				action,
				hasEagerState: !1,
				eagerState: null,
				next: null
			};
			isRenderPhaseUpdate(fiber) ? enqueueRenderPhaseUpdate(queue, action) : (action = enqueueConcurrentHookUpdate(fiber, queue, action, lane), null !== action && (scheduleUpdateOnFiber(action, fiber, lane), entangleTransitionUpdate(action, queue, lane)));
		}
		function dispatchSetState(fiber, queue, action) {
			dispatchSetStateInternal(fiber, queue, action, requestUpdateLane());
		}
		function dispatchSetStateInternal(fiber, queue, action, lane) {
			var update = {
				lane,
				revertLane: 0,
				action,
				hasEagerState: !1,
				eagerState: null,
				next: null
			};
			if (isRenderPhaseUpdate(fiber)) enqueueRenderPhaseUpdate(queue, update);
			else {
				var alternate = fiber.alternate;
				if (0 === fiber.lanes && (null === alternate || 0 === alternate.lanes) && (alternate = queue.lastRenderedReducer, null !== alternate)) try {
					var currentState = queue.lastRenderedState, eagerState = alternate(currentState, action);
					update.hasEagerState = !0;
					update.eagerState = eagerState;
					if (objectIs(eagerState, currentState)) return enqueueUpdate$1(fiber, queue, update, 0), null === workInProgressRoot && finishQueueingConcurrentUpdates(), !1;
				} catch (error) {}
				action = enqueueConcurrentHookUpdate(fiber, queue, update, lane);
				if (null !== action) return scheduleUpdateOnFiber(action, fiber, lane), entangleTransitionUpdate(action, queue, lane), !0;
			}
			return !1;
		}
		function dispatchOptimisticSetState(fiber, throwIfDuringRender, queue, action) {
			action = {
				lane: 2,
				revertLane: requestTransitionLane(),
				action,
				hasEagerState: !1,
				eagerState: null,
				next: null
			};
			if (isRenderPhaseUpdate(fiber)) {
				if (throwIfDuringRender) throw Error(formatProdErrorMessage(479));
			} else throwIfDuringRender = enqueueConcurrentHookUpdate(fiber, queue, action, 2), null !== throwIfDuringRender && scheduleUpdateOnFiber(throwIfDuringRender, fiber, 2);
		}
		function isRenderPhaseUpdate(fiber) {
			var alternate = fiber.alternate;
			return fiber === currentlyRenderingFiber || null !== alternate && alternate === currentlyRenderingFiber;
		}
		function enqueueRenderPhaseUpdate(queue, update) {
			didScheduleRenderPhaseUpdateDuringThisPass = didScheduleRenderPhaseUpdate = !0;
			var pending = queue.pending;
			null === pending ? update.next = update : (update.next = pending.next, pending.next = update);
			queue.pending = update;
		}
		function entangleTransitionUpdate(root, queue, lane) {
			if (0 !== (lane & 4194048)) {
				var queueLanes = queue.lanes;
				queueLanes &= root.pendingLanes;
				lane |= queueLanes;
				queue.lanes = lane;
				markRootEntangled(root, lane);
			}
		}
		function unwrapThenable(thenable) {
			var index = thenableIndexCounter;
			thenableIndexCounter += 1;
			null === thenableState && (thenableState = []);
			return trackUsedThenable(thenableState, thenable, index);
		}
		function coerceRef(workInProgress$1, element) {
			element = element.props.ref;
			workInProgress$1.ref = void 0 !== element ? element : null;
		}
		function throwOnInvalidObjectType(returnFiber, newChild) {
			if (newChild.$$typeof === REACT_LEGACY_ELEMENT_TYPE) throw Error(formatProdErrorMessage(525));
			returnFiber = Object.prototype.toString.call(newChild);
			throw Error(formatProdErrorMessage(31, "[object Object]" === returnFiber ? "object with keys {" + Object.keys(newChild).join(", ") + "}" : returnFiber));
		}
		function resolveLazy(lazyType) {
			var init = lazyType._init;
			return init(lazyType._payload);
		}
		function createChildReconciler(shouldTrackSideEffects) {
			function deleteChild(returnFiber, childToDelete) {
				if (shouldTrackSideEffects) {
					var deletions = returnFiber.deletions;
					null === deletions ? (returnFiber.deletions = [childToDelete], returnFiber.flags |= 16) : deletions.push(childToDelete);
				}
			}
			function deleteRemainingChildren(returnFiber, currentFirstChild) {
				if (!shouldTrackSideEffects) return null;
				for (; null !== currentFirstChild;) deleteChild(returnFiber, currentFirstChild), currentFirstChild = currentFirstChild.sibling;
				return null;
			}
			function mapRemainingChildren(currentFirstChild) {
				for (var existingChildren = /* @__PURE__ */ new Map(); null !== currentFirstChild;) null !== currentFirstChild.key ? existingChildren.set(currentFirstChild.key, currentFirstChild) : existingChildren.set(currentFirstChild.index, currentFirstChild), currentFirstChild = currentFirstChild.sibling;
				return existingChildren;
			}
			function useFiber(fiber, pendingProps) {
				fiber = createWorkInProgress(fiber, pendingProps);
				fiber.index = 0;
				fiber.sibling = null;
				return fiber;
			}
			function placeChild(newFiber, lastPlacedIndex, newIndex) {
				newFiber.index = newIndex;
				if (!shouldTrackSideEffects) return newFiber.flags |= 1048576, lastPlacedIndex;
				newIndex = newFiber.alternate;
				if (null !== newIndex) return newIndex = newIndex.index, newIndex < lastPlacedIndex ? (newFiber.flags |= 67108866, lastPlacedIndex) : newIndex;
				newFiber.flags |= 67108866;
				return lastPlacedIndex;
			}
			function placeSingleChild(newFiber) {
				shouldTrackSideEffects && null === newFiber.alternate && (newFiber.flags |= 67108866);
				return newFiber;
			}
			function updateTextNode(returnFiber, current, textContent, lanes) {
				if (null === current || 6 !== current.tag) return current = createFiberFromText(textContent, returnFiber.mode, lanes), current.return = returnFiber, current;
				current = useFiber(current, textContent);
				current.return = returnFiber;
				return current;
			}
			function updateElement(returnFiber, current, element, lanes) {
				var elementType = element.type;
				if (elementType === REACT_FRAGMENT_TYPE$2) return updateFragment(returnFiber, current, element.props.children, lanes, element.key);
				if (null !== current && (current.elementType === elementType || "object" === typeof elementType && null !== elementType && elementType.$$typeof === REACT_LAZY_TYPE$1 && resolveLazy(elementType) === current.type)) return current = useFiber(current, element.props), coerceRef(current, element), current.return = returnFiber, current;
				current = createFiberFromTypeAndProps(element.type, element.key, element.props, null, returnFiber.mode, lanes);
				coerceRef(current, element);
				current.return = returnFiber;
				return current;
			}
			function updatePortal(returnFiber, current, portal, lanes) {
				if (null === current || 4 !== current.tag || current.stateNode.containerInfo !== portal.containerInfo || current.stateNode.implementation !== portal.implementation) return current = createFiberFromPortal(portal, returnFiber.mode, lanes), current.return = returnFiber, current;
				current = useFiber(current, portal.children || []);
				current.return = returnFiber;
				return current;
			}
			function updateFragment(returnFiber, current, fragment, lanes, key) {
				if (null === current || 7 !== current.tag) return current = createFiberFromFragment(fragment, returnFiber.mode, lanes, key), current.return = returnFiber, current;
				current = useFiber(current, fragment);
				current.return = returnFiber;
				return current;
			}
			function createChild(returnFiber, newChild, lanes) {
				if ("string" === typeof newChild && "" !== newChild || "number" === typeof newChild || "bigint" === typeof newChild) return newChild = createFiberFromText("" + newChild, returnFiber.mode, lanes), newChild.return = returnFiber, newChild;
				if ("object" === typeof newChild && null !== newChild) {
					switch (newChild.$$typeof) {
						case REACT_ELEMENT_TYPE$2: return lanes = createFiberFromTypeAndProps(newChild.type, newChild.key, newChild.props, null, returnFiber.mode, lanes), coerceRef(lanes, newChild), lanes.return = returnFiber, lanes;
						case REACT_PORTAL_TYPE$1: return newChild = createFiberFromPortal(newChild, returnFiber.mode, lanes), newChild.return = returnFiber, newChild;
						case REACT_LAZY_TYPE$1:
							var init = newChild._init;
							newChild = init(newChild._payload);
							return createChild(returnFiber, newChild, lanes);
					}
					if (isArrayImpl$1(newChild) || getIteratorFn$1(newChild)) return newChild = createFiberFromFragment(newChild, returnFiber.mode, lanes, null), newChild.return = returnFiber, newChild;
					if ("function" === typeof newChild.then) return createChild(returnFiber, unwrapThenable(newChild), lanes);
					if (newChild.$$typeof === REACT_CONTEXT_TYPE$1) return createChild(returnFiber, readContextDuringReconciliation(returnFiber, newChild), lanes);
					throwOnInvalidObjectType(returnFiber, newChild);
				}
				return null;
			}
			function updateSlot(returnFiber, oldFiber, newChild, lanes) {
				var key = null !== oldFiber ? oldFiber.key : null;
				if ("string" === typeof newChild && "" !== newChild || "number" === typeof newChild || "bigint" === typeof newChild) return null !== key ? null : updateTextNode(returnFiber, oldFiber, "" + newChild, lanes);
				if ("object" === typeof newChild && null !== newChild) {
					switch (newChild.$$typeof) {
						case REACT_ELEMENT_TYPE$2: return newChild.key === key ? updateElement(returnFiber, oldFiber, newChild, lanes) : null;
						case REACT_PORTAL_TYPE$1: return newChild.key === key ? updatePortal(returnFiber, oldFiber, newChild, lanes) : null;
						case REACT_LAZY_TYPE$1: return key = newChild._init, newChild = key(newChild._payload), updateSlot(returnFiber, oldFiber, newChild, lanes);
					}
					if (isArrayImpl$1(newChild) || getIteratorFn$1(newChild)) return null !== key ? null : updateFragment(returnFiber, oldFiber, newChild, lanes, null);
					if ("function" === typeof newChild.then) return updateSlot(returnFiber, oldFiber, unwrapThenable(newChild), lanes);
					if (newChild.$$typeof === REACT_CONTEXT_TYPE$1) return updateSlot(returnFiber, oldFiber, readContextDuringReconciliation(returnFiber, newChild), lanes);
					throwOnInvalidObjectType(returnFiber, newChild);
				}
				return null;
			}
			function updateFromMap(existingChildren, returnFiber, newIdx, newChild, lanes) {
				if ("string" === typeof newChild && "" !== newChild || "number" === typeof newChild || "bigint" === typeof newChild) return existingChildren = existingChildren.get(newIdx) || null, updateTextNode(returnFiber, existingChildren, "" + newChild, lanes);
				if ("object" === typeof newChild && null !== newChild) {
					switch (newChild.$$typeof) {
						case REACT_ELEMENT_TYPE$2: return existingChildren = existingChildren.get(null === newChild.key ? newIdx : newChild.key) || null, updateElement(returnFiber, existingChildren, newChild, lanes);
						case REACT_PORTAL_TYPE$1: return existingChildren = existingChildren.get(null === newChild.key ? newIdx : newChild.key) || null, updatePortal(returnFiber, existingChildren, newChild, lanes);
						case REACT_LAZY_TYPE$1:
							var init = newChild._init;
							newChild = init(newChild._payload);
							return updateFromMap(existingChildren, returnFiber, newIdx, newChild, lanes);
					}
					if (isArrayImpl$1(newChild) || getIteratorFn$1(newChild)) return existingChildren = existingChildren.get(newIdx) || null, updateFragment(returnFiber, existingChildren, newChild, lanes, null);
					if ("function" === typeof newChild.then) return updateFromMap(existingChildren, returnFiber, newIdx, unwrapThenable(newChild), lanes);
					if (newChild.$$typeof === REACT_CONTEXT_TYPE$1) return updateFromMap(existingChildren, returnFiber, newIdx, readContextDuringReconciliation(returnFiber, newChild), lanes);
					throwOnInvalidObjectType(returnFiber, newChild);
				}
				return null;
			}
			function reconcileChildrenArray(returnFiber, currentFirstChild, newChildren, lanes) {
				for (var resultingFirstChild = null, previousNewFiber = null, oldFiber = currentFirstChild, newIdx = currentFirstChild = 0, nextOldFiber = null; null !== oldFiber && newIdx < newChildren.length; newIdx++) {
					oldFiber.index > newIdx ? (nextOldFiber = oldFiber, oldFiber = null) : nextOldFiber = oldFiber.sibling;
					var newFiber = updateSlot(returnFiber, oldFiber, newChildren[newIdx], lanes);
					if (null === newFiber) {
						null === oldFiber && (oldFiber = nextOldFiber);
						break;
					}
					shouldTrackSideEffects && oldFiber && null === newFiber.alternate && deleteChild(returnFiber, oldFiber);
					currentFirstChild = placeChild(newFiber, currentFirstChild, newIdx);
					null === previousNewFiber ? resultingFirstChild = newFiber : previousNewFiber.sibling = newFiber;
					previousNewFiber = newFiber;
					oldFiber = nextOldFiber;
				}
				if (newIdx === newChildren.length) return deleteRemainingChildren(returnFiber, oldFiber), isHydrating && pushTreeFork(returnFiber, newIdx), resultingFirstChild;
				if (null === oldFiber) {
					for (; newIdx < newChildren.length; newIdx++) oldFiber = createChild(returnFiber, newChildren[newIdx], lanes), null !== oldFiber && (currentFirstChild = placeChild(oldFiber, currentFirstChild, newIdx), null === previousNewFiber ? resultingFirstChild = oldFiber : previousNewFiber.sibling = oldFiber, previousNewFiber = oldFiber);
					isHydrating && pushTreeFork(returnFiber, newIdx);
					return resultingFirstChild;
				}
				for (oldFiber = mapRemainingChildren(oldFiber); newIdx < newChildren.length; newIdx++) nextOldFiber = updateFromMap(oldFiber, returnFiber, newIdx, newChildren[newIdx], lanes), null !== nextOldFiber && (shouldTrackSideEffects && null !== nextOldFiber.alternate && oldFiber.delete(null === nextOldFiber.key ? newIdx : nextOldFiber.key), currentFirstChild = placeChild(nextOldFiber, currentFirstChild, newIdx), null === previousNewFiber ? resultingFirstChild = nextOldFiber : previousNewFiber.sibling = nextOldFiber, previousNewFiber = nextOldFiber);
				shouldTrackSideEffects && oldFiber.forEach(function(child) {
					return deleteChild(returnFiber, child);
				});
				isHydrating && pushTreeFork(returnFiber, newIdx);
				return resultingFirstChild;
			}
			function reconcileChildrenIterator(returnFiber, currentFirstChild, newChildren, lanes) {
				if (null == newChildren) throw Error(formatProdErrorMessage(151));
				for (var resultingFirstChild = null, previousNewFiber = null, oldFiber = currentFirstChild, newIdx = currentFirstChild = 0, nextOldFiber = null, step = newChildren.next(); null !== oldFiber && !step.done; newIdx++, step = newChildren.next()) {
					oldFiber.index > newIdx ? (nextOldFiber = oldFiber, oldFiber = null) : nextOldFiber = oldFiber.sibling;
					var newFiber = updateSlot(returnFiber, oldFiber, step.value, lanes);
					if (null === newFiber) {
						null === oldFiber && (oldFiber = nextOldFiber);
						break;
					}
					shouldTrackSideEffects && oldFiber && null === newFiber.alternate && deleteChild(returnFiber, oldFiber);
					currentFirstChild = placeChild(newFiber, currentFirstChild, newIdx);
					null === previousNewFiber ? resultingFirstChild = newFiber : previousNewFiber.sibling = newFiber;
					previousNewFiber = newFiber;
					oldFiber = nextOldFiber;
				}
				if (step.done) return deleteRemainingChildren(returnFiber, oldFiber), isHydrating && pushTreeFork(returnFiber, newIdx), resultingFirstChild;
				if (null === oldFiber) {
					for (; !step.done; newIdx++, step = newChildren.next()) step = createChild(returnFiber, step.value, lanes), null !== step && (currentFirstChild = placeChild(step, currentFirstChild, newIdx), null === previousNewFiber ? resultingFirstChild = step : previousNewFiber.sibling = step, previousNewFiber = step);
					isHydrating && pushTreeFork(returnFiber, newIdx);
					return resultingFirstChild;
				}
				for (oldFiber = mapRemainingChildren(oldFiber); !step.done; newIdx++, step = newChildren.next()) step = updateFromMap(oldFiber, returnFiber, newIdx, step.value, lanes), null !== step && (shouldTrackSideEffects && null !== step.alternate && oldFiber.delete(null === step.key ? newIdx : step.key), currentFirstChild = placeChild(step, currentFirstChild, newIdx), null === previousNewFiber ? resultingFirstChild = step : previousNewFiber.sibling = step, previousNewFiber = step);
				shouldTrackSideEffects && oldFiber.forEach(function(child) {
					return deleteChild(returnFiber, child);
				});
				isHydrating && pushTreeFork(returnFiber, newIdx);
				return resultingFirstChild;
			}
			function reconcileChildFibersImpl(returnFiber, currentFirstChild, newChild, lanes) {
				"object" === typeof newChild && null !== newChild && newChild.type === REACT_FRAGMENT_TYPE$2 && null === newChild.key && (newChild = newChild.props.children);
				if ("object" === typeof newChild && null !== newChild) {
					switch (newChild.$$typeof) {
						case REACT_ELEMENT_TYPE$2:
							a: {
								for (var key = newChild.key; null !== currentFirstChild;) {
									if (currentFirstChild.key === key) {
										key = newChild.type;
										if (key === REACT_FRAGMENT_TYPE$2) {
											if (7 === currentFirstChild.tag) {
												deleteRemainingChildren(returnFiber, currentFirstChild.sibling);
												lanes = useFiber(currentFirstChild, newChild.props.children);
												lanes.return = returnFiber;
												returnFiber = lanes;
												break a;
											}
										} else if (currentFirstChild.elementType === key || "object" === typeof key && null !== key && key.$$typeof === REACT_LAZY_TYPE$1 && resolveLazy(key) === currentFirstChild.type) {
											deleteRemainingChildren(returnFiber, currentFirstChild.sibling);
											lanes = useFiber(currentFirstChild, newChild.props);
											coerceRef(lanes, newChild);
											lanes.return = returnFiber;
											returnFiber = lanes;
											break a;
										}
										deleteRemainingChildren(returnFiber, currentFirstChild);
										break;
									} else deleteChild(returnFiber, currentFirstChild);
									currentFirstChild = currentFirstChild.sibling;
								}
								newChild.type === REACT_FRAGMENT_TYPE$2 ? (lanes = createFiberFromFragment(newChild.props.children, returnFiber.mode, lanes, newChild.key), lanes.return = returnFiber, returnFiber = lanes) : (lanes = createFiberFromTypeAndProps(newChild.type, newChild.key, newChild.props, null, returnFiber.mode, lanes), coerceRef(lanes, newChild), lanes.return = returnFiber, returnFiber = lanes);
							}
							return placeSingleChild(returnFiber);
						case REACT_PORTAL_TYPE$1:
							a: {
								for (key = newChild.key; null !== currentFirstChild;) {
									if (currentFirstChild.key === key) if (4 === currentFirstChild.tag && currentFirstChild.stateNode.containerInfo === newChild.containerInfo && currentFirstChild.stateNode.implementation === newChild.implementation) {
										deleteRemainingChildren(returnFiber, currentFirstChild.sibling);
										lanes = useFiber(currentFirstChild, newChild.children || []);
										lanes.return = returnFiber;
										returnFiber = lanes;
										break a;
									} else {
										deleteRemainingChildren(returnFiber, currentFirstChild);
										break;
									}
									else deleteChild(returnFiber, currentFirstChild);
									currentFirstChild = currentFirstChild.sibling;
								}
								lanes = createFiberFromPortal(newChild, returnFiber.mode, lanes);
								lanes.return = returnFiber;
								returnFiber = lanes;
							}
							return placeSingleChild(returnFiber);
						case REACT_LAZY_TYPE$1: return key = newChild._init, newChild = key(newChild._payload), reconcileChildFibersImpl(returnFiber, currentFirstChild, newChild, lanes);
					}
					if (isArrayImpl$1(newChild)) return reconcileChildrenArray(returnFiber, currentFirstChild, newChild, lanes);
					if (getIteratorFn$1(newChild)) {
						key = getIteratorFn$1(newChild);
						if ("function" !== typeof key) throw Error(formatProdErrorMessage(150));
						newChild = key.call(newChild);
						return reconcileChildrenIterator(returnFiber, currentFirstChild, newChild, lanes);
					}
					if ("function" === typeof newChild.then) return reconcileChildFibersImpl(returnFiber, currentFirstChild, unwrapThenable(newChild), lanes);
					if (newChild.$$typeof === REACT_CONTEXT_TYPE$1) return reconcileChildFibersImpl(returnFiber, currentFirstChild, readContextDuringReconciliation(returnFiber, newChild), lanes);
					throwOnInvalidObjectType(returnFiber, newChild);
				}
				return "string" === typeof newChild && "" !== newChild || "number" === typeof newChild || "bigint" === typeof newChild ? (newChild = "" + newChild, null !== currentFirstChild && 6 === currentFirstChild.tag ? (deleteRemainingChildren(returnFiber, currentFirstChild.sibling), lanes = useFiber(currentFirstChild, newChild), lanes.return = returnFiber, returnFiber = lanes) : (deleteRemainingChildren(returnFiber, currentFirstChild), lanes = createFiberFromText(newChild, returnFiber.mode, lanes), lanes.return = returnFiber, returnFiber = lanes), placeSingleChild(returnFiber)) : deleteRemainingChildren(returnFiber, currentFirstChild);
			}
			return function(returnFiber, currentFirstChild, newChild, lanes) {
				try {
					thenableIndexCounter = 0;
					var firstChildFiber = reconcileChildFibersImpl(returnFiber, currentFirstChild, newChild, lanes);
					thenableState = null;
					return firstChildFiber;
				} catch (x) {
					if (x === SuspenseException || x === SuspenseActionException) throw x;
					var fiber = createFiber(29, x, null, returnFiber.mode);
					fiber.lanes = lanes;
					fiber.return = returnFiber;
					return fiber;
				}
			};
		}
		function pushPrimaryTreeSuspenseHandler(handler) {
			var current = handler.alternate;
			push$2(suspenseStackCursor, suspenseStackCursor.current & 1);
			push$2(suspenseHandlerStackCursor, handler);
			null === shellBoundary && (null === current || null !== currentTreeHiddenStackCursor.current ? shellBoundary = handler : null !== current.memoizedState && (shellBoundary = handler));
		}
		function pushOffscreenSuspenseHandler(fiber) {
			if (22 === fiber.tag) {
				if (push$2(suspenseStackCursor, suspenseStackCursor.current), push$2(suspenseHandlerStackCursor, fiber), null === shellBoundary) {
					var current = fiber.alternate;
					null !== current && null !== current.memoizedState && (shellBoundary = fiber);
				}
			} else reuseSuspenseHandlerOnStack(fiber);
		}
		function reuseSuspenseHandlerOnStack() {
			push$2(suspenseStackCursor, suspenseStackCursor.current);
			push$2(suspenseHandlerStackCursor, suspenseHandlerStackCursor.current);
		}
		function popSuspenseHandler(fiber) {
			pop$1(suspenseHandlerStackCursor);
			shellBoundary === fiber && (shellBoundary = null);
			pop$1(suspenseStackCursor);
		}
		function findFirstSuspended(row) {
			for (var node = row; null !== node;) {
				if (13 === node.tag) {
					var state = node.memoizedState;
					if (null !== state && (state = state.dehydrated, null === state || isSuspenseInstancePending(state) || isSuspenseInstanceFallback(state))) return node;
				} else if (19 === node.tag && void 0 !== node.memoizedProps.revealOrder) {
					if (0 !== (node.flags & 128)) return node;
				} else if (null !== node.child) {
					node.child.return = node;
					node = node.child;
					continue;
				}
				if (node === row) break;
				for (; null === node.sibling;) {
					if (null === node.return || node.return === row) return null;
					node = node.return;
				}
				node.sibling.return = node.return;
				node = node.sibling;
			}
			return null;
		}
		function applyDerivedStateFromProps(workInProgress$1, ctor, getDerivedStateFromProps, nextProps) {
			ctor = workInProgress$1.memoizedState;
			getDerivedStateFromProps = getDerivedStateFromProps(nextProps, ctor);
			getDerivedStateFromProps = null === getDerivedStateFromProps || void 0 === getDerivedStateFromProps ? ctor : assign$1({}, ctor, getDerivedStateFromProps);
			workInProgress$1.memoizedState = getDerivedStateFromProps;
			0 === workInProgress$1.lanes && (workInProgress$1.updateQueue.baseState = getDerivedStateFromProps);
		}
		function checkShouldComponentUpdate(workInProgress$1, ctor, oldProps, newProps, oldState, newState, nextContext) {
			workInProgress$1 = workInProgress$1.stateNode;
			return "function" === typeof workInProgress$1.shouldComponentUpdate ? workInProgress$1.shouldComponentUpdate(newProps, newState, nextContext) : ctor.prototype && ctor.prototype.isPureReactComponent ? !shallowEqual(oldProps, newProps) || !shallowEqual(oldState, newState) : !0;
		}
		function callComponentWillReceiveProps(workInProgress$1, instance, newProps, nextContext) {
			workInProgress$1 = instance.state;
			"function" === typeof instance.componentWillReceiveProps && instance.componentWillReceiveProps(newProps, nextContext);
			"function" === typeof instance.UNSAFE_componentWillReceiveProps && instance.UNSAFE_componentWillReceiveProps(newProps, nextContext);
			instance.state !== workInProgress$1 && classComponentUpdater.enqueueReplaceState(instance, instance.state, null);
		}
		function resolveClassComponentProps(Component$1, baseProps) {
			var newProps = baseProps;
			if ("ref" in baseProps) {
				newProps = {};
				for (var propName in baseProps) "ref" !== propName && (newProps[propName] = baseProps[propName]);
			}
			if (Component$1 = Component$1.defaultProps) {
				newProps === baseProps && (newProps = assign$1({}, newProps));
				for (var propName$57 in Component$1) void 0 === newProps[propName$57] && (newProps[propName$57] = Component$1[propName$57]);
			}
			return newProps;
		}
		function logUncaughtError(root, errorInfo) {
			try {
				var onUncaughtError = root.onUncaughtError;
				onUncaughtError(errorInfo.value, { componentStack: errorInfo.stack });
			} catch (e) {
				setTimeout(function() {
					throw e;
				});
			}
		}
		function logCaughtError(root, boundary, errorInfo) {
			try {
				var onCaughtError = root.onCaughtError;
				onCaughtError(errorInfo.value, {
					componentStack: errorInfo.stack,
					errorBoundary: 1 === boundary.tag ? boundary.stateNode : null
				});
			} catch (e) {
				setTimeout(function() {
					throw e;
				});
			}
		}
		function createRootErrorUpdate(root, errorInfo, lane) {
			lane = createUpdate(lane);
			lane.tag = 3;
			lane.payload = { element: null };
			lane.callback = function() {
				logUncaughtError(root, errorInfo);
			};
			return lane;
		}
		function createClassErrorUpdate(lane) {
			lane = createUpdate(lane);
			lane.tag = 3;
			return lane;
		}
		function initializeClassErrorUpdate(update, root, fiber, errorInfo) {
			var getDerivedStateFromError = fiber.type.getDerivedStateFromError;
			if ("function" === typeof getDerivedStateFromError) {
				var error = errorInfo.value;
				update.payload = function() {
					return getDerivedStateFromError(error);
				};
				update.callback = function() {
					logCaughtError(root, fiber, errorInfo);
				};
			}
			var inst = fiber.stateNode;
			null !== inst && "function" === typeof inst.componentDidCatch && (update.callback = function() {
				logCaughtError(root, fiber, errorInfo);
				"function" !== typeof getDerivedStateFromError && (null === legacyErrorBoundariesThatAlreadyFailed ? legacyErrorBoundariesThatAlreadyFailed = new Set([this]) : legacyErrorBoundariesThatAlreadyFailed.add(this));
				var stack = errorInfo.stack;
				this.componentDidCatch(errorInfo.value, { componentStack: null !== stack ? stack : "" });
			});
		}
		function throwException(root, returnFiber, sourceFiber, value, rootRenderLanes) {
			sourceFiber.flags |= 32768;
			if (null !== value && "object" === typeof value && "function" === typeof value.then) {
				returnFiber = sourceFiber.alternate;
				null !== returnFiber && propagateParentContextChanges(returnFiber, sourceFiber, rootRenderLanes, !0);
				sourceFiber = suspenseHandlerStackCursor.current;
				if (null !== sourceFiber) {
					switch (sourceFiber.tag) {
						case 13: return null === shellBoundary ? renderDidSuspendDelayIfPossible() : null === sourceFiber.alternate && 0 === workInProgressRootExitStatus && (workInProgressRootExitStatus = 3), sourceFiber.flags &= -257, sourceFiber.flags |= 65536, sourceFiber.lanes = rootRenderLanes, value === noopSuspenseyCommitThenable ? sourceFiber.flags |= 16384 : (returnFiber = sourceFiber.updateQueue, null === returnFiber ? sourceFiber.updateQueue = new Set([value]) : returnFiber.add(value), attachPingListener(root, value, rootRenderLanes)), !1;
						case 22: return sourceFiber.flags |= 65536, value === noopSuspenseyCommitThenable ? sourceFiber.flags |= 16384 : (returnFiber = sourceFiber.updateQueue, null === returnFiber ? (returnFiber = {
							transitions: null,
							markerInstances: null,
							retryQueue: new Set([value])
						}, sourceFiber.updateQueue = returnFiber) : (sourceFiber = returnFiber.retryQueue, null === sourceFiber ? returnFiber.retryQueue = new Set([value]) : sourceFiber.add(value)), attachPingListener(root, value, rootRenderLanes)), !1;
					}
					throw Error(formatProdErrorMessage(435, sourceFiber.tag));
				}
				attachPingListener(root, value, rootRenderLanes);
				renderDidSuspendDelayIfPossible();
				return !1;
			}
			if (isHydrating) return returnFiber = suspenseHandlerStackCursor.current, null !== returnFiber ? (0 === (returnFiber.flags & 65536) && (returnFiber.flags |= 256), returnFiber.flags |= 65536, returnFiber.lanes = rootRenderLanes, value !== HydrationMismatchException && (root = Error(formatProdErrorMessage(422), { cause: value }), queueHydrationError(createCapturedValueAtFiber(root, sourceFiber)))) : (value !== HydrationMismatchException && (returnFiber = Error(formatProdErrorMessage(423), { cause: value }), queueHydrationError(createCapturedValueAtFiber(returnFiber, sourceFiber))), root = root.current.alternate, root.flags |= 65536, rootRenderLanes &= -rootRenderLanes, root.lanes |= rootRenderLanes, value = createCapturedValueAtFiber(value, sourceFiber), rootRenderLanes = createRootErrorUpdate(root.stateNode, value, rootRenderLanes), enqueueCapturedUpdate(root, rootRenderLanes), 4 !== workInProgressRootExitStatus && (workInProgressRootExitStatus = 2)), !1;
			var wrapperError = Error(formatProdErrorMessage(520), { cause: value });
			wrapperError = createCapturedValueAtFiber(wrapperError, sourceFiber);
			null === workInProgressRootConcurrentErrors ? workInProgressRootConcurrentErrors = [wrapperError] : workInProgressRootConcurrentErrors.push(wrapperError);
			4 !== workInProgressRootExitStatus && (workInProgressRootExitStatus = 2);
			if (null === returnFiber) return !0;
			value = createCapturedValueAtFiber(value, sourceFiber);
			sourceFiber = returnFiber;
			do {
				switch (sourceFiber.tag) {
					case 3: return sourceFiber.flags |= 65536, root = rootRenderLanes & -rootRenderLanes, sourceFiber.lanes |= root, root = createRootErrorUpdate(sourceFiber.stateNode, value, root), enqueueCapturedUpdate(sourceFiber, root), !1;
					case 1: if (returnFiber = sourceFiber.type, wrapperError = sourceFiber.stateNode, 0 === (sourceFiber.flags & 128) && ("function" === typeof returnFiber.getDerivedStateFromError || null !== wrapperError && "function" === typeof wrapperError.componentDidCatch && (null === legacyErrorBoundariesThatAlreadyFailed || !legacyErrorBoundariesThatAlreadyFailed.has(wrapperError)))) return sourceFiber.flags |= 65536, rootRenderLanes &= -rootRenderLanes, sourceFiber.lanes |= rootRenderLanes, rootRenderLanes = createClassErrorUpdate(rootRenderLanes), initializeClassErrorUpdate(rootRenderLanes, root, sourceFiber, value), enqueueCapturedUpdate(sourceFiber, rootRenderLanes), !1;
				}
				sourceFiber = sourceFiber.return;
			} while (null !== sourceFiber);
			return !1;
		}
		function reconcileChildren(current, workInProgress$1, nextChildren, renderLanes$1) {
			workInProgress$1.child = null === current ? mountChildFibers(workInProgress$1, null, nextChildren, renderLanes$1) : reconcileChildFibers(workInProgress$1, current.child, nextChildren, renderLanes$1);
		}
		function updateForwardRef(current, workInProgress$1, Component$1, nextProps, renderLanes$1) {
			Component$1 = Component$1.render;
			var ref = workInProgress$1.ref;
			if ("ref" in nextProps) {
				var propsWithoutRef = {};
				for (var key in nextProps) "ref" !== key && (propsWithoutRef[key] = nextProps[key]);
			} else propsWithoutRef = nextProps;
			prepareToReadContext(workInProgress$1);
			nextProps = renderWithHooks(current, workInProgress$1, Component$1, propsWithoutRef, ref, renderLanes$1);
			key = checkDidRenderIdHook();
			if (null !== current && !didReceiveUpdate) return bailoutHooks(current, workInProgress$1, renderLanes$1), bailoutOnAlreadyFinishedWork(current, workInProgress$1, renderLanes$1);
			isHydrating && key && pushMaterializedTreeId(workInProgress$1);
			workInProgress$1.flags |= 1;
			reconcileChildren(current, workInProgress$1, nextProps, renderLanes$1);
			return workInProgress$1.child;
		}
		function updateMemoComponent(current, workInProgress$1, Component$1, nextProps, renderLanes$1) {
			if (null === current) {
				var type = Component$1.type;
				if ("function" === typeof type && !shouldConstruct(type) && void 0 === type.defaultProps && null === Component$1.compare) return workInProgress$1.tag = 15, workInProgress$1.type = type, updateSimpleMemoComponent(current, workInProgress$1, type, nextProps, renderLanes$1);
				current = createFiberFromTypeAndProps(Component$1.type, null, nextProps, workInProgress$1, workInProgress$1.mode, renderLanes$1);
				current.ref = workInProgress$1.ref;
				current.return = workInProgress$1;
				return workInProgress$1.child = current;
			}
			type = current.child;
			if (!checkScheduledUpdateOrContext(current, renderLanes$1)) {
				var prevProps = type.memoizedProps;
				Component$1 = Component$1.compare;
				Component$1 = null !== Component$1 ? Component$1 : shallowEqual;
				if (Component$1(prevProps, nextProps) && current.ref === workInProgress$1.ref) return bailoutOnAlreadyFinishedWork(current, workInProgress$1, renderLanes$1);
			}
			workInProgress$1.flags |= 1;
			current = createWorkInProgress(type, nextProps);
			current.ref = workInProgress$1.ref;
			current.return = workInProgress$1;
			return workInProgress$1.child = current;
		}
		function updateSimpleMemoComponent(current, workInProgress$1, Component$1, nextProps, renderLanes$1) {
			if (null !== current) {
				var prevProps = current.memoizedProps;
				if (shallowEqual(prevProps, nextProps) && current.ref === workInProgress$1.ref) if (didReceiveUpdate = !1, workInProgress$1.pendingProps = nextProps = prevProps, checkScheduledUpdateOrContext(current, renderLanes$1)) 0 !== (current.flags & 131072) && (didReceiveUpdate = !0);
				else return workInProgress$1.lanes = current.lanes, bailoutOnAlreadyFinishedWork(current, workInProgress$1, renderLanes$1);
			}
			return updateFunctionComponent(current, workInProgress$1, Component$1, nextProps, renderLanes$1);
		}
		function updateOffscreenComponent(current, workInProgress$1, renderLanes$1) {
			var nextProps = workInProgress$1.pendingProps, nextChildren = nextProps.children, prevState = null !== current ? current.memoizedState : null;
			if ("hidden" === nextProps.mode) {
				if (0 !== (workInProgress$1.flags & 128)) {
					nextProps = null !== prevState ? prevState.baseLanes | renderLanes$1 : renderLanes$1;
					if (null !== current) {
						nextChildren = workInProgress$1.child = current.child;
						for (prevState = 0; null !== nextChildren;) prevState = prevState | nextChildren.lanes | nextChildren.childLanes, nextChildren = nextChildren.sibling;
						workInProgress$1.childLanes = prevState & ~nextProps;
					} else workInProgress$1.childLanes = 0, workInProgress$1.child = null;
					return deferHiddenOffscreenComponent(current, workInProgress$1, nextProps, renderLanes$1);
				}
				if (0 !== (renderLanes$1 & 536870912)) workInProgress$1.memoizedState = {
					baseLanes: 0,
					cachePool: null
				}, null !== current && pushTransition(workInProgress$1, null !== prevState ? prevState.cachePool : null), null !== prevState ? pushHiddenContext(workInProgress$1, prevState) : reuseHiddenContextOnStack(), pushOffscreenSuspenseHandler(workInProgress$1);
				else return workInProgress$1.lanes = workInProgress$1.childLanes = 536870912, deferHiddenOffscreenComponent(current, workInProgress$1, null !== prevState ? prevState.baseLanes | renderLanes$1 : renderLanes$1, renderLanes$1);
			} else null !== prevState ? (pushTransition(workInProgress$1, prevState.cachePool), pushHiddenContext(workInProgress$1, prevState), reuseSuspenseHandlerOnStack(workInProgress$1), workInProgress$1.memoizedState = null) : (null !== current && pushTransition(workInProgress$1, null), reuseHiddenContextOnStack(), reuseSuspenseHandlerOnStack(workInProgress$1));
			reconcileChildren(current, workInProgress$1, nextChildren, renderLanes$1);
			return workInProgress$1.child;
		}
		function deferHiddenOffscreenComponent(current, workInProgress$1, nextBaseLanes, renderLanes$1) {
			var JSCompiler_inline_result = peekCacheFromPool();
			JSCompiler_inline_result = null === JSCompiler_inline_result ? null : {
				parent: isPrimaryRenderer ? CacheContext._currentValue : CacheContext._currentValue2,
				pool: JSCompiler_inline_result
			};
			workInProgress$1.memoizedState = {
				baseLanes: nextBaseLanes,
				cachePool: JSCompiler_inline_result
			};
			null !== current && pushTransition(workInProgress$1, null);
			reuseHiddenContextOnStack();
			pushOffscreenSuspenseHandler(workInProgress$1);
			null !== current && propagateParentContextChanges(current, workInProgress$1, renderLanes$1, !0);
			return null;
		}
		function markRef(current, workInProgress$1) {
			var ref = workInProgress$1.ref;
			if (null === ref) null !== current && null !== current.ref && (workInProgress$1.flags |= 4194816);
			else {
				if ("function" !== typeof ref && "object" !== typeof ref) throw Error(formatProdErrorMessage(284));
				if (null === current || current.ref !== ref) workInProgress$1.flags |= 4194816;
			}
		}
		function updateFunctionComponent(current, workInProgress$1, Component$1, nextProps, renderLanes$1) {
			prepareToReadContext(workInProgress$1);
			Component$1 = renderWithHooks(current, workInProgress$1, Component$1, nextProps, void 0, renderLanes$1);
			nextProps = checkDidRenderIdHook();
			if (null !== current && !didReceiveUpdate) return bailoutHooks(current, workInProgress$1, renderLanes$1), bailoutOnAlreadyFinishedWork(current, workInProgress$1, renderLanes$1);
			isHydrating && nextProps && pushMaterializedTreeId(workInProgress$1);
			workInProgress$1.flags |= 1;
			reconcileChildren(current, workInProgress$1, Component$1, renderLanes$1);
			return workInProgress$1.child;
		}
		function replayFunctionComponent(current, workInProgress$1, nextProps, Component$1, secondArg, renderLanes$1) {
			prepareToReadContext(workInProgress$1);
			workInProgress$1.updateQueue = null;
			nextProps = renderWithHooksAgain(workInProgress$1, Component$1, nextProps, secondArg);
			finishRenderingHooks(current);
			Component$1 = checkDidRenderIdHook();
			if (null !== current && !didReceiveUpdate) return bailoutHooks(current, workInProgress$1, renderLanes$1), bailoutOnAlreadyFinishedWork(current, workInProgress$1, renderLanes$1);
			isHydrating && Component$1 && pushMaterializedTreeId(workInProgress$1);
			workInProgress$1.flags |= 1;
			reconcileChildren(current, workInProgress$1, nextProps, renderLanes$1);
			return workInProgress$1.child;
		}
		function updateClassComponent(current, workInProgress$1, Component$1, nextProps, renderLanes$1) {
			prepareToReadContext(workInProgress$1);
			if (null === workInProgress$1.stateNode) {
				var context = emptyContextObject, contextType = Component$1.contextType;
				"object" === typeof contextType && null !== contextType && (context = readContext(contextType));
				context = new Component$1(nextProps, context);
				workInProgress$1.memoizedState = null !== context.state && void 0 !== context.state ? context.state : null;
				context.updater = classComponentUpdater;
				workInProgress$1.stateNode = context;
				context._reactInternals = workInProgress$1;
				context = workInProgress$1.stateNode;
				context.props = nextProps;
				context.state = workInProgress$1.memoizedState;
				context.refs = {};
				initializeUpdateQueue(workInProgress$1);
				contextType = Component$1.contextType;
				context.context = "object" === typeof contextType && null !== contextType ? readContext(contextType) : emptyContextObject;
				context.state = workInProgress$1.memoizedState;
				contextType = Component$1.getDerivedStateFromProps;
				"function" === typeof contextType && (applyDerivedStateFromProps(workInProgress$1, Component$1, contextType, nextProps), context.state = workInProgress$1.memoizedState);
				"function" === typeof Component$1.getDerivedStateFromProps || "function" === typeof context.getSnapshotBeforeUpdate || "function" !== typeof context.UNSAFE_componentWillMount && "function" !== typeof context.componentWillMount || (contextType = context.state, "function" === typeof context.componentWillMount && context.componentWillMount(), "function" === typeof context.UNSAFE_componentWillMount && context.UNSAFE_componentWillMount(), contextType !== context.state && classComponentUpdater.enqueueReplaceState(context, context.state, null), processUpdateQueue(workInProgress$1, nextProps, context, renderLanes$1), suspendIfUpdateReadFromEntangledAsyncAction(), context.state = workInProgress$1.memoizedState);
				"function" === typeof context.componentDidMount && (workInProgress$1.flags |= 4194308);
				nextProps = !0;
			} else if (null === current) {
				context = workInProgress$1.stateNode;
				var unresolvedOldProps = workInProgress$1.memoizedProps, oldProps = resolveClassComponentProps(Component$1, unresolvedOldProps);
				context.props = oldProps;
				var oldContext = context.context, contextType$jscomp$0 = Component$1.contextType;
				contextType = emptyContextObject;
				"object" === typeof contextType$jscomp$0 && null !== contextType$jscomp$0 && (contextType = readContext(contextType$jscomp$0));
				var getDerivedStateFromProps = Component$1.getDerivedStateFromProps;
				contextType$jscomp$0 = "function" === typeof getDerivedStateFromProps || "function" === typeof context.getSnapshotBeforeUpdate;
				unresolvedOldProps = workInProgress$1.pendingProps !== unresolvedOldProps;
				contextType$jscomp$0 || "function" !== typeof context.UNSAFE_componentWillReceiveProps && "function" !== typeof context.componentWillReceiveProps || (unresolvedOldProps || oldContext !== contextType) && callComponentWillReceiveProps(workInProgress$1, context, nextProps, contextType);
				hasForceUpdate = !1;
				var oldState = workInProgress$1.memoizedState;
				context.state = oldState;
				processUpdateQueue(workInProgress$1, nextProps, context, renderLanes$1);
				suspendIfUpdateReadFromEntangledAsyncAction();
				oldContext = workInProgress$1.memoizedState;
				unresolvedOldProps || oldState !== oldContext || hasForceUpdate ? ("function" === typeof getDerivedStateFromProps && (applyDerivedStateFromProps(workInProgress$1, Component$1, getDerivedStateFromProps, nextProps), oldContext = workInProgress$1.memoizedState), (oldProps = hasForceUpdate || checkShouldComponentUpdate(workInProgress$1, Component$1, oldProps, nextProps, oldState, oldContext, contextType)) ? (contextType$jscomp$0 || "function" !== typeof context.UNSAFE_componentWillMount && "function" !== typeof context.componentWillMount || ("function" === typeof context.componentWillMount && context.componentWillMount(), "function" === typeof context.UNSAFE_componentWillMount && context.UNSAFE_componentWillMount()), "function" === typeof context.componentDidMount && (workInProgress$1.flags |= 4194308)) : ("function" === typeof context.componentDidMount && (workInProgress$1.flags |= 4194308), workInProgress$1.memoizedProps = nextProps, workInProgress$1.memoizedState = oldContext), context.props = nextProps, context.state = oldContext, context.context = contextType, nextProps = oldProps) : ("function" === typeof context.componentDidMount && (workInProgress$1.flags |= 4194308), nextProps = !1);
			} else {
				context = workInProgress$1.stateNode;
				cloneUpdateQueue(current, workInProgress$1);
				contextType = workInProgress$1.memoizedProps;
				contextType$jscomp$0 = resolveClassComponentProps(Component$1, contextType);
				context.props = contextType$jscomp$0;
				getDerivedStateFromProps = workInProgress$1.pendingProps;
				oldState = context.context;
				oldContext = Component$1.contextType;
				oldProps = emptyContextObject;
				"object" === typeof oldContext && null !== oldContext && (oldProps = readContext(oldContext));
				unresolvedOldProps = Component$1.getDerivedStateFromProps;
				(oldContext = "function" === typeof unresolvedOldProps || "function" === typeof context.getSnapshotBeforeUpdate) || "function" !== typeof context.UNSAFE_componentWillReceiveProps && "function" !== typeof context.componentWillReceiveProps || (contextType !== getDerivedStateFromProps || oldState !== oldProps) && callComponentWillReceiveProps(workInProgress$1, context, nextProps, oldProps);
				hasForceUpdate = !1;
				oldState = workInProgress$1.memoizedState;
				context.state = oldState;
				processUpdateQueue(workInProgress$1, nextProps, context, renderLanes$1);
				suspendIfUpdateReadFromEntangledAsyncAction();
				var newState = workInProgress$1.memoizedState;
				contextType !== getDerivedStateFromProps || oldState !== newState || hasForceUpdate || null !== current && null !== current.dependencies && checkIfContextChanged(current.dependencies) ? ("function" === typeof unresolvedOldProps && (applyDerivedStateFromProps(workInProgress$1, Component$1, unresolvedOldProps, nextProps), newState = workInProgress$1.memoizedState), (contextType$jscomp$0 = hasForceUpdate || checkShouldComponentUpdate(workInProgress$1, Component$1, contextType$jscomp$0, nextProps, oldState, newState, oldProps) || null !== current && null !== current.dependencies && checkIfContextChanged(current.dependencies)) ? (oldContext || "function" !== typeof context.UNSAFE_componentWillUpdate && "function" !== typeof context.componentWillUpdate || ("function" === typeof context.componentWillUpdate && context.componentWillUpdate(nextProps, newState, oldProps), "function" === typeof context.UNSAFE_componentWillUpdate && context.UNSAFE_componentWillUpdate(nextProps, newState, oldProps)), "function" === typeof context.componentDidUpdate && (workInProgress$1.flags |= 4), "function" === typeof context.getSnapshotBeforeUpdate && (workInProgress$1.flags |= 1024)) : ("function" !== typeof context.componentDidUpdate || contextType === current.memoizedProps && oldState === current.memoizedState || (workInProgress$1.flags |= 4), "function" !== typeof context.getSnapshotBeforeUpdate || contextType === current.memoizedProps && oldState === current.memoizedState || (workInProgress$1.flags |= 1024), workInProgress$1.memoizedProps = nextProps, workInProgress$1.memoizedState = newState), context.props = nextProps, context.state = newState, context.context = oldProps, nextProps = contextType$jscomp$0) : ("function" !== typeof context.componentDidUpdate || contextType === current.memoizedProps && oldState === current.memoizedState || (workInProgress$1.flags |= 4), "function" !== typeof context.getSnapshotBeforeUpdate || contextType === current.memoizedProps && oldState === current.memoizedState || (workInProgress$1.flags |= 1024), nextProps = !1);
			}
			context = nextProps;
			markRef(current, workInProgress$1);
			nextProps = 0 !== (workInProgress$1.flags & 128);
			context || nextProps ? (context = workInProgress$1.stateNode, Component$1 = nextProps && "function" !== typeof Component$1.getDerivedStateFromError ? null : context.render(), workInProgress$1.flags |= 1, null !== current && nextProps ? (workInProgress$1.child = reconcileChildFibers(workInProgress$1, current.child, null, renderLanes$1), workInProgress$1.child = reconcileChildFibers(workInProgress$1, null, Component$1, renderLanes$1)) : reconcileChildren(current, workInProgress$1, Component$1, renderLanes$1), workInProgress$1.memoizedState = context.state, current = workInProgress$1.child) : current = bailoutOnAlreadyFinishedWork(current, workInProgress$1, renderLanes$1);
			return current;
		}
		function mountHostRootWithoutHydrating(current, workInProgress$1, nextChildren, renderLanes$1) {
			resetHydrationState();
			workInProgress$1.flags |= 256;
			reconcileChildren(current, workInProgress$1, nextChildren, renderLanes$1);
			return workInProgress$1.child;
		}
		function mountSuspenseOffscreenState(renderLanes$1) {
			return {
				baseLanes: renderLanes$1,
				cachePool: getSuspendedCache()
			};
		}
		function getRemainingWorkInPrimaryTree(current, primaryTreeDidDefer, renderLanes$1) {
			current = null !== current ? current.childLanes & ~renderLanes$1 : 0;
			primaryTreeDidDefer && (current |= workInProgressDeferredLane);
			return current;
		}
		function updateSuspenseComponent(current, workInProgress$1, renderLanes$1) {
			var nextProps = workInProgress$1.pendingProps, showFallback = !1, didSuspend = 0 !== (workInProgress$1.flags & 128), JSCompiler_temp;
			(JSCompiler_temp = didSuspend) || (JSCompiler_temp = null !== current && null === current.memoizedState ? !1 : 0 !== (suspenseStackCursor.current & 2));
			JSCompiler_temp && (showFallback = !0, workInProgress$1.flags &= -129);
			JSCompiler_temp = 0 !== (workInProgress$1.flags & 32);
			workInProgress$1.flags &= -33;
			if (null === current) {
				if (isHydrating) {
					showFallback ? pushPrimaryTreeSuspenseHandler(workInProgress$1) : reuseSuspenseHandlerOnStack(workInProgress$1);
					if (isHydrating) {
						var nextInstance = nextHydratableInstance, JSCompiler_temp$jscomp$0;
						if (JSCompiler_temp$jscomp$0 = nextInstance) nextInstance = canHydrateSuspenseInstance(nextInstance, rootOrSingletonContext), null !== nextInstance ? (workInProgress$1.memoizedState = {
							dehydrated: nextInstance,
							treeContext: null !== treeContextProvider ? {
								id: treeContextId,
								overflow: treeContextOverflow
							} : null,
							retryLane: 536870912,
							hydrationErrors: null
						}, JSCompiler_temp$jscomp$0 = createFiber(18, null, null, 0), JSCompiler_temp$jscomp$0.stateNode = nextInstance, JSCompiler_temp$jscomp$0.return = workInProgress$1, workInProgress$1.child = JSCompiler_temp$jscomp$0, hydrationParentFiber = workInProgress$1, nextHydratableInstance = null, JSCompiler_temp$jscomp$0 = !0) : JSCompiler_temp$jscomp$0 = !1;
						JSCompiler_temp$jscomp$0 || throwOnHydrationMismatch(workInProgress$1);
					}
					nextInstance = workInProgress$1.memoizedState;
					if (null !== nextInstance && (nextInstance = nextInstance.dehydrated, null !== nextInstance)) return isSuspenseInstanceFallback(nextInstance) ? workInProgress$1.lanes = 32 : workInProgress$1.lanes = 536870912, null;
					popSuspenseHandler(workInProgress$1);
				}
				nextInstance = nextProps.children;
				nextProps = nextProps.fallback;
				if (showFallback) return reuseSuspenseHandlerOnStack(workInProgress$1), showFallback = workInProgress$1.mode, nextInstance = mountWorkInProgressOffscreenFiber({
					mode: "hidden",
					children: nextInstance
				}, showFallback), nextProps = createFiberFromFragment(nextProps, showFallback, renderLanes$1, null), nextInstance.return = workInProgress$1, nextProps.return = workInProgress$1, nextInstance.sibling = nextProps, workInProgress$1.child = nextInstance, showFallback = workInProgress$1.child, showFallback.memoizedState = mountSuspenseOffscreenState(renderLanes$1), showFallback.childLanes = getRemainingWorkInPrimaryTree(current, JSCompiler_temp, renderLanes$1), workInProgress$1.memoizedState = SUSPENDED_MARKER, nextProps;
				pushPrimaryTreeSuspenseHandler(workInProgress$1);
				return mountSuspensePrimaryChildren(workInProgress$1, nextInstance);
			}
			JSCompiler_temp$jscomp$0 = current.memoizedState;
			if (null !== JSCompiler_temp$jscomp$0 && (nextInstance = JSCompiler_temp$jscomp$0.dehydrated, null !== nextInstance)) {
				if (didSuspend) workInProgress$1.flags & 256 ? (pushPrimaryTreeSuspenseHandler(workInProgress$1), workInProgress$1.flags &= -257, workInProgress$1 = retrySuspenseComponentWithoutHydrating(current, workInProgress$1, renderLanes$1)) : null !== workInProgress$1.memoizedState ? (reuseSuspenseHandlerOnStack(workInProgress$1), workInProgress$1.child = current.child, workInProgress$1.flags |= 128, workInProgress$1 = null) : (reuseSuspenseHandlerOnStack(workInProgress$1), showFallback = nextProps.fallback, nextInstance = workInProgress$1.mode, nextProps = mountWorkInProgressOffscreenFiber({
					mode: "visible",
					children: nextProps.children
				}, nextInstance), showFallback = createFiberFromFragment(showFallback, nextInstance, renderLanes$1, null), showFallback.flags |= 2, nextProps.return = workInProgress$1, showFallback.return = workInProgress$1, nextProps.sibling = showFallback, workInProgress$1.child = nextProps, reconcileChildFibers(workInProgress$1, current.child, null, renderLanes$1), nextProps = workInProgress$1.child, nextProps.memoizedState = mountSuspenseOffscreenState(renderLanes$1), nextProps.childLanes = getRemainingWorkInPrimaryTree(current, JSCompiler_temp, renderLanes$1), workInProgress$1.memoizedState = SUSPENDED_MARKER, workInProgress$1 = showFallback);
				else if (pushPrimaryTreeSuspenseHandler(workInProgress$1), isSuspenseInstanceFallback(nextInstance)) JSCompiler_temp = getSuspenseInstanceFallbackErrorDetails(nextInstance).digest, nextProps = Error(formatProdErrorMessage(419)), nextProps.stack = "", nextProps.digest = JSCompiler_temp, queueHydrationError({
					value: nextProps,
					source: null,
					stack: null
				}), workInProgress$1 = retrySuspenseComponentWithoutHydrating(current, workInProgress$1, renderLanes$1);
				else if (didReceiveUpdate || propagateParentContextChanges(current, workInProgress$1, renderLanes$1, !1), JSCompiler_temp = 0 !== (renderLanes$1 & current.childLanes), didReceiveUpdate || JSCompiler_temp) {
					JSCompiler_temp = workInProgressRoot;
					if (null !== JSCompiler_temp && (nextProps = renderLanes$1 & -renderLanes$1, nextProps = 0 !== (nextProps & 42) ? 1 : getBumpedLaneForHydrationByLane(nextProps), nextProps = 0 !== (nextProps & (JSCompiler_temp.suspendedLanes | renderLanes$1)) ? 0 : nextProps, 0 !== nextProps && nextProps !== JSCompiler_temp$jscomp$0.retryLane)) throw JSCompiler_temp$jscomp$0.retryLane = nextProps, enqueueConcurrentRenderForLane(current, nextProps), scheduleUpdateOnFiber(JSCompiler_temp, current, nextProps), SelectiveHydrationException;
					isSuspenseInstancePending(nextInstance) || renderDidSuspendDelayIfPossible();
					workInProgress$1 = retrySuspenseComponentWithoutHydrating(current, workInProgress$1, renderLanes$1);
				} else isSuspenseInstancePending(nextInstance) ? (workInProgress$1.flags |= 192, workInProgress$1.child = current.child, workInProgress$1 = null) : (current = JSCompiler_temp$jscomp$0.treeContext, supportsHydration && (nextHydratableInstance = getFirstHydratableChildWithinSuspenseInstance(nextInstance), hydrationParentFiber = workInProgress$1, isHydrating = !0, hydrationErrors = null, rootOrSingletonContext = !1, null !== current && (idStack[idStackIndex++] = treeContextId, idStack[idStackIndex++] = treeContextOverflow, idStack[idStackIndex++] = treeContextProvider, treeContextId = current.id, treeContextOverflow = current.overflow, treeContextProvider = workInProgress$1)), workInProgress$1 = mountSuspensePrimaryChildren(workInProgress$1, nextProps.children), workInProgress$1.flags |= 4096);
				return workInProgress$1;
			}
			if (showFallback) return reuseSuspenseHandlerOnStack(workInProgress$1), showFallback = nextProps.fallback, nextInstance = workInProgress$1.mode, JSCompiler_temp$jscomp$0 = current.child, didSuspend = JSCompiler_temp$jscomp$0.sibling, nextProps = createWorkInProgress(JSCompiler_temp$jscomp$0, {
				mode: "hidden",
				children: nextProps.children
			}), nextProps.subtreeFlags = JSCompiler_temp$jscomp$0.subtreeFlags & 65011712, null !== didSuspend ? showFallback = createWorkInProgress(didSuspend, showFallback) : (showFallback = createFiberFromFragment(showFallback, nextInstance, renderLanes$1, null), showFallback.flags |= 2), showFallback.return = workInProgress$1, nextProps.return = workInProgress$1, nextProps.sibling = showFallback, workInProgress$1.child = nextProps, nextProps = showFallback, showFallback = workInProgress$1.child, nextInstance = current.child.memoizedState, null === nextInstance ? nextInstance = mountSuspenseOffscreenState(renderLanes$1) : (JSCompiler_temp$jscomp$0 = nextInstance.cachePool, null !== JSCompiler_temp$jscomp$0 ? (didSuspend = isPrimaryRenderer ? CacheContext._currentValue : CacheContext._currentValue2, JSCompiler_temp$jscomp$0 = JSCompiler_temp$jscomp$0.parent !== didSuspend ? {
				parent: didSuspend,
				pool: didSuspend
			} : JSCompiler_temp$jscomp$0) : JSCompiler_temp$jscomp$0 = getSuspendedCache(), nextInstance = {
				baseLanes: nextInstance.baseLanes | renderLanes$1,
				cachePool: JSCompiler_temp$jscomp$0
			}), showFallback.memoizedState = nextInstance, showFallback.childLanes = getRemainingWorkInPrimaryTree(current, JSCompiler_temp, renderLanes$1), workInProgress$1.memoizedState = SUSPENDED_MARKER, nextProps;
			pushPrimaryTreeSuspenseHandler(workInProgress$1);
			renderLanes$1 = current.child;
			current = renderLanes$1.sibling;
			renderLanes$1 = createWorkInProgress(renderLanes$1, {
				mode: "visible",
				children: nextProps.children
			});
			renderLanes$1.return = workInProgress$1;
			renderLanes$1.sibling = null;
			null !== current && (JSCompiler_temp = workInProgress$1.deletions, null === JSCompiler_temp ? (workInProgress$1.deletions = [current], workInProgress$1.flags |= 16) : JSCompiler_temp.push(current));
			workInProgress$1.child = renderLanes$1;
			workInProgress$1.memoizedState = null;
			return renderLanes$1;
		}
		function mountSuspensePrimaryChildren(workInProgress$1, primaryChildren) {
			primaryChildren = mountWorkInProgressOffscreenFiber({
				mode: "visible",
				children: primaryChildren
			}, workInProgress$1.mode);
			primaryChildren.return = workInProgress$1;
			return workInProgress$1.child = primaryChildren;
		}
		function mountWorkInProgressOffscreenFiber(offscreenProps, mode) {
			offscreenProps = createFiber(22, offscreenProps, null, mode);
			offscreenProps.lanes = 0;
			offscreenProps.stateNode = {
				_visibility: 1,
				_pendingMarkers: null,
				_retryCache: null,
				_transitions: null
			};
			return offscreenProps;
		}
		function retrySuspenseComponentWithoutHydrating(current, workInProgress$1, renderLanes$1) {
			reconcileChildFibers(workInProgress$1, current.child, null, renderLanes$1);
			current = mountSuspensePrimaryChildren(workInProgress$1, workInProgress$1.pendingProps.children);
			current.flags |= 2;
			workInProgress$1.memoizedState = null;
			return current;
		}
		function scheduleSuspenseWorkOnFiber(fiber, renderLanes$1, propagationRoot) {
			fiber.lanes |= renderLanes$1;
			var alternate = fiber.alternate;
			null !== alternate && (alternate.lanes |= renderLanes$1);
			scheduleContextWorkOnParentPath(fiber.return, renderLanes$1, propagationRoot);
		}
		function initSuspenseListRenderState(workInProgress$1, isBackwards, tail, lastContentRow, tailMode) {
			var renderState = workInProgress$1.memoizedState;
			null === renderState ? workInProgress$1.memoizedState = {
				isBackwards,
				rendering: null,
				renderingStartTime: 0,
				last: lastContentRow,
				tail,
				tailMode
			} : (renderState.isBackwards = isBackwards, renderState.rendering = null, renderState.renderingStartTime = 0, renderState.last = lastContentRow, renderState.tail = tail, renderState.tailMode = tailMode);
		}
		function updateSuspenseListComponent(current, workInProgress$1, renderLanes$1) {
			var nextProps = workInProgress$1.pendingProps, revealOrder = nextProps.revealOrder, tailMode = nextProps.tail;
			reconcileChildren(current, workInProgress$1, nextProps.children, renderLanes$1);
			nextProps = suspenseStackCursor.current;
			if (0 !== (nextProps & 2)) nextProps = nextProps & 1 | 2, workInProgress$1.flags |= 128;
			else {
				if (null !== current && 0 !== (current.flags & 128)) a: for (current = workInProgress$1.child; null !== current;) {
					if (13 === current.tag) null !== current.memoizedState && scheduleSuspenseWorkOnFiber(current, renderLanes$1, workInProgress$1);
					else if (19 === current.tag) scheduleSuspenseWorkOnFiber(current, renderLanes$1, workInProgress$1);
					else if (null !== current.child) {
						current.child.return = current;
						current = current.child;
						continue;
					}
					if (current === workInProgress$1) break a;
					for (; null === current.sibling;) {
						if (null === current.return || current.return === workInProgress$1) break a;
						current = current.return;
					}
					current.sibling.return = current.return;
					current = current.sibling;
				}
				nextProps &= 1;
			}
			push$2(suspenseStackCursor, nextProps);
			switch (revealOrder) {
				case "forwards":
					renderLanes$1 = workInProgress$1.child;
					for (revealOrder = null; null !== renderLanes$1;) current = renderLanes$1.alternate, null !== current && null === findFirstSuspended(current) && (revealOrder = renderLanes$1), renderLanes$1 = renderLanes$1.sibling;
					renderLanes$1 = revealOrder;
					null === renderLanes$1 ? (revealOrder = workInProgress$1.child, workInProgress$1.child = null) : (revealOrder = renderLanes$1.sibling, renderLanes$1.sibling = null);
					initSuspenseListRenderState(workInProgress$1, !1, revealOrder, renderLanes$1, tailMode);
					break;
				case "backwards":
					renderLanes$1 = null;
					revealOrder = workInProgress$1.child;
					for (workInProgress$1.child = null; null !== revealOrder;) {
						current = revealOrder.alternate;
						if (null !== current && null === findFirstSuspended(current)) {
							workInProgress$1.child = revealOrder;
							break;
						}
						current = revealOrder.sibling;
						revealOrder.sibling = renderLanes$1;
						renderLanes$1 = revealOrder;
						revealOrder = current;
					}
					initSuspenseListRenderState(workInProgress$1, !0, renderLanes$1, null, tailMode);
					break;
				case "together":
					initSuspenseListRenderState(workInProgress$1, !1, null, null, void 0);
					break;
				default: workInProgress$1.memoizedState = null;
			}
			return workInProgress$1.child;
		}
		function bailoutOnAlreadyFinishedWork(current, workInProgress$1, renderLanes$1) {
			null !== current && (workInProgress$1.dependencies = current.dependencies);
			workInProgressRootSkippedLanes |= workInProgress$1.lanes;
			if (0 === (renderLanes$1 & workInProgress$1.childLanes)) if (null !== current) {
				if (propagateParentContextChanges(current, workInProgress$1, renderLanes$1, !1), 0 === (renderLanes$1 & workInProgress$1.childLanes)) return null;
			} else return null;
			if (null !== current && workInProgress$1.child !== current.child) throw Error(formatProdErrorMessage(153));
			if (null !== workInProgress$1.child) {
				current = workInProgress$1.child;
				renderLanes$1 = createWorkInProgress(current, current.pendingProps);
				workInProgress$1.child = renderLanes$1;
				for (renderLanes$1.return = workInProgress$1; null !== current.sibling;) current = current.sibling, renderLanes$1 = renderLanes$1.sibling = createWorkInProgress(current, current.pendingProps), renderLanes$1.return = workInProgress$1;
				renderLanes$1.sibling = null;
			}
			return workInProgress$1.child;
		}
		function checkScheduledUpdateOrContext(current, renderLanes$1) {
			if (0 !== (current.lanes & renderLanes$1)) return !0;
			current = current.dependencies;
			return null !== current && checkIfContextChanged(current) ? !0 : !1;
		}
		function attemptEarlyBailoutIfNoScheduledUpdate(current, workInProgress$1, renderLanes$1) {
			switch (workInProgress$1.tag) {
				case 3:
					pushHostContainer(workInProgress$1, workInProgress$1.stateNode.containerInfo);
					pushProvider(workInProgress$1, CacheContext, current.memoizedState.cache);
					resetHydrationState();
					break;
				case 27:
				case 5:
					pushHostContext(workInProgress$1);
					break;
				case 4:
					pushHostContainer(workInProgress$1, workInProgress$1.stateNode.containerInfo);
					break;
				case 10:
					pushProvider(workInProgress$1, workInProgress$1.type, workInProgress$1.memoizedProps.value);
					break;
				case 13:
					var state = workInProgress$1.memoizedState;
					if (null !== state) {
						if (null !== state.dehydrated) return pushPrimaryTreeSuspenseHandler(workInProgress$1), workInProgress$1.flags |= 128, null;
						if (0 !== (renderLanes$1 & workInProgress$1.child.childLanes)) return updateSuspenseComponent(current, workInProgress$1, renderLanes$1);
						pushPrimaryTreeSuspenseHandler(workInProgress$1);
						current = bailoutOnAlreadyFinishedWork(current, workInProgress$1, renderLanes$1);
						return null !== current ? current.sibling : null;
					}
					pushPrimaryTreeSuspenseHandler(workInProgress$1);
					break;
				case 19:
					var didSuspendBefore = 0 !== (current.flags & 128);
					state = 0 !== (renderLanes$1 & workInProgress$1.childLanes);
					state || (propagateParentContextChanges(current, workInProgress$1, renderLanes$1, !1), state = 0 !== (renderLanes$1 & workInProgress$1.childLanes));
					if (didSuspendBefore) {
						if (state) return updateSuspenseListComponent(current, workInProgress$1, renderLanes$1);
						workInProgress$1.flags |= 128;
					}
					didSuspendBefore = workInProgress$1.memoizedState;
					null !== didSuspendBefore && (didSuspendBefore.rendering = null, didSuspendBefore.tail = null, didSuspendBefore.lastEffect = null);
					push$2(suspenseStackCursor, suspenseStackCursor.current);
					if (state) break;
					else return null;
				case 22:
				case 23: return workInProgress$1.lanes = 0, updateOffscreenComponent(current, workInProgress$1, renderLanes$1);
				case 24: pushProvider(workInProgress$1, CacheContext, current.memoizedState.cache);
			}
			return bailoutOnAlreadyFinishedWork(current, workInProgress$1, renderLanes$1);
		}
		function beginWork(current, workInProgress$1, renderLanes$1) {
			if (null !== current) if (current.memoizedProps !== workInProgress$1.pendingProps) didReceiveUpdate = !0;
			else {
				if (!checkScheduledUpdateOrContext(current, renderLanes$1) && 0 === (workInProgress$1.flags & 128)) return didReceiveUpdate = !1, attemptEarlyBailoutIfNoScheduledUpdate(current, workInProgress$1, renderLanes$1);
				didReceiveUpdate = 0 !== (current.flags & 131072) ? !0 : !1;
			}
			else didReceiveUpdate = !1, isHydrating && 0 !== (workInProgress$1.flags & 1048576) && pushTreeId(workInProgress$1, treeForkCount, workInProgress$1.index);
			workInProgress$1.lanes = 0;
			switch (workInProgress$1.tag) {
				case 16:
					a: {
						current = workInProgress$1.pendingProps;
						var lazyComponent = workInProgress$1.elementType, init = lazyComponent._init;
						lazyComponent = init(lazyComponent._payload);
						workInProgress$1.type = lazyComponent;
						if ("function" === typeof lazyComponent) shouldConstruct(lazyComponent) ? (current = resolveClassComponentProps(lazyComponent, current), workInProgress$1.tag = 1, workInProgress$1 = updateClassComponent(null, workInProgress$1, lazyComponent, current, renderLanes$1)) : (workInProgress$1.tag = 0, workInProgress$1 = updateFunctionComponent(null, workInProgress$1, lazyComponent, current, renderLanes$1));
						else {
							if (void 0 !== lazyComponent && null !== lazyComponent) {
								if (init = lazyComponent.$$typeof, init === REACT_FORWARD_REF_TYPE$1) {
									workInProgress$1.tag = 11;
									workInProgress$1 = updateForwardRef(null, workInProgress$1, lazyComponent, current, renderLanes$1);
									break a;
								} else if (init === REACT_MEMO_TYPE$1) {
									workInProgress$1.tag = 14;
									workInProgress$1 = updateMemoComponent(null, workInProgress$1, lazyComponent, current, renderLanes$1);
									break a;
								}
							}
							workInProgress$1 = getComponentNameFromType(lazyComponent) || lazyComponent;
							throw Error(formatProdErrorMessage(306, workInProgress$1, ""));
						}
					}
					return workInProgress$1;
				case 0: return updateFunctionComponent(current, workInProgress$1, workInProgress$1.type, workInProgress$1.pendingProps, renderLanes$1);
				case 1: return lazyComponent = workInProgress$1.type, init = resolveClassComponentProps(lazyComponent, workInProgress$1.pendingProps), updateClassComponent(current, workInProgress$1, lazyComponent, init, renderLanes$1);
				case 3:
					a: {
						pushHostContainer(workInProgress$1, workInProgress$1.stateNode.containerInfo);
						if (null === current) throw Error(formatProdErrorMessage(387));
						var nextProps = workInProgress$1.pendingProps;
						init = workInProgress$1.memoizedState;
						lazyComponent = init.element;
						cloneUpdateQueue(current, workInProgress$1);
						processUpdateQueue(workInProgress$1, nextProps, null, renderLanes$1);
						var nextState = workInProgress$1.memoizedState;
						nextProps = nextState.cache;
						pushProvider(workInProgress$1, CacheContext, nextProps);
						nextProps !== init.cache && propagateContextChanges(workInProgress$1, [CacheContext], renderLanes$1, !0);
						suspendIfUpdateReadFromEntangledAsyncAction();
						nextProps = nextState.element;
						if (supportsHydration && init.isDehydrated) if (init = {
							element: nextProps,
							isDehydrated: !1,
							cache: nextState.cache
						}, workInProgress$1.updateQueue.baseState = init, workInProgress$1.memoizedState = init, workInProgress$1.flags & 256) {
							workInProgress$1 = mountHostRootWithoutHydrating(current, workInProgress$1, nextProps, renderLanes$1);
							break a;
						} else if (nextProps !== lazyComponent) {
							lazyComponent = createCapturedValueAtFiber(Error(formatProdErrorMessage(424)), workInProgress$1);
							queueHydrationError(lazyComponent);
							workInProgress$1 = mountHostRootWithoutHydrating(current, workInProgress$1, nextProps, renderLanes$1);
							break a;
						} else for (supportsHydration && (nextHydratableInstance = getFirstHydratableChildWithinContainer(workInProgress$1.stateNode.containerInfo), hydrationParentFiber = workInProgress$1, isHydrating = !0, hydrationErrors = null, rootOrSingletonContext = !0), renderLanes$1 = mountChildFibers(workInProgress$1, null, nextProps, renderLanes$1), workInProgress$1.child = renderLanes$1; renderLanes$1;) renderLanes$1.flags = renderLanes$1.flags & -3 | 4096, renderLanes$1 = renderLanes$1.sibling;
						else {
							resetHydrationState();
							if (nextProps === lazyComponent) {
								workInProgress$1 = bailoutOnAlreadyFinishedWork(current, workInProgress$1, renderLanes$1);
								break a;
							}
							reconcileChildren(current, workInProgress$1, nextProps, renderLanes$1);
						}
						workInProgress$1 = workInProgress$1.child;
					}
					return workInProgress$1;
				case 26: if (supportsResources) return markRef(current, workInProgress$1), null === current ? (renderLanes$1 = getResource(workInProgress$1.type, null, workInProgress$1.pendingProps, null)) ? workInProgress$1.memoizedState = renderLanes$1 : isHydrating || (workInProgress$1.stateNode = createHoistableInstance(workInProgress$1.type, workInProgress$1.pendingProps, rootInstanceStackCursor.current, workInProgress$1)) : workInProgress$1.memoizedState = getResource(workInProgress$1.type, current.memoizedProps, workInProgress$1.pendingProps, current.memoizedState), null;
				case 27: if (supportsSingletons) return pushHostContext(workInProgress$1), null === current && supportsSingletons && isHydrating && (lazyComponent = workInProgress$1.stateNode = resolveSingletonInstance(workInProgress$1.type, workInProgress$1.pendingProps, rootInstanceStackCursor.current, contextStackCursor.current, !1), hydrationParentFiber = workInProgress$1, rootOrSingletonContext = !0, nextHydratableInstance = getFirstHydratableChildWithinSingleton(workInProgress$1.type, lazyComponent, nextHydratableInstance)), reconcileChildren(current, workInProgress$1, workInProgress$1.pendingProps.children, renderLanes$1), markRef(current, workInProgress$1), null === current && (workInProgress$1.flags |= 4194304), workInProgress$1.child;
				case 5:
					if (null === current && isHydrating) {
						validateHydratableInstance(workInProgress$1.type, workInProgress$1.pendingProps, contextStackCursor.current);
						if (init = lazyComponent = nextHydratableInstance) lazyComponent = canHydrateInstance(lazyComponent, workInProgress$1.type, workInProgress$1.pendingProps, rootOrSingletonContext), null !== lazyComponent ? (workInProgress$1.stateNode = lazyComponent, hydrationParentFiber = workInProgress$1, nextHydratableInstance = getFirstHydratableChild(lazyComponent), rootOrSingletonContext = !1, init = !0) : init = !1;
						init || throwOnHydrationMismatch(workInProgress$1);
					}
					pushHostContext(workInProgress$1);
					init = workInProgress$1.type;
					nextProps = workInProgress$1.pendingProps;
					nextState = null !== current ? current.memoizedProps : null;
					lazyComponent = nextProps.children;
					shouldSetTextContent(init, nextProps) ? lazyComponent = null : null !== nextState && shouldSetTextContent(init, nextState) && (workInProgress$1.flags |= 32);
					null !== workInProgress$1.memoizedState && (init = renderWithHooks(current, workInProgress$1, TransitionAwareHostComponent, null, null, renderLanes$1), isPrimaryRenderer ? HostTransitionContext._currentValue = init : HostTransitionContext._currentValue2 = init);
					markRef(current, workInProgress$1);
					reconcileChildren(current, workInProgress$1, lazyComponent, renderLanes$1);
					return workInProgress$1.child;
				case 6:
					if (null === current && isHydrating) {
						validateHydratableTextInstance(workInProgress$1.pendingProps, contextStackCursor.current);
						if (current = renderLanes$1 = nextHydratableInstance) renderLanes$1 = canHydrateTextInstance(renderLanes$1, workInProgress$1.pendingProps, rootOrSingletonContext), null !== renderLanes$1 ? (workInProgress$1.stateNode = renderLanes$1, hydrationParentFiber = workInProgress$1, nextHydratableInstance = null, current = !0) : current = !1;
						current || throwOnHydrationMismatch(workInProgress$1);
					}
					return null;
				case 13: return updateSuspenseComponent(current, workInProgress$1, renderLanes$1);
				case 4: return pushHostContainer(workInProgress$1, workInProgress$1.stateNode.containerInfo), lazyComponent = workInProgress$1.pendingProps, null === current ? workInProgress$1.child = reconcileChildFibers(workInProgress$1, null, lazyComponent, renderLanes$1) : reconcileChildren(current, workInProgress$1, lazyComponent, renderLanes$1), workInProgress$1.child;
				case 11: return updateForwardRef(current, workInProgress$1, workInProgress$1.type, workInProgress$1.pendingProps, renderLanes$1);
				case 7: return reconcileChildren(current, workInProgress$1, workInProgress$1.pendingProps, renderLanes$1), workInProgress$1.child;
				case 8: return reconcileChildren(current, workInProgress$1, workInProgress$1.pendingProps.children, renderLanes$1), workInProgress$1.child;
				case 12: return reconcileChildren(current, workInProgress$1, workInProgress$1.pendingProps.children, renderLanes$1), workInProgress$1.child;
				case 10: return lazyComponent = workInProgress$1.pendingProps, pushProvider(workInProgress$1, workInProgress$1.type, lazyComponent.value), reconcileChildren(current, workInProgress$1, lazyComponent.children, renderLanes$1), workInProgress$1.child;
				case 9: return init = workInProgress$1.type._context, lazyComponent = workInProgress$1.pendingProps.children, prepareToReadContext(workInProgress$1), init = readContext(init), lazyComponent = lazyComponent(init), workInProgress$1.flags |= 1, reconcileChildren(current, workInProgress$1, lazyComponent, renderLanes$1), workInProgress$1.child;
				case 14: return updateMemoComponent(current, workInProgress$1, workInProgress$1.type, workInProgress$1.pendingProps, renderLanes$1);
				case 15: return updateSimpleMemoComponent(current, workInProgress$1, workInProgress$1.type, workInProgress$1.pendingProps, renderLanes$1);
				case 19: return updateSuspenseListComponent(current, workInProgress$1, renderLanes$1);
				case 31: return lazyComponent = workInProgress$1.pendingProps, renderLanes$1 = workInProgress$1.mode, lazyComponent = {
					mode: lazyComponent.mode,
					children: lazyComponent.children
				}, null === current ? (renderLanes$1 = mountWorkInProgressOffscreenFiber(lazyComponent, renderLanes$1), renderLanes$1.ref = workInProgress$1.ref, workInProgress$1.child = renderLanes$1, renderLanes$1.return = workInProgress$1, workInProgress$1 = renderLanes$1) : (renderLanes$1 = createWorkInProgress(current.child, lazyComponent), renderLanes$1.ref = workInProgress$1.ref, workInProgress$1.child = renderLanes$1, renderLanes$1.return = workInProgress$1, workInProgress$1 = renderLanes$1), workInProgress$1;
				case 22: return updateOffscreenComponent(current, workInProgress$1, renderLanes$1);
				case 24: return prepareToReadContext(workInProgress$1), lazyComponent = readContext(CacheContext), null === current ? (init = peekCacheFromPool(), null === init && (init = workInProgressRoot, nextProps = createCache(), init.pooledCache = nextProps, nextProps.refCount++, null !== nextProps && (init.pooledCacheLanes |= renderLanes$1), init = nextProps), workInProgress$1.memoizedState = {
					parent: lazyComponent,
					cache: init
				}, initializeUpdateQueue(workInProgress$1), pushProvider(workInProgress$1, CacheContext, init)) : (0 !== (current.lanes & renderLanes$1) && (cloneUpdateQueue(current, workInProgress$1), processUpdateQueue(workInProgress$1, null, null, renderLanes$1), suspendIfUpdateReadFromEntangledAsyncAction()), init = current.memoizedState, nextProps = workInProgress$1.memoizedState, init.parent !== lazyComponent ? (init = {
					parent: lazyComponent,
					cache: lazyComponent
				}, workInProgress$1.memoizedState = init, 0 === workInProgress$1.lanes && (workInProgress$1.memoizedState = workInProgress$1.updateQueue.baseState = init), pushProvider(workInProgress$1, CacheContext, lazyComponent)) : (lazyComponent = nextProps.cache, pushProvider(workInProgress$1, CacheContext, lazyComponent), lazyComponent !== init.cache && propagateContextChanges(workInProgress$1, [CacheContext], renderLanes$1, !0))), reconcileChildren(current, workInProgress$1, workInProgress$1.pendingProps.children, renderLanes$1), workInProgress$1.child;
				case 29: throw workInProgress$1.pendingProps;
			}
			throw Error(formatProdErrorMessage(156, workInProgress$1.tag));
		}
		function markUpdate(workInProgress$1) {
			workInProgress$1.flags |= 4;
		}
		function doesRequireClone(current, completedWork) {
			if (null !== current && current.child === completedWork.child) return !1;
			if (0 !== (completedWork.flags & 16)) return !0;
			for (current = completedWork.child; null !== current;) {
				if (0 !== (current.flags & 13878) || 0 !== (current.subtreeFlags & 13878)) return !0;
				current = current.sibling;
			}
			return !1;
		}
		function appendAllChildren(parent, workInProgress$1, needsVisibilityToggle, isHidden$1) {
			if (supportsMutation) for (needsVisibilityToggle = workInProgress$1.child; null !== needsVisibilityToggle;) {
				if (5 === needsVisibilityToggle.tag || 6 === needsVisibilityToggle.tag) appendInitialChild(parent, needsVisibilityToggle.stateNode);
				else if (!(4 === needsVisibilityToggle.tag || supportsSingletons && 27 === needsVisibilityToggle.tag) && null !== needsVisibilityToggle.child) {
					needsVisibilityToggle.child.return = needsVisibilityToggle;
					needsVisibilityToggle = needsVisibilityToggle.child;
					continue;
				}
				if (needsVisibilityToggle === workInProgress$1) break;
				for (; null === needsVisibilityToggle.sibling;) {
					if (null === needsVisibilityToggle.return || needsVisibilityToggle.return === workInProgress$1) return;
					needsVisibilityToggle = needsVisibilityToggle.return;
				}
				needsVisibilityToggle.sibling.return = needsVisibilityToggle.return;
				needsVisibilityToggle = needsVisibilityToggle.sibling;
			}
			else if (supportsPersistence) for (var node$93 = workInProgress$1.child; null !== node$93;) {
				if (5 === node$93.tag) {
					var instance = node$93.stateNode;
					needsVisibilityToggle && isHidden$1 && (instance = cloneHiddenInstance(instance, node$93.type, node$93.memoizedProps));
					appendInitialChild(parent, instance);
				} else if (6 === node$93.tag) instance = node$93.stateNode, needsVisibilityToggle && isHidden$1 && (instance = cloneHiddenTextInstance(instance, node$93.memoizedProps)), appendInitialChild(parent, instance);
				else if (4 !== node$93.tag) {
					if (22 === node$93.tag && null !== node$93.memoizedState) instance = node$93.child, null !== instance && (instance.return = node$93), appendAllChildren(parent, node$93, !0, !0);
					else if (null !== node$93.child) {
						node$93.child.return = node$93;
						node$93 = node$93.child;
						continue;
					}
				}
				if (node$93 === workInProgress$1) break;
				for (; null === node$93.sibling;) {
					if (null === node$93.return || node$93.return === workInProgress$1) return;
					node$93 = node$93.return;
				}
				node$93.sibling.return = node$93.return;
				node$93 = node$93.sibling;
			}
		}
		function appendAllChildrenToContainer(containerChildSet, workInProgress$1, needsVisibilityToggle, isHidden$1) {
			var hasOffscreenComponentChild = !1;
			if (supportsPersistence) for (var node = workInProgress$1.child; null !== node;) {
				if (5 === node.tag) {
					var instance = node.stateNode;
					needsVisibilityToggle && isHidden$1 && (instance = cloneHiddenInstance(instance, node.type, node.memoizedProps));
					appendChildToContainerChildSet(containerChildSet, instance);
				} else if (6 === node.tag) instance = node.stateNode, needsVisibilityToggle && isHidden$1 && (instance = cloneHiddenTextInstance(instance, node.memoizedProps)), appendChildToContainerChildSet(containerChildSet, instance);
				else if (4 !== node.tag) {
					if (22 === node.tag && null !== node.memoizedState) hasOffscreenComponentChild = node.child, null !== hasOffscreenComponentChild && (hasOffscreenComponentChild.return = node), appendAllChildrenToContainer(containerChildSet, node, !0, !0), hasOffscreenComponentChild = !0;
					else if (null !== node.child) {
						node.child.return = node;
						node = node.child;
						continue;
					}
				}
				if (node === workInProgress$1) break;
				for (; null === node.sibling;) {
					if (null === node.return || node.return === workInProgress$1) return hasOffscreenComponentChild;
					node = node.return;
				}
				node.sibling.return = node.return;
				node = node.sibling;
			}
			return hasOffscreenComponentChild;
		}
		function updateHostContainer(current, workInProgress$1) {
			if (supportsPersistence && doesRequireClone(current, workInProgress$1)) {
				current = workInProgress$1.stateNode;
				var container = current.containerInfo, newChildSet = createContainerChildSet();
				appendAllChildrenToContainer(newChildSet, workInProgress$1, !1, !1);
				current.pendingChildren = newChildSet;
				markUpdate(workInProgress$1);
				finalizeContainerChildren(container, newChildSet);
			}
		}
		function updateHostComponent(current, workInProgress$1, type, newProps) {
			if (supportsMutation) current.memoizedProps !== newProps && markUpdate(workInProgress$1);
			else if (supportsPersistence) {
				var currentInstance = current.stateNode, oldProps$96 = current.memoizedProps;
				if ((current = doesRequireClone(current, workInProgress$1)) || oldProps$96 !== newProps) {
					var currentHostContext = contextStackCursor.current;
					oldProps$96 = cloneInstance(currentInstance, type, oldProps$96, newProps, !current, null);
					oldProps$96 === currentInstance ? workInProgress$1.stateNode = currentInstance : (finalizeInitialChildren(oldProps$96, type, newProps, currentHostContext) && markUpdate(workInProgress$1), workInProgress$1.stateNode = oldProps$96, current ? appendAllChildren(oldProps$96, workInProgress$1, !1, !1) : markUpdate(workInProgress$1));
				} else workInProgress$1.stateNode = currentInstance;
			}
		}
		function preloadInstanceAndSuspendIfNeeded(workInProgress$1, type, props) {
			if (maySuspendCommit(type, props)) {
				if (workInProgress$1.flags |= 16777216, !preloadInstance(type, props)) if (shouldRemainOnPreviousScreen()) workInProgress$1.flags |= 8192;
				else throw suspendedThenable = noopSuspenseyCommitThenable, SuspenseyCommitException;
			} else workInProgress$1.flags &= -16777217;
		}
		function preloadResourceAndSuspendIfNeeded(workInProgress$1, resource) {
			if (mayResourceSuspendCommit(resource)) {
				if (workInProgress$1.flags |= 16777216, !preloadResource(resource)) if (shouldRemainOnPreviousScreen()) workInProgress$1.flags |= 8192;
				else throw suspendedThenable = noopSuspenseyCommitThenable, SuspenseyCommitException;
			} else workInProgress$1.flags &= -16777217;
		}
		function scheduleRetryEffect(workInProgress$1, retryQueue) {
			null !== retryQueue && (workInProgress$1.flags |= 4);
			workInProgress$1.flags & 16384 && (retryQueue = 22 !== workInProgress$1.tag ? claimNextRetryLane() : 536870912, workInProgress$1.lanes |= retryQueue, workInProgressSuspendedRetryLanes |= retryQueue);
		}
		function cutOffTailIfNeeded(renderState, hasRenderedATailFallback) {
			if (!isHydrating) switch (renderState.tailMode) {
				case "hidden":
					hasRenderedATailFallback = renderState.tail;
					for (var lastTailNode = null; null !== hasRenderedATailFallback;) null !== hasRenderedATailFallback.alternate && (lastTailNode = hasRenderedATailFallback), hasRenderedATailFallback = hasRenderedATailFallback.sibling;
					null === lastTailNode ? renderState.tail = null : lastTailNode.sibling = null;
					break;
				case "collapsed":
					lastTailNode = renderState.tail;
					for (var lastTailNode$98 = null; null !== lastTailNode;) null !== lastTailNode.alternate && (lastTailNode$98 = lastTailNode), lastTailNode = lastTailNode.sibling;
					null === lastTailNode$98 ? hasRenderedATailFallback || null === renderState.tail ? renderState.tail = null : renderState.tail.sibling = null : lastTailNode$98.sibling = null;
			}
		}
		function bubbleProperties(completedWork) {
			var didBailout = null !== completedWork.alternate && completedWork.alternate.child === completedWork.child, newChildLanes = 0, subtreeFlags = 0;
			if (didBailout) for (var child$99 = completedWork.child; null !== child$99;) newChildLanes |= child$99.lanes | child$99.childLanes, subtreeFlags |= child$99.subtreeFlags & 65011712, subtreeFlags |= child$99.flags & 65011712, child$99.return = completedWork, child$99 = child$99.sibling;
			else for (child$99 = completedWork.child; null !== child$99;) newChildLanes |= child$99.lanes | child$99.childLanes, subtreeFlags |= child$99.subtreeFlags, subtreeFlags |= child$99.flags, child$99.return = completedWork, child$99 = child$99.sibling;
			completedWork.subtreeFlags |= subtreeFlags;
			completedWork.childLanes = newChildLanes;
			return didBailout;
		}
		function completeWork(current, workInProgress$1, renderLanes$1) {
			var newProps = workInProgress$1.pendingProps;
			popTreeContext(workInProgress$1);
			switch (workInProgress$1.tag) {
				case 31:
				case 16:
				case 15:
				case 0:
				case 11:
				case 7:
				case 8:
				case 12:
				case 9:
				case 14: return bubbleProperties(workInProgress$1), null;
				case 1: return bubbleProperties(workInProgress$1), null;
				case 3:
					renderLanes$1 = workInProgress$1.stateNode;
					newProps = null;
					null !== current && (newProps = current.memoizedState.cache);
					workInProgress$1.memoizedState.cache !== newProps && (workInProgress$1.flags |= 2048);
					popProvider(CacheContext);
					popHostContainer();
					renderLanes$1.pendingContext && (renderLanes$1.context = renderLanes$1.pendingContext, renderLanes$1.pendingContext = null);
					if (null === current || null === current.child) popHydrationState(workInProgress$1) ? markUpdate(workInProgress$1) : null === current || current.memoizedState.isDehydrated && 0 === (workInProgress$1.flags & 256) || (workInProgress$1.flags |= 1024, upgradeHydrationErrorsToRecoverable());
					updateHostContainer(current, workInProgress$1);
					bubbleProperties(workInProgress$1);
					return null;
				case 26: if (supportsResources) {
					renderLanes$1 = workInProgress$1.type;
					var nextResource = workInProgress$1.memoizedState;
					null === current ? (markUpdate(workInProgress$1), null !== nextResource ? (bubbleProperties(workInProgress$1), preloadResourceAndSuspendIfNeeded(workInProgress$1, nextResource)) : (bubbleProperties(workInProgress$1), preloadInstanceAndSuspendIfNeeded(workInProgress$1, renderLanes$1, newProps))) : nextResource ? nextResource !== current.memoizedState ? (markUpdate(workInProgress$1), bubbleProperties(workInProgress$1), preloadResourceAndSuspendIfNeeded(workInProgress$1, nextResource)) : (bubbleProperties(workInProgress$1), workInProgress$1.flags &= -16777217) : (supportsMutation ? current.memoizedProps !== newProps && markUpdate(workInProgress$1) : updateHostComponent(current, workInProgress$1, renderLanes$1, newProps), bubbleProperties(workInProgress$1), preloadInstanceAndSuspendIfNeeded(workInProgress$1, renderLanes$1, newProps));
					return null;
				}
				case 27: if (supportsSingletons) {
					popHostContext(workInProgress$1);
					renderLanes$1 = rootInstanceStackCursor.current;
					nextResource = workInProgress$1.type;
					if (null !== current && null != workInProgress$1.stateNode) supportsMutation ? current.memoizedProps !== newProps && markUpdate(workInProgress$1) : updateHostComponent(current, workInProgress$1, nextResource, newProps);
					else {
						if (!newProps) {
							if (null === workInProgress$1.stateNode) throw Error(formatProdErrorMessage(166));
							bubbleProperties(workInProgress$1);
							return null;
						}
						current = contextStackCursor.current;
						popHydrationState(workInProgress$1) ? prepareToHydrateHostInstance(workInProgress$1, current) : (current = resolveSingletonInstance(nextResource, newProps, renderLanes$1, current, !0), workInProgress$1.stateNode = current, markUpdate(workInProgress$1));
					}
					bubbleProperties(workInProgress$1);
					return null;
				}
				case 5:
					popHostContext(workInProgress$1);
					renderLanes$1 = workInProgress$1.type;
					if (null !== current && null != workInProgress$1.stateNode) updateHostComponent(current, workInProgress$1, renderLanes$1, newProps);
					else {
						if (!newProps) {
							if (null === workInProgress$1.stateNode) throw Error(formatProdErrorMessage(166));
							bubbleProperties(workInProgress$1);
							return null;
						}
						current = contextStackCursor.current;
						popHydrationState(workInProgress$1) ? prepareToHydrateHostInstance(workInProgress$1, current) : (nextResource = createInstance(renderLanes$1, newProps, rootInstanceStackCursor.current, current, workInProgress$1), appendAllChildren(nextResource, workInProgress$1, !1, !1), workInProgress$1.stateNode = nextResource, finalizeInitialChildren(nextResource, renderLanes$1, newProps, current) && markUpdate(workInProgress$1));
					}
					bubbleProperties(workInProgress$1);
					preloadInstanceAndSuspendIfNeeded(workInProgress$1, workInProgress$1.type, workInProgress$1.pendingProps);
					return null;
				case 6:
					if (current && null != workInProgress$1.stateNode) renderLanes$1 = current.memoizedProps, supportsMutation ? renderLanes$1 !== newProps && markUpdate(workInProgress$1) : supportsPersistence && (renderLanes$1 !== newProps ? (workInProgress$1.stateNode = createTextInstance(newProps, rootInstanceStackCursor.current, contextStackCursor.current, workInProgress$1), markUpdate(workInProgress$1)) : workInProgress$1.stateNode = current.stateNode);
					else {
						if ("string" !== typeof newProps && null === workInProgress$1.stateNode) throw Error(formatProdErrorMessage(166));
						current = rootInstanceStackCursor.current;
						renderLanes$1 = contextStackCursor.current;
						if (popHydrationState(workInProgress$1)) {
							if (!supportsHydration) throw Error(formatProdErrorMessage(176));
							current = workInProgress$1.stateNode;
							renderLanes$1 = workInProgress$1.memoizedProps;
							newProps = null;
							nextResource = hydrationParentFiber;
							if (null !== nextResource) switch (nextResource.tag) {
								case 27:
								case 5: newProps = nextResource.memoizedProps;
							}
							hydrateTextInstance(current, renderLanes$1, workInProgress$1, newProps) || throwOnHydrationMismatch(workInProgress$1);
						} else workInProgress$1.stateNode = createTextInstance(newProps, current, renderLanes$1, workInProgress$1);
					}
					bubbleProperties(workInProgress$1);
					return null;
				case 13:
					newProps = workInProgress$1.memoizedState;
					if (null === current || null !== current.memoizedState && null !== current.memoizedState.dehydrated) {
						nextResource = popHydrationState(workInProgress$1);
						if (null !== newProps && null !== newProps.dehydrated) {
							if (null === current) {
								if (!nextResource) throw Error(formatProdErrorMessage(318));
								if (!supportsHydration) throw Error(formatProdErrorMessage(344));
								nextResource = workInProgress$1.memoizedState;
								nextResource = null !== nextResource ? nextResource.dehydrated : null;
								if (!nextResource) throw Error(formatProdErrorMessage(317));
								hydrateSuspenseInstance(nextResource, workInProgress$1);
							} else resetHydrationState(), 0 === (workInProgress$1.flags & 128) && (workInProgress$1.memoizedState = null), workInProgress$1.flags |= 4;
							bubbleProperties(workInProgress$1);
							nextResource = !1;
						} else nextResource = upgradeHydrationErrorsToRecoverable(), null !== current && null !== current.memoizedState && (current.memoizedState.hydrationErrors = nextResource), nextResource = !0;
						if (!nextResource) {
							if (workInProgress$1.flags & 256) return popSuspenseHandler(workInProgress$1), workInProgress$1;
							popSuspenseHandler(workInProgress$1);
							return null;
						}
					}
					popSuspenseHandler(workInProgress$1);
					if (0 !== (workInProgress$1.flags & 128)) return workInProgress$1.lanes = renderLanes$1, workInProgress$1;
					renderLanes$1 = null !== newProps;
					current = null !== current && null !== current.memoizedState;
					if (renderLanes$1) {
						newProps = workInProgress$1.child;
						nextResource = null;
						null !== newProps.alternate && null !== newProps.alternate.memoizedState && null !== newProps.alternate.memoizedState.cachePool && (nextResource = newProps.alternate.memoizedState.cachePool.pool);
						var cache$113 = null;
						null !== newProps.memoizedState && null !== newProps.memoizedState.cachePool && (cache$113 = newProps.memoizedState.cachePool.pool);
						cache$113 !== nextResource && (newProps.flags |= 2048);
					}
					renderLanes$1 !== current && renderLanes$1 && (workInProgress$1.child.flags |= 8192);
					scheduleRetryEffect(workInProgress$1, workInProgress$1.updateQueue);
					bubbleProperties(workInProgress$1);
					return null;
				case 4: return popHostContainer(), updateHostContainer(current, workInProgress$1), null === current && preparePortalMount(workInProgress$1.stateNode.containerInfo), bubbleProperties(workInProgress$1), null;
				case 10: return popProvider(workInProgress$1.type), bubbleProperties(workInProgress$1), null;
				case 19:
					pop$1(suspenseStackCursor);
					nextResource = workInProgress$1.memoizedState;
					if (null === nextResource) return bubbleProperties(workInProgress$1), null;
					newProps = 0 !== (workInProgress$1.flags & 128);
					cache$113 = nextResource.rendering;
					if (null === cache$113) if (newProps) cutOffTailIfNeeded(nextResource, !1);
					else {
						if (0 !== workInProgressRootExitStatus || null !== current && 0 !== (current.flags & 128)) for (current = workInProgress$1.child; null !== current;) {
							cache$113 = findFirstSuspended(current);
							if (null !== cache$113) {
								workInProgress$1.flags |= 128;
								cutOffTailIfNeeded(nextResource, !1);
								current = cache$113.updateQueue;
								workInProgress$1.updateQueue = current;
								scheduleRetryEffect(workInProgress$1, current);
								workInProgress$1.subtreeFlags = 0;
								current = renderLanes$1;
								for (renderLanes$1 = workInProgress$1.child; null !== renderLanes$1;) resetWorkInProgress(renderLanes$1, current), renderLanes$1 = renderLanes$1.sibling;
								push$2(suspenseStackCursor, suspenseStackCursor.current & 1 | 2);
								return workInProgress$1.child;
							}
							current = current.sibling;
						}
						null !== nextResource.tail && now() > workInProgressRootRenderTargetTime && (workInProgress$1.flags |= 128, newProps = !0, cutOffTailIfNeeded(nextResource, !1), workInProgress$1.lanes = 4194304);
					}
					else {
						if (!newProps) if (current = findFirstSuspended(cache$113), null !== current) {
							if (workInProgress$1.flags |= 128, newProps = !0, current = current.updateQueue, workInProgress$1.updateQueue = current, scheduleRetryEffect(workInProgress$1, current), cutOffTailIfNeeded(nextResource, !0), null === nextResource.tail && "hidden" === nextResource.tailMode && !cache$113.alternate && !isHydrating) return bubbleProperties(workInProgress$1), null;
						} else 2 * now() - nextResource.renderingStartTime > workInProgressRootRenderTargetTime && 536870912 !== renderLanes$1 && (workInProgress$1.flags |= 128, newProps = !0, cutOffTailIfNeeded(nextResource, !1), workInProgress$1.lanes = 4194304);
						nextResource.isBackwards ? (cache$113.sibling = workInProgress$1.child, workInProgress$1.child = cache$113) : (current = nextResource.last, null !== current ? current.sibling = cache$113 : workInProgress$1.child = cache$113, nextResource.last = cache$113);
					}
					if (null !== nextResource.tail) return workInProgress$1 = nextResource.tail, nextResource.rendering = workInProgress$1, nextResource.tail = workInProgress$1.sibling, nextResource.renderingStartTime = now(), workInProgress$1.sibling = null, current = suspenseStackCursor.current, push$2(suspenseStackCursor, newProps ? current & 1 | 2 : current & 1), workInProgress$1;
					bubbleProperties(workInProgress$1);
					return null;
				case 22:
				case 23: return popSuspenseHandler(workInProgress$1), popHiddenContext(), newProps = null !== workInProgress$1.memoizedState, null !== current ? null !== current.memoizedState !== newProps && (workInProgress$1.flags |= 8192) : newProps && (workInProgress$1.flags |= 8192), newProps ? 0 !== (renderLanes$1 & 536870912) && 0 === (workInProgress$1.flags & 128) && (bubbleProperties(workInProgress$1), workInProgress$1.subtreeFlags & 6 && (workInProgress$1.flags |= 8192)) : bubbleProperties(workInProgress$1), renderLanes$1 = workInProgress$1.updateQueue, null !== renderLanes$1 && scheduleRetryEffect(workInProgress$1, renderLanes$1.retryQueue), renderLanes$1 = null, null !== current && null !== current.memoizedState && null !== current.memoizedState.cachePool && (renderLanes$1 = current.memoizedState.cachePool.pool), newProps = null, null !== workInProgress$1.memoizedState && null !== workInProgress$1.memoizedState.cachePool && (newProps = workInProgress$1.memoizedState.cachePool.pool), newProps !== renderLanes$1 && (workInProgress$1.flags |= 2048), null !== current && pop$1(resumedCache), null;
				case 24: return renderLanes$1 = null, null !== current && (renderLanes$1 = current.memoizedState.cache), workInProgress$1.memoizedState.cache !== renderLanes$1 && (workInProgress$1.flags |= 2048), popProvider(CacheContext), bubbleProperties(workInProgress$1), null;
				case 25: return null;
				case 30: return null;
			}
			throw Error(formatProdErrorMessage(156, workInProgress$1.tag));
		}
		function unwindWork(current, workInProgress$1) {
			popTreeContext(workInProgress$1);
			switch (workInProgress$1.tag) {
				case 1: return current = workInProgress$1.flags, current & 65536 ? (workInProgress$1.flags = current & -65537 | 128, workInProgress$1) : null;
				case 3: return popProvider(CacheContext), popHostContainer(), current = workInProgress$1.flags, 0 !== (current & 65536) && 0 === (current & 128) ? (workInProgress$1.flags = current & -65537 | 128, workInProgress$1) : null;
				case 26:
				case 27:
				case 5: return popHostContext(workInProgress$1), null;
				case 13:
					popSuspenseHandler(workInProgress$1);
					current = workInProgress$1.memoizedState;
					if (null !== current && null !== current.dehydrated) {
						if (null === workInProgress$1.alternate) throw Error(formatProdErrorMessage(340));
						resetHydrationState();
					}
					current = workInProgress$1.flags;
					return current & 65536 ? (workInProgress$1.flags = current & -65537 | 128, workInProgress$1) : null;
				case 19: return pop$1(suspenseStackCursor), null;
				case 4: return popHostContainer(), null;
				case 10: return popProvider(workInProgress$1.type), null;
				case 22:
				case 23: return popSuspenseHandler(workInProgress$1), popHiddenContext(), null !== current && pop$1(resumedCache), current = workInProgress$1.flags, current & 65536 ? (workInProgress$1.flags = current & -65537 | 128, workInProgress$1) : null;
				case 24: return popProvider(CacheContext), null;
				case 25: return null;
				default: return null;
			}
		}
		function unwindInterruptedWork(current, interruptedWork) {
			popTreeContext(interruptedWork);
			switch (interruptedWork.tag) {
				case 3:
					popProvider(CacheContext);
					popHostContainer();
					break;
				case 26:
				case 27:
				case 5:
					popHostContext(interruptedWork);
					break;
				case 4:
					popHostContainer();
					break;
				case 13:
					popSuspenseHandler(interruptedWork);
					break;
				case 19:
					pop$1(suspenseStackCursor);
					break;
				case 10:
					popProvider(interruptedWork.type);
					break;
				case 22:
				case 23:
					popSuspenseHandler(interruptedWork);
					popHiddenContext();
					null !== current && pop$1(resumedCache);
					break;
				case 24: popProvider(CacheContext);
			}
		}
		function commitHookEffectListMount(flags, finishedWork) {
			try {
				var updateQueue = finishedWork.updateQueue, lastEffect = null !== updateQueue ? updateQueue.lastEffect : null;
				if (null !== lastEffect) {
					var firstEffect = lastEffect.next;
					updateQueue = firstEffect;
					do {
						if ((updateQueue.tag & flags) === flags) {
							lastEffect = void 0;
							var create$1 = updateQueue.create, inst = updateQueue.inst;
							lastEffect = create$1();
							inst.destroy = lastEffect;
						}
						updateQueue = updateQueue.next;
					} while (updateQueue !== firstEffect);
				}
			} catch (error) {
				captureCommitPhaseError(finishedWork, finishedWork.return, error);
			}
		}
		function commitHookEffectListUnmount(flags, finishedWork, nearestMountedAncestor$jscomp$0) {
			try {
				var updateQueue = finishedWork.updateQueue, lastEffect = null !== updateQueue ? updateQueue.lastEffect : null;
				if (null !== lastEffect) {
					var firstEffect = lastEffect.next;
					updateQueue = firstEffect;
					do {
						if ((updateQueue.tag & flags) === flags) {
							var inst = updateQueue.inst, destroy = inst.destroy;
							if (void 0 !== destroy) {
								inst.destroy = void 0;
								lastEffect = finishedWork;
								var nearestMountedAncestor = nearestMountedAncestor$jscomp$0, destroy_ = destroy;
								try {
									destroy_();
								} catch (error) {
									captureCommitPhaseError(lastEffect, nearestMountedAncestor, error);
								}
							}
						}
						updateQueue = updateQueue.next;
					} while (updateQueue !== firstEffect);
				}
			} catch (error) {
				captureCommitPhaseError(finishedWork, finishedWork.return, error);
			}
		}
		function commitClassCallbacks(finishedWork) {
			var updateQueue = finishedWork.updateQueue;
			if (null !== updateQueue) {
				var instance = finishedWork.stateNode;
				try {
					commitCallbacks(updateQueue, instance);
				} catch (error) {
					captureCommitPhaseError(finishedWork, finishedWork.return, error);
				}
			}
		}
		function safelyCallComponentWillUnmount(current, nearestMountedAncestor, instance) {
			instance.props = resolveClassComponentProps(current.type, current.memoizedProps);
			instance.state = current.memoizedState;
			try {
				instance.componentWillUnmount();
			} catch (error) {
				captureCommitPhaseError(current, nearestMountedAncestor, error);
			}
		}
		function safelyAttachRef(current, nearestMountedAncestor) {
			try {
				var ref = current.ref;
				if (null !== ref) {
					switch (current.tag) {
						case 26:
						case 27:
						case 5:
							var instanceToUse = getPublicInstance(current.stateNode);
							break;
						case 30:
							instanceToUse = current.stateNode;
							break;
						default: instanceToUse = current.stateNode;
					}
					"function" === typeof ref ? current.refCleanup = ref(instanceToUse) : ref.current = instanceToUse;
				}
			} catch (error) {
				captureCommitPhaseError(current, nearestMountedAncestor, error);
			}
		}
		function safelyDetachRef(current, nearestMountedAncestor) {
			var ref = current.ref, refCleanup = current.refCleanup;
			if (null !== ref) if ("function" === typeof refCleanup) try {
				refCleanup();
			} catch (error) {
				captureCommitPhaseError(current, nearestMountedAncestor, error);
			} finally {
				current.refCleanup = null, current = current.alternate, null != current && (current.refCleanup = null);
			}
			else if ("function" === typeof ref) try {
				ref(null);
			} catch (error$129) {
				captureCommitPhaseError(current, nearestMountedAncestor, error$129);
			}
			else ref.current = null;
		}
		function commitHostMount(finishedWork) {
			var type = finishedWork.type, props = finishedWork.memoizedProps, instance = finishedWork.stateNode;
			try {
				commitMount(instance, type, props, finishedWork);
			} catch (error) {
				captureCommitPhaseError(finishedWork, finishedWork.return, error);
			}
		}
		function commitHostUpdate(finishedWork, newProps, oldProps) {
			try {
				commitUpdate(finishedWork.stateNode, finishedWork.type, oldProps, newProps, finishedWork);
			} catch (error) {
				captureCommitPhaseError(finishedWork, finishedWork.return, error);
			}
		}
		function isHostParent(fiber) {
			return 5 === fiber.tag || 3 === fiber.tag || (supportsResources ? 26 === fiber.tag : !1) || (supportsSingletons ? 27 === fiber.tag && isSingletonScope(fiber.type) : !1) || 4 === fiber.tag;
		}
		function getHostSibling(fiber) {
			a: for (;;) {
				for (; null === fiber.sibling;) {
					if (null === fiber.return || isHostParent(fiber.return)) return null;
					fiber = fiber.return;
				}
				fiber.sibling.return = fiber.return;
				for (fiber = fiber.sibling; 5 !== fiber.tag && 6 !== fiber.tag && 18 !== fiber.tag;) {
					if (supportsSingletons && 27 === fiber.tag && isSingletonScope(fiber.type)) continue a;
					if (fiber.flags & 2) continue a;
					if (null === fiber.child || 4 === fiber.tag) continue a;
					else fiber.child.return = fiber, fiber = fiber.child;
				}
				if (!(fiber.flags & 2)) return fiber.stateNode;
			}
		}
		function insertOrAppendPlacementNodeIntoContainer(node, before, parent) {
			var tag = node.tag;
			if (5 === tag || 6 === tag) node = node.stateNode, before ? insertInContainerBefore(parent, node, before) : appendChildToContainer(parent, node);
			else if (4 !== tag && (supportsSingletons && 27 === tag && isSingletonScope(node.type) && (parent = node.stateNode, before = null), node = node.child, null !== node)) for (insertOrAppendPlacementNodeIntoContainer(node, before, parent), node = node.sibling; null !== node;) insertOrAppendPlacementNodeIntoContainer(node, before, parent), node = node.sibling;
		}
		function insertOrAppendPlacementNode(node, before, parent) {
			var tag = node.tag;
			if (5 === tag || 6 === tag) node = node.stateNode, before ? insertBefore(parent, node, before) : appendChild(parent, node);
			else if (4 !== tag && (supportsSingletons && 27 === tag && isSingletonScope(node.type) && (parent = node.stateNode), node = node.child, null !== node)) for (insertOrAppendPlacementNode(node, before, parent), node = node.sibling; null !== node;) insertOrAppendPlacementNode(node, before, parent), node = node.sibling;
		}
		function commitHostPortalContainerChildren(portal, finishedWork, pendingChildren) {
			portal = portal.containerInfo;
			try {
				replaceContainerChildren(portal, pendingChildren);
			} catch (error) {
				captureCommitPhaseError(finishedWork, finishedWork.return, error);
			}
		}
		function commitHostSingletonAcquisition(finishedWork) {
			var singleton = finishedWork.stateNode, props = finishedWork.memoizedProps;
			try {
				acquireSingletonInstance(finishedWork.type, props, singleton, finishedWork);
			} catch (error) {
				captureCommitPhaseError(finishedWork, finishedWork.return, error);
			}
		}
		function commitBeforeMutationEffects(root, firstChild) {
			prepareForCommit(root.containerInfo);
			for (nextEffect = firstChild; null !== nextEffect;) if (root = nextEffect, firstChild = root.child, 0 !== (root.subtreeFlags & 1024) && null !== firstChild) firstChild.return = root, nextEffect = firstChild;
			else for (; null !== nextEffect;) {
				root = nextEffect;
				var current = root.alternate;
				firstChild = root.flags;
				switch (root.tag) {
					case 0: break;
					case 11:
					case 15: break;
					case 1:
						if (0 !== (firstChild & 1024) && null !== current) {
							firstChild = void 0;
							var finishedWork = root, prevProps = current.memoizedProps;
							current = current.memoizedState;
							var instance = finishedWork.stateNode;
							try {
								var resolvedPrevProps = resolveClassComponentProps(finishedWork.type, prevProps, finishedWork.elementType === finishedWork.type);
								firstChild = instance.getSnapshotBeforeUpdate(resolvedPrevProps, current);
								instance.__reactInternalSnapshotBeforeUpdate = firstChild;
							} catch (error) {
								captureCommitPhaseError(finishedWork, finishedWork.return, error);
							}
						}
						break;
					case 3:
						0 !== (firstChild & 1024) && supportsMutation && clearContainer(root.stateNode.containerInfo);
						break;
					case 5:
					case 26:
					case 27:
					case 6:
					case 4:
					case 17: break;
					default: if (0 !== (firstChild & 1024)) throw Error(formatProdErrorMessage(163));
				}
				firstChild = root.sibling;
				if (null !== firstChild) {
					firstChild.return = root.return;
					nextEffect = firstChild;
					break;
				}
				nextEffect = root.return;
			}
		}
		function commitLayoutEffectOnFiber(finishedRoot, current, finishedWork) {
			var flags = finishedWork.flags;
			switch (finishedWork.tag) {
				case 0:
				case 11:
				case 15:
					recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
					flags & 4 && commitHookEffectListMount(5, finishedWork);
					break;
				case 1:
					recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
					if (flags & 4) if (finishedRoot = finishedWork.stateNode, null === current) try {
						finishedRoot.componentDidMount();
					} catch (error) {
						captureCommitPhaseError(finishedWork, finishedWork.return, error);
					}
					else {
						var prevProps = resolveClassComponentProps(finishedWork.type, current.memoizedProps);
						current = current.memoizedState;
						try {
							finishedRoot.componentDidUpdate(prevProps, current, finishedRoot.__reactInternalSnapshotBeforeUpdate);
						} catch (error$128) {
							captureCommitPhaseError(finishedWork, finishedWork.return, error$128);
						}
					}
					flags & 64 && commitClassCallbacks(finishedWork);
					flags & 512 && safelyAttachRef(finishedWork, finishedWork.return);
					break;
				case 3:
					recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
					if (flags & 64 && (finishedRoot = finishedWork.updateQueue, null !== finishedRoot)) {
						current = null;
						if (null !== finishedWork.child) switch (finishedWork.child.tag) {
							case 27:
							case 5:
								current = getPublicInstance(finishedWork.child.stateNode);
								break;
							case 1: current = finishedWork.child.stateNode;
						}
						try {
							commitCallbacks(finishedRoot, current);
						} catch (error) {
							captureCommitPhaseError(finishedWork, finishedWork.return, error);
						}
					}
					break;
				case 27: supportsSingletons && null === current && flags & 4 && commitHostSingletonAcquisition(finishedWork);
				case 26:
				case 5:
					recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
					null === current && flags & 4 && commitHostMount(finishedWork);
					flags & 512 && safelyAttachRef(finishedWork, finishedWork.return);
					break;
				case 12:
					recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
					break;
				case 13:
					recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
					flags & 4 && commitSuspenseHydrationCallbacks(finishedRoot, finishedWork);
					flags & 64 && (finishedRoot = finishedWork.memoizedState, null !== finishedRoot && (finishedRoot = finishedRoot.dehydrated, null !== finishedRoot && (finishedWork = retryDehydratedSuspenseBoundary.bind(null, finishedWork), registerSuspenseInstanceRetry(finishedRoot, finishedWork))));
					break;
				case 22:
					flags = null !== finishedWork.memoizedState || offscreenSubtreeIsHidden;
					if (!flags) {
						current = null !== current && null !== current.memoizedState || offscreenSubtreeWasHidden;
						prevProps = offscreenSubtreeIsHidden;
						var prevOffscreenSubtreeWasHidden = offscreenSubtreeWasHidden;
						offscreenSubtreeIsHidden = flags;
						(offscreenSubtreeWasHidden = current) && !prevOffscreenSubtreeWasHidden ? recursivelyTraverseReappearLayoutEffects(finishedRoot, finishedWork, 0 !== (finishedWork.subtreeFlags & 8772)) : recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
						offscreenSubtreeIsHidden = prevProps;
						offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden;
					}
					break;
				case 30: break;
				default: recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
			}
		}
		function detachFiberAfterEffects(fiber) {
			var alternate = fiber.alternate;
			null !== alternate && (fiber.alternate = null, detachFiberAfterEffects(alternate));
			fiber.child = null;
			fiber.deletions = null;
			fiber.sibling = null;
			5 === fiber.tag && (alternate = fiber.stateNode, null !== alternate && detachDeletedInstance(alternate));
			fiber.stateNode = null;
			fiber.return = null;
			fiber.dependencies = null;
			fiber.memoizedProps = null;
			fiber.memoizedState = null;
			fiber.pendingProps = null;
			fiber.stateNode = null;
			fiber.updateQueue = null;
		}
		function recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, parent) {
			for (parent = parent.child; null !== parent;) commitDeletionEffectsOnFiber(finishedRoot, nearestMountedAncestor, parent), parent = parent.sibling;
		}
		function commitDeletionEffectsOnFiber(finishedRoot, nearestMountedAncestor, deletedFiber) {
			if (injectedHook && "function" === typeof injectedHook.onCommitFiberUnmount) try {
				injectedHook.onCommitFiberUnmount(rendererID, deletedFiber);
			} catch (err) {}
			switch (deletedFiber.tag) {
				case 26: if (supportsResources) {
					offscreenSubtreeWasHidden || safelyDetachRef(deletedFiber, nearestMountedAncestor);
					recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);
					deletedFiber.memoizedState ? releaseResource(deletedFiber.memoizedState) : deletedFiber.stateNode && unmountHoistable(deletedFiber.stateNode);
					break;
				}
				case 27: if (supportsSingletons) {
					offscreenSubtreeWasHidden || safelyDetachRef(deletedFiber, nearestMountedAncestor);
					var prevHostParent = hostParent, prevHostParentIsContainer = hostParentIsContainer;
					isSingletonScope(deletedFiber.type) && (hostParent = deletedFiber.stateNode, hostParentIsContainer = !1);
					recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);
					releaseSingletonInstance(deletedFiber.stateNode);
					hostParent = prevHostParent;
					hostParentIsContainer = prevHostParentIsContainer;
					break;
				}
				case 5: offscreenSubtreeWasHidden || safelyDetachRef(deletedFiber, nearestMountedAncestor);
				case 6:
					if (supportsMutation) {
						if (prevHostParent = hostParent, prevHostParentIsContainer = hostParentIsContainer, hostParent = null, recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber), hostParent = prevHostParent, hostParentIsContainer = prevHostParentIsContainer, null !== hostParent) if (hostParentIsContainer) try {
							removeChildFromContainer(hostParent, deletedFiber.stateNode);
						} catch (error) {
							captureCommitPhaseError(deletedFiber, nearestMountedAncestor, error);
						}
						else try {
							removeChild(hostParent, deletedFiber.stateNode);
						} catch (error) {
							captureCommitPhaseError(deletedFiber, nearestMountedAncestor, error);
						}
					} else recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);
					break;
				case 18:
					supportsMutation && null !== hostParent && (hostParentIsContainer ? clearSuspenseBoundaryFromContainer(hostParent, deletedFiber.stateNode) : clearSuspenseBoundary(hostParent, deletedFiber.stateNode));
					break;
				case 4:
					supportsMutation ? (prevHostParent = hostParent, prevHostParentIsContainer = hostParentIsContainer, hostParent = deletedFiber.stateNode.containerInfo, hostParentIsContainer = !0, recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber), hostParent = prevHostParent, hostParentIsContainer = prevHostParentIsContainer) : (supportsPersistence && commitHostPortalContainerChildren(deletedFiber.stateNode, deletedFiber, createContainerChildSet()), recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber));
					break;
				case 0:
				case 11:
				case 14:
				case 15:
					offscreenSubtreeWasHidden || commitHookEffectListUnmount(2, deletedFiber, nearestMountedAncestor);
					offscreenSubtreeWasHidden || commitHookEffectListUnmount(4, deletedFiber, nearestMountedAncestor);
					recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);
					break;
				case 1:
					offscreenSubtreeWasHidden || (safelyDetachRef(deletedFiber, nearestMountedAncestor), prevHostParent = deletedFiber.stateNode, "function" === typeof prevHostParent.componentWillUnmount && safelyCallComponentWillUnmount(deletedFiber, nearestMountedAncestor, prevHostParent));
					recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);
					break;
				case 21:
					recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);
					break;
				case 22:
					offscreenSubtreeWasHidden = (prevHostParent = offscreenSubtreeWasHidden) || null !== deletedFiber.memoizedState;
					recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);
					offscreenSubtreeWasHidden = prevHostParent;
					break;
				default: recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);
			}
		}
		function commitSuspenseHydrationCallbacks(finishedRoot, finishedWork) {
			if (supportsHydration && null === finishedWork.memoizedState && (finishedRoot = finishedWork.alternate, null !== finishedRoot && (finishedRoot = finishedRoot.memoizedState, null !== finishedRoot && (finishedRoot = finishedRoot.dehydrated, null !== finishedRoot)))) try {
				commitHydratedSuspenseInstance(finishedRoot);
			} catch (error) {
				captureCommitPhaseError(finishedWork, finishedWork.return, error);
			}
		}
		function getRetryCache(finishedWork) {
			switch (finishedWork.tag) {
				case 13:
				case 19:
					var retryCache = finishedWork.stateNode;
					null === retryCache && (retryCache = finishedWork.stateNode = new PossiblyWeakSet());
					return retryCache;
				case 22: return finishedWork = finishedWork.stateNode, retryCache = finishedWork._retryCache, null === retryCache && (retryCache = finishedWork._retryCache = new PossiblyWeakSet()), retryCache;
				default: throw Error(formatProdErrorMessage(435, finishedWork.tag));
			}
		}
		function attachSuspenseRetryListeners(finishedWork, wakeables) {
			var retryCache = getRetryCache(finishedWork);
			wakeables.forEach(function(wakeable) {
				var retry = resolveRetryWakeable.bind(null, finishedWork, wakeable);
				retryCache.has(wakeable) || (retryCache.add(wakeable), wakeable.then(retry, retry));
			});
		}
		function recursivelyTraverseMutationEffects(root$jscomp$0, parentFiber) {
			var deletions = parentFiber.deletions;
			if (null !== deletions) for (var i = 0; i < deletions.length; i++) {
				var childToDelete = deletions[i], root = root$jscomp$0, returnFiber = parentFiber;
				if (supportsMutation) {
					var parent = returnFiber;
					a: for (; null !== parent;) {
						switch (parent.tag) {
							case 27: if (supportsSingletons) {
								if (isSingletonScope(parent.type)) {
									hostParent = parent.stateNode;
									hostParentIsContainer = !1;
									break a;
								}
								break;
							}
							case 5:
								hostParent = parent.stateNode;
								hostParentIsContainer = !1;
								break a;
							case 3:
							case 4:
								hostParent = parent.stateNode.containerInfo;
								hostParentIsContainer = !0;
								break a;
						}
						parent = parent.return;
					}
					if (null === hostParent) throw Error(formatProdErrorMessage(160));
					commitDeletionEffectsOnFiber(root, returnFiber, childToDelete);
					hostParent = null;
					hostParentIsContainer = !1;
				} else commitDeletionEffectsOnFiber(root, returnFiber, childToDelete);
				root = childToDelete.alternate;
				null !== root && (root.return = null);
				childToDelete.return = null;
			}
			if (parentFiber.subtreeFlags & 13878) for (parentFiber = parentFiber.child; null !== parentFiber;) commitMutationEffectsOnFiber(parentFiber, root$jscomp$0), parentFiber = parentFiber.sibling;
		}
		function commitMutationEffectsOnFiber(finishedWork, root) {
			var current = finishedWork.alternate, flags = finishedWork.flags;
			switch (finishedWork.tag) {
				case 0:
				case 11:
				case 14:
				case 15:
					recursivelyTraverseMutationEffects(root, finishedWork);
					commitReconciliationEffects(finishedWork);
					flags & 4 && (commitHookEffectListUnmount(3, finishedWork, finishedWork.return), commitHookEffectListMount(3, finishedWork), commitHookEffectListUnmount(5, finishedWork, finishedWork.return));
					break;
				case 1:
					recursivelyTraverseMutationEffects(root, finishedWork);
					commitReconciliationEffects(finishedWork);
					flags & 512 && (offscreenSubtreeWasHidden || null === current || safelyDetachRef(current, current.return));
					flags & 64 && offscreenSubtreeIsHidden && (finishedWork = finishedWork.updateQueue, null !== finishedWork && (flags = finishedWork.callbacks, null !== flags && (current = finishedWork.shared.hiddenCallbacks, finishedWork.shared.hiddenCallbacks = null === current ? flags : current.concat(flags))));
					break;
				case 26: if (supportsResources) {
					var hoistableRoot = currentHoistableRoot;
					recursivelyTraverseMutationEffects(root, finishedWork);
					commitReconciliationEffects(finishedWork);
					flags & 512 && (offscreenSubtreeWasHidden || null === current || safelyDetachRef(current, current.return));
					if (flags & 4) {
						flags = null !== current ? current.memoizedState : null;
						var newResource = finishedWork.memoizedState;
						null === current ? null === newResource ? null === finishedWork.stateNode ? finishedWork.stateNode = hydrateHoistable(hoistableRoot, finishedWork.type, finishedWork.memoizedProps, finishedWork) : mountHoistable(hoistableRoot, finishedWork.type, finishedWork.stateNode) : finishedWork.stateNode = acquireResource(hoistableRoot, newResource, finishedWork.memoizedProps) : flags !== newResource ? (null === flags ? null !== current.stateNode && unmountHoistable(current.stateNode) : releaseResource(flags), null === newResource ? mountHoistable(hoistableRoot, finishedWork.type, finishedWork.stateNode) : acquireResource(hoistableRoot, newResource, finishedWork.memoizedProps)) : null === newResource && null !== finishedWork.stateNode && commitHostUpdate(finishedWork, finishedWork.memoizedProps, current.memoizedProps);
					}
					break;
				}
				case 27: if (supportsSingletons) {
					recursivelyTraverseMutationEffects(root, finishedWork);
					commitReconciliationEffects(finishedWork);
					flags & 512 && (offscreenSubtreeWasHidden || null === current || safelyDetachRef(current, current.return));
					null !== current && flags & 4 && commitHostUpdate(finishedWork, finishedWork.memoizedProps, current.memoizedProps);
					break;
				}
				case 5:
					recursivelyTraverseMutationEffects(root, finishedWork);
					commitReconciliationEffects(finishedWork);
					flags & 512 && (offscreenSubtreeWasHidden || null === current || safelyDetachRef(current, current.return));
					if (supportsMutation) {
						if (finishedWork.flags & 32) {
							hoistableRoot = finishedWork.stateNode;
							try {
								resetTextContent(hoistableRoot);
							} catch (error) {
								captureCommitPhaseError(finishedWork, finishedWork.return, error);
							}
						}
						flags & 4 && null != finishedWork.stateNode && (hoistableRoot = finishedWork.memoizedProps, commitHostUpdate(finishedWork, hoistableRoot, null !== current ? current.memoizedProps : hoistableRoot));
						flags & 1024 && (needsFormReset = !0);
					}
					break;
				case 6:
					recursivelyTraverseMutationEffects(root, finishedWork);
					commitReconciliationEffects(finishedWork);
					if (flags & 4 && supportsMutation) {
						if (null === finishedWork.stateNode) throw Error(formatProdErrorMessage(162));
						flags = finishedWork.memoizedProps;
						current = null !== current ? current.memoizedProps : flags;
						hoistableRoot = finishedWork.stateNode;
						try {
							commitTextUpdate(hoistableRoot, current, flags);
						} catch (error) {
							captureCommitPhaseError(finishedWork, finishedWork.return, error);
						}
					}
					break;
				case 3:
					supportsResources ? (prepareToCommitHoistables(), hoistableRoot = currentHoistableRoot, currentHoistableRoot = getHoistableRoot(root.containerInfo), recursivelyTraverseMutationEffects(root, finishedWork), currentHoistableRoot = hoistableRoot) : recursivelyTraverseMutationEffects(root, finishedWork);
					commitReconciliationEffects(finishedWork);
					if (flags & 4) {
						if (supportsMutation && supportsHydration && null !== current && current.memoizedState.isDehydrated) try {
							commitHydratedContainer(root.containerInfo);
						} catch (error) {
							captureCommitPhaseError(finishedWork, finishedWork.return, error);
						}
						if (supportsPersistence) {
							flags = root.containerInfo;
							current = root.pendingChildren;
							try {
								replaceContainerChildren(flags, current);
							} catch (error) {
								captureCommitPhaseError(finishedWork, finishedWork.return, error);
							}
						}
					}
					needsFormReset && (needsFormReset = !1, recursivelyResetForms(finishedWork));
					break;
				case 4:
					supportsResources ? (current = currentHoistableRoot, currentHoistableRoot = getHoistableRoot(finishedWork.stateNode.containerInfo), recursivelyTraverseMutationEffects(root, finishedWork), commitReconciliationEffects(finishedWork), currentHoistableRoot = current) : (recursivelyTraverseMutationEffects(root, finishedWork), commitReconciliationEffects(finishedWork));
					flags & 4 && supportsPersistence && commitHostPortalContainerChildren(finishedWork.stateNode, finishedWork, finishedWork.stateNode.pendingChildren);
					break;
				case 12:
					recursivelyTraverseMutationEffects(root, finishedWork);
					commitReconciliationEffects(finishedWork);
					break;
				case 13:
					recursivelyTraverseMutationEffects(root, finishedWork);
					commitReconciliationEffects(finishedWork);
					finishedWork.child.flags & 8192 && null !== finishedWork.memoizedState !== (null !== current && null !== current.memoizedState) && (globalMostRecentFallbackTime = now());
					flags & 4 && (flags = finishedWork.updateQueue, null !== flags && (finishedWork.updateQueue = null, attachSuspenseRetryListeners(finishedWork, flags)));
					break;
				case 22:
					hoistableRoot = null !== finishedWork.memoizedState;
					var wasHidden = null !== current && null !== current.memoizedState, prevOffscreenSubtreeIsHidden = offscreenSubtreeIsHidden, prevOffscreenSubtreeWasHidden = offscreenSubtreeWasHidden;
					offscreenSubtreeIsHidden = prevOffscreenSubtreeIsHidden || hoistableRoot;
					offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden || wasHidden;
					recursivelyTraverseMutationEffects(root, finishedWork);
					offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden;
					offscreenSubtreeIsHidden = prevOffscreenSubtreeIsHidden;
					commitReconciliationEffects(finishedWork);
					if (flags & 8192 && (root = finishedWork.stateNode, root._visibility = hoistableRoot ? root._visibility & -2 : root._visibility | 1, hoistableRoot && (null === current || wasHidden || offscreenSubtreeIsHidden || offscreenSubtreeWasHidden || recursivelyTraverseDisappearLayoutEffects(finishedWork)), supportsMutation)) {
						a: if (current = null, supportsMutation) for (root = finishedWork;;) {
							if (5 === root.tag || supportsResources && 26 === root.tag) {
								if (null === current) {
									wasHidden = current = root;
									try {
										newResource = wasHidden.stateNode, hoistableRoot ? hideInstance(newResource) : unhideInstance(wasHidden.stateNode, wasHidden.memoizedProps);
									} catch (error) {
										captureCommitPhaseError(wasHidden, wasHidden.return, error);
									}
								}
							} else if (6 === root.tag) {
								if (null === current) {
									wasHidden = root;
									try {
										var instance = wasHidden.stateNode;
										hoistableRoot ? hideTextInstance(instance) : unhideTextInstance(instance, wasHidden.memoizedProps);
									} catch (error) {
										captureCommitPhaseError(wasHidden, wasHidden.return, error);
									}
								}
							} else if ((22 !== root.tag && 23 !== root.tag || null === root.memoizedState || root === finishedWork) && null !== root.child) {
								root.child.return = root;
								root = root.child;
								continue;
							}
							if (root === finishedWork) break a;
							for (; null === root.sibling;) {
								if (null === root.return || root.return === finishedWork) break a;
								current === root && (current = null);
								root = root.return;
							}
							current === root && (current = null);
							root.sibling.return = root.return;
							root = root.sibling;
						}
					}
					flags & 4 && (flags = finishedWork.updateQueue, null !== flags && (current = flags.retryQueue, null !== current && (flags.retryQueue = null, attachSuspenseRetryListeners(finishedWork, current))));
					break;
				case 19:
					recursivelyTraverseMutationEffects(root, finishedWork);
					commitReconciliationEffects(finishedWork);
					flags & 4 && (flags = finishedWork.updateQueue, null !== flags && (finishedWork.updateQueue = null, attachSuspenseRetryListeners(finishedWork, flags)));
					break;
				case 30: break;
				case 21: break;
				default: recursivelyTraverseMutationEffects(root, finishedWork), commitReconciliationEffects(finishedWork);
			}
		}
		function commitReconciliationEffects(finishedWork) {
			var flags = finishedWork.flags;
			if (flags & 2) {
				try {
					if (supportsMutation) {
						for (var hostParentFiber, parentFiber = finishedWork.return; null !== parentFiber;) {
							if (isHostParent(parentFiber)) {
								hostParentFiber = parentFiber;
								break;
							}
							parentFiber = parentFiber.return;
						}
						if (null == hostParentFiber) throw Error(formatProdErrorMessage(160));
						switch (hostParentFiber.tag) {
							case 27: if (supportsSingletons) {
								var parent = hostParentFiber.stateNode;
								insertOrAppendPlacementNode(finishedWork, getHostSibling(finishedWork), parent);
								break;
							}
							case 5:
								var parent$130 = hostParentFiber.stateNode;
								hostParentFiber.flags & 32 && (resetTextContent(parent$130), hostParentFiber.flags &= -33);
								insertOrAppendPlacementNode(finishedWork, getHostSibling(finishedWork), parent$130);
								break;
							case 3:
							case 4:
								var parent$132 = hostParentFiber.stateNode.containerInfo;
								insertOrAppendPlacementNodeIntoContainer(finishedWork, getHostSibling(finishedWork), parent$132);
								break;
							default: throw Error(formatProdErrorMessage(161));
						}
					}
				} catch (error) {
					captureCommitPhaseError(finishedWork, finishedWork.return, error);
				}
				finishedWork.flags &= -3;
			}
			flags & 4096 && (finishedWork.flags &= -4097);
		}
		function recursivelyResetForms(parentFiber) {
			if (parentFiber.subtreeFlags & 1024) for (parentFiber = parentFiber.child; null !== parentFiber;) {
				var fiber = parentFiber;
				recursivelyResetForms(fiber);
				5 === fiber.tag && fiber.flags & 1024 && resetFormInstance(fiber.stateNode);
				parentFiber = parentFiber.sibling;
			}
		}
		function recursivelyTraverseLayoutEffects(root, parentFiber) {
			if (parentFiber.subtreeFlags & 8772) for (parentFiber = parentFiber.child; null !== parentFiber;) commitLayoutEffectOnFiber(root, parentFiber.alternate, parentFiber), parentFiber = parentFiber.sibling;
		}
		function recursivelyTraverseDisappearLayoutEffects(parentFiber) {
			for (parentFiber = parentFiber.child; null !== parentFiber;) {
				var finishedWork = parentFiber;
				switch (finishedWork.tag) {
					case 0:
					case 11:
					case 14:
					case 15:
						commitHookEffectListUnmount(4, finishedWork, finishedWork.return);
						recursivelyTraverseDisappearLayoutEffects(finishedWork);
						break;
					case 1:
						safelyDetachRef(finishedWork, finishedWork.return);
						var instance = finishedWork.stateNode;
						"function" === typeof instance.componentWillUnmount && safelyCallComponentWillUnmount(finishedWork, finishedWork.return, instance);
						recursivelyTraverseDisappearLayoutEffects(finishedWork);
						break;
					case 27: supportsSingletons && releaseSingletonInstance(finishedWork.stateNode);
					case 26:
					case 5:
						safelyDetachRef(finishedWork, finishedWork.return);
						recursivelyTraverseDisappearLayoutEffects(finishedWork);
						break;
					case 22:
						null === finishedWork.memoizedState && recursivelyTraverseDisappearLayoutEffects(finishedWork);
						break;
					case 30:
						recursivelyTraverseDisappearLayoutEffects(finishedWork);
						break;
					default: recursivelyTraverseDisappearLayoutEffects(finishedWork);
				}
				parentFiber = parentFiber.sibling;
			}
		}
		function recursivelyTraverseReappearLayoutEffects(finishedRoot$jscomp$0, parentFiber, includeWorkInProgressEffects) {
			includeWorkInProgressEffects = includeWorkInProgressEffects && 0 !== (parentFiber.subtreeFlags & 8772);
			for (parentFiber = parentFiber.child; null !== parentFiber;) {
				var current = parentFiber.alternate, finishedRoot = finishedRoot$jscomp$0, finishedWork = parentFiber, flags = finishedWork.flags;
				switch (finishedWork.tag) {
					case 0:
					case 11:
					case 15:
						recursivelyTraverseReappearLayoutEffects(finishedRoot, finishedWork, includeWorkInProgressEffects);
						commitHookEffectListMount(4, finishedWork);
						break;
					case 1:
						recursivelyTraverseReappearLayoutEffects(finishedRoot, finishedWork, includeWorkInProgressEffects);
						current = finishedWork;
						finishedRoot = current.stateNode;
						if ("function" === typeof finishedRoot.componentDidMount) try {
							finishedRoot.componentDidMount();
						} catch (error) {
							captureCommitPhaseError(current, current.return, error);
						}
						current = finishedWork;
						finishedRoot = current.updateQueue;
						if (null !== finishedRoot) {
							var instance = current.stateNode;
							try {
								var hiddenCallbacks = finishedRoot.shared.hiddenCallbacks;
								if (null !== hiddenCallbacks) for (finishedRoot.shared.hiddenCallbacks = null, finishedRoot = 0; finishedRoot < hiddenCallbacks.length; finishedRoot++) callCallback(hiddenCallbacks[finishedRoot], instance);
							} catch (error) {
								captureCommitPhaseError(current, current.return, error);
							}
						}
						includeWorkInProgressEffects && flags & 64 && commitClassCallbacks(finishedWork);
						safelyAttachRef(finishedWork, finishedWork.return);
						break;
					case 27: supportsSingletons && commitHostSingletonAcquisition(finishedWork);
					case 26:
					case 5:
						recursivelyTraverseReappearLayoutEffects(finishedRoot, finishedWork, includeWorkInProgressEffects);
						includeWorkInProgressEffects && null === current && flags & 4 && commitHostMount(finishedWork);
						safelyAttachRef(finishedWork, finishedWork.return);
						break;
					case 12:
						recursivelyTraverseReappearLayoutEffects(finishedRoot, finishedWork, includeWorkInProgressEffects);
						break;
					case 13:
						recursivelyTraverseReappearLayoutEffects(finishedRoot, finishedWork, includeWorkInProgressEffects);
						includeWorkInProgressEffects && flags & 4 && commitSuspenseHydrationCallbacks(finishedRoot, finishedWork);
						break;
					case 22:
						null === finishedWork.memoizedState && recursivelyTraverseReappearLayoutEffects(finishedRoot, finishedWork, includeWorkInProgressEffects);
						safelyAttachRef(finishedWork, finishedWork.return);
						break;
					case 30: break;
					default: recursivelyTraverseReappearLayoutEffects(finishedRoot, finishedWork, includeWorkInProgressEffects);
				}
				parentFiber = parentFiber.sibling;
			}
		}
		function commitOffscreenPassiveMountEffects(current, finishedWork) {
			var previousCache = null;
			null !== current && null !== current.memoizedState && null !== current.memoizedState.cachePool && (previousCache = current.memoizedState.cachePool.pool);
			current = null;
			null !== finishedWork.memoizedState && null !== finishedWork.memoizedState.cachePool && (current = finishedWork.memoizedState.cachePool.pool);
			current !== previousCache && (null != current && current.refCount++, null != previousCache && releaseCache(previousCache));
		}
		function commitCachePassiveMountEffect(current, finishedWork) {
			current = null;
			null !== finishedWork.alternate && (current = finishedWork.alternate.memoizedState.cache);
			finishedWork = finishedWork.memoizedState.cache;
			finishedWork !== current && (finishedWork.refCount++, null != current && releaseCache(current));
		}
		function recursivelyTraversePassiveMountEffects(root, parentFiber, committedLanes, committedTransitions) {
			if (parentFiber.subtreeFlags & 10256) for (parentFiber = parentFiber.child; null !== parentFiber;) commitPassiveMountOnFiber(root, parentFiber, committedLanes, committedTransitions), parentFiber = parentFiber.sibling;
		}
		function commitPassiveMountOnFiber(finishedRoot, finishedWork, committedLanes, committedTransitions) {
			var flags = finishedWork.flags;
			switch (finishedWork.tag) {
				case 0:
				case 11:
				case 15:
					recursivelyTraversePassiveMountEffects(finishedRoot, finishedWork, committedLanes, committedTransitions);
					flags & 2048 && commitHookEffectListMount(9, finishedWork);
					break;
				case 1:
					recursivelyTraversePassiveMountEffects(finishedRoot, finishedWork, committedLanes, committedTransitions);
					break;
				case 3:
					recursivelyTraversePassiveMountEffects(finishedRoot, finishedWork, committedLanes, committedTransitions);
					flags & 2048 && (finishedRoot = null, null !== finishedWork.alternate && (finishedRoot = finishedWork.alternate.memoizedState.cache), finishedWork = finishedWork.memoizedState.cache, finishedWork !== finishedRoot && (finishedWork.refCount++, null != finishedRoot && releaseCache(finishedRoot)));
					break;
				case 12:
					if (flags & 2048) {
						recursivelyTraversePassiveMountEffects(finishedRoot, finishedWork, committedLanes, committedTransitions);
						finishedRoot = finishedWork.stateNode;
						try {
							var _finishedWork$memoize2 = finishedWork.memoizedProps, id = _finishedWork$memoize2.id, onPostCommit = _finishedWork$memoize2.onPostCommit;
							"function" === typeof onPostCommit && onPostCommit(id, null === finishedWork.alternate ? "mount" : "update", finishedRoot.passiveEffectDuration, -0);
						} catch (error) {
							captureCommitPhaseError(finishedWork, finishedWork.return, error);
						}
					} else recursivelyTraversePassiveMountEffects(finishedRoot, finishedWork, committedLanes, committedTransitions);
					break;
				case 13:
					recursivelyTraversePassiveMountEffects(finishedRoot, finishedWork, committedLanes, committedTransitions);
					break;
				case 23: break;
				case 22:
					_finishedWork$memoize2 = finishedWork.stateNode;
					id = finishedWork.alternate;
					null !== finishedWork.memoizedState ? _finishedWork$memoize2._visibility & 2 ? recursivelyTraversePassiveMountEffects(finishedRoot, finishedWork, committedLanes, committedTransitions) : recursivelyTraverseAtomicPassiveEffects(finishedRoot, finishedWork) : _finishedWork$memoize2._visibility & 2 ? recursivelyTraversePassiveMountEffects(finishedRoot, finishedWork, committedLanes, committedTransitions) : (_finishedWork$memoize2._visibility |= 2, recursivelyTraverseReconnectPassiveEffects(finishedRoot, finishedWork, committedLanes, committedTransitions, 0 !== (finishedWork.subtreeFlags & 10256)));
					flags & 2048 && commitOffscreenPassiveMountEffects(id, finishedWork);
					break;
				case 24:
					recursivelyTraversePassiveMountEffects(finishedRoot, finishedWork, committedLanes, committedTransitions);
					flags & 2048 && commitCachePassiveMountEffect(finishedWork.alternate, finishedWork);
					break;
				default: recursivelyTraversePassiveMountEffects(finishedRoot, finishedWork, committedLanes, committedTransitions);
			}
		}
		function recursivelyTraverseReconnectPassiveEffects(finishedRoot$jscomp$0, parentFiber, committedLanes$jscomp$0, committedTransitions$jscomp$0, includeWorkInProgressEffects) {
			includeWorkInProgressEffects = includeWorkInProgressEffects && 0 !== (parentFiber.subtreeFlags & 10256);
			for (parentFiber = parentFiber.child; null !== parentFiber;) {
				var finishedRoot = finishedRoot$jscomp$0, finishedWork = parentFiber, committedLanes = committedLanes$jscomp$0, committedTransitions = committedTransitions$jscomp$0, flags = finishedWork.flags;
				switch (finishedWork.tag) {
					case 0:
					case 11:
					case 15:
						recursivelyTraverseReconnectPassiveEffects(finishedRoot, finishedWork, committedLanes, committedTransitions, includeWorkInProgressEffects);
						commitHookEffectListMount(8, finishedWork);
						break;
					case 23: break;
					case 22:
						var instance = finishedWork.stateNode;
						null !== finishedWork.memoizedState ? instance._visibility & 2 ? recursivelyTraverseReconnectPassiveEffects(finishedRoot, finishedWork, committedLanes, committedTransitions, includeWorkInProgressEffects) : recursivelyTraverseAtomicPassiveEffects(finishedRoot, finishedWork) : (instance._visibility |= 2, recursivelyTraverseReconnectPassiveEffects(finishedRoot, finishedWork, committedLanes, committedTransitions, includeWorkInProgressEffects));
						includeWorkInProgressEffects && flags & 2048 && commitOffscreenPassiveMountEffects(finishedWork.alternate, finishedWork);
						break;
					case 24:
						recursivelyTraverseReconnectPassiveEffects(finishedRoot, finishedWork, committedLanes, committedTransitions, includeWorkInProgressEffects);
						includeWorkInProgressEffects && flags & 2048 && commitCachePassiveMountEffect(finishedWork.alternate, finishedWork);
						break;
					default: recursivelyTraverseReconnectPassiveEffects(finishedRoot, finishedWork, committedLanes, committedTransitions, includeWorkInProgressEffects);
				}
				parentFiber = parentFiber.sibling;
			}
		}
		function recursivelyTraverseAtomicPassiveEffects(finishedRoot$jscomp$0, parentFiber) {
			if (parentFiber.subtreeFlags & 10256) for (parentFiber = parentFiber.child; null !== parentFiber;) {
				var finishedRoot = finishedRoot$jscomp$0, finishedWork = parentFiber, flags = finishedWork.flags;
				switch (finishedWork.tag) {
					case 22:
						recursivelyTraverseAtomicPassiveEffects(finishedRoot, finishedWork);
						flags & 2048 && commitOffscreenPassiveMountEffects(finishedWork.alternate, finishedWork);
						break;
					case 24:
						recursivelyTraverseAtomicPassiveEffects(finishedRoot, finishedWork);
						flags & 2048 && commitCachePassiveMountEffect(finishedWork.alternate, finishedWork);
						break;
					default: recursivelyTraverseAtomicPassiveEffects(finishedRoot, finishedWork);
				}
				parentFiber = parentFiber.sibling;
			}
		}
		function recursivelyAccumulateSuspenseyCommit(parentFiber) {
			if (parentFiber.subtreeFlags & suspenseyCommitFlag) for (parentFiber = parentFiber.child; null !== parentFiber;) accumulateSuspenseyCommitOnFiber(parentFiber), parentFiber = parentFiber.sibling;
		}
		function accumulateSuspenseyCommitOnFiber(fiber) {
			switch (fiber.tag) {
				case 26:
					recursivelyAccumulateSuspenseyCommit(fiber);
					fiber.flags & suspenseyCommitFlag && (null !== fiber.memoizedState ? suspendResource(currentHoistableRoot, fiber.memoizedState, fiber.memoizedProps) : suspendInstance(fiber.type, fiber.memoizedProps));
					break;
				case 5:
					recursivelyAccumulateSuspenseyCommit(fiber);
					fiber.flags & suspenseyCommitFlag && suspendInstance(fiber.type, fiber.memoizedProps);
					break;
				case 3:
				case 4:
					if (supportsResources) {
						var previousHoistableRoot = currentHoistableRoot;
						currentHoistableRoot = getHoistableRoot(fiber.stateNode.containerInfo);
						recursivelyAccumulateSuspenseyCommit(fiber);
						currentHoistableRoot = previousHoistableRoot;
					} else recursivelyAccumulateSuspenseyCommit(fiber);
					break;
				case 22:
					null === fiber.memoizedState && (previousHoistableRoot = fiber.alternate, null !== previousHoistableRoot && null !== previousHoistableRoot.memoizedState ? (previousHoistableRoot = suspenseyCommitFlag, suspenseyCommitFlag = 16777216, recursivelyAccumulateSuspenseyCommit(fiber), suspenseyCommitFlag = previousHoistableRoot) : recursivelyAccumulateSuspenseyCommit(fiber));
					break;
				default: recursivelyAccumulateSuspenseyCommit(fiber);
			}
		}
		function detachAlternateSiblings(parentFiber) {
			var previousFiber = parentFiber.alternate;
			if (null !== previousFiber && (parentFiber = previousFiber.child, null !== parentFiber)) {
				previousFiber.child = null;
				do
					previousFiber = parentFiber.sibling, parentFiber.sibling = null, parentFiber = previousFiber;
				while (null !== parentFiber);
			}
		}
		function recursivelyTraversePassiveUnmountEffects(parentFiber) {
			var deletions = parentFiber.deletions;
			if (0 !== (parentFiber.flags & 16)) {
				if (null !== deletions) for (var i = 0; i < deletions.length; i++) {
					var childToDelete = deletions[i];
					nextEffect = childToDelete;
					commitPassiveUnmountEffectsInsideOfDeletedTree_begin(childToDelete, parentFiber);
				}
				detachAlternateSiblings(parentFiber);
			}
			if (parentFiber.subtreeFlags & 10256) for (parentFiber = parentFiber.child; null !== parentFiber;) commitPassiveUnmountOnFiber(parentFiber), parentFiber = parentFiber.sibling;
		}
		function commitPassiveUnmountOnFiber(finishedWork) {
			switch (finishedWork.tag) {
				case 0:
				case 11:
				case 15:
					recursivelyTraversePassiveUnmountEffects(finishedWork);
					finishedWork.flags & 2048 && commitHookEffectListUnmount(9, finishedWork, finishedWork.return);
					break;
				case 3:
					recursivelyTraversePassiveUnmountEffects(finishedWork);
					break;
				case 12:
					recursivelyTraversePassiveUnmountEffects(finishedWork);
					break;
				case 22:
					var instance = finishedWork.stateNode;
					null !== finishedWork.memoizedState && instance._visibility & 2 && (null === finishedWork.return || 13 !== finishedWork.return.tag) ? (instance._visibility &= -3, recursivelyTraverseDisconnectPassiveEffects(finishedWork)) : recursivelyTraversePassiveUnmountEffects(finishedWork);
					break;
				default: recursivelyTraversePassiveUnmountEffects(finishedWork);
			}
		}
		function recursivelyTraverseDisconnectPassiveEffects(parentFiber) {
			var deletions = parentFiber.deletions;
			if (0 !== (parentFiber.flags & 16)) {
				if (null !== deletions) for (var i = 0; i < deletions.length; i++) {
					var childToDelete = deletions[i];
					nextEffect = childToDelete;
					commitPassiveUnmountEffectsInsideOfDeletedTree_begin(childToDelete, parentFiber);
				}
				detachAlternateSiblings(parentFiber);
			}
			for (parentFiber = parentFiber.child; null !== parentFiber;) {
				deletions = parentFiber;
				switch (deletions.tag) {
					case 0:
					case 11:
					case 15:
						commitHookEffectListUnmount(8, deletions, deletions.return);
						recursivelyTraverseDisconnectPassiveEffects(deletions);
						break;
					case 22:
						i = deletions.stateNode;
						i._visibility & 2 && (i._visibility &= -3, recursivelyTraverseDisconnectPassiveEffects(deletions));
						break;
					default: recursivelyTraverseDisconnectPassiveEffects(deletions);
				}
				parentFiber = parentFiber.sibling;
			}
		}
		function commitPassiveUnmountEffectsInsideOfDeletedTree_begin(deletedSubtreeRoot, nearestMountedAncestor) {
			for (; null !== nextEffect;) {
				var fiber = nextEffect;
				switch (fiber.tag) {
					case 0:
					case 11:
					case 15:
						commitHookEffectListUnmount(8, fiber, nearestMountedAncestor);
						break;
					case 23:
					case 22:
						if (null !== fiber.memoizedState && null !== fiber.memoizedState.cachePool) {
							var cache$4 = fiber.memoizedState.cachePool.pool;
							null != cache$4 && cache$4.refCount++;
						}
						break;
					case 24: releaseCache(fiber.memoizedState.cache);
				}
				cache$4 = fiber.child;
				if (null !== cache$4) cache$4.return = fiber, nextEffect = cache$4;
				else a: for (fiber = deletedSubtreeRoot; null !== nextEffect;) {
					cache$4 = nextEffect;
					var sibling = cache$4.sibling, returnFiber = cache$4.return;
					detachFiberAfterEffects(cache$4);
					if (cache$4 === fiber) {
						nextEffect = null;
						break a;
					}
					if (null !== sibling) {
						sibling.return = returnFiber;
						nextEffect = sibling;
						break a;
					}
					nextEffect = returnFiber;
				}
			}
		}
		function findFiberRootForHostRoot(hostRoot) {
			var maybeFiber = getInstanceFromNode(hostRoot);
			if (null != maybeFiber) {
				if ("string" !== typeof maybeFiber.memoizedProps["data-testname"]) throw Error(formatProdErrorMessage(364));
				return maybeFiber;
			}
			hostRoot = findFiberRoot(hostRoot);
			if (null === hostRoot) throw Error(formatProdErrorMessage(362));
			return hostRoot.stateNode.current;
		}
		function matchSelector(fiber$jscomp$0, selector) {
			var tag = fiber$jscomp$0.tag;
			switch (selector.$$typeof) {
				case COMPONENT_TYPE:
					if (fiber$jscomp$0.type === selector.value) return !0;
					break;
				case HAS_PSEUDO_CLASS_TYPE:
					a: {
						selector = selector.value;
						fiber$jscomp$0 = [fiber$jscomp$0, 0];
						for (tag = 0; tag < fiber$jscomp$0.length;) {
							var fiber = fiber$jscomp$0[tag++], tag$jscomp$0 = fiber.tag, selectorIndex = fiber$jscomp$0[tag++], selector$jscomp$0 = selector[selectorIndex];
							if (5 !== tag$jscomp$0 && 26 !== tag$jscomp$0 && 27 !== tag$jscomp$0 || !isHiddenSubtree(fiber)) {
								for (; null != selector$jscomp$0 && matchSelector(fiber, selector$jscomp$0);) selectorIndex++, selector$jscomp$0 = selector[selectorIndex];
								if (selectorIndex === selector.length) {
									selector = !0;
									break a;
								} else for (fiber = fiber.child; null !== fiber;) fiber$jscomp$0.push(fiber, selectorIndex), fiber = fiber.sibling;
							}
						}
						selector = !1;
					}
					return selector;
				case ROLE_TYPE:
					if ((5 === tag || 26 === tag || 27 === tag) && matchAccessibilityRole(fiber$jscomp$0.stateNode, selector.value)) return !0;
					break;
				case TEXT_TYPE:
					if (5 === tag || 6 === tag || 26 === tag || 27 === tag) {
						if (fiber$jscomp$0 = getTextContent(fiber$jscomp$0), null !== fiber$jscomp$0 && 0 <= fiber$jscomp$0.indexOf(selector.value)) return !0;
					}
					break;
				case TEST_NAME_TYPE:
					if (5 === tag || 26 === tag || 27 === tag) {
						if (fiber$jscomp$0 = fiber$jscomp$0.memoizedProps["data-testname"], "string" === typeof fiber$jscomp$0 && fiber$jscomp$0.toLowerCase() === selector.value.toLowerCase()) return !0;
					}
					break;
				default: throw Error(formatProdErrorMessage(365));
			}
			return !1;
		}
		function selectorToString(selector) {
			switch (selector.$$typeof) {
				case COMPONENT_TYPE: return "<" + (getComponentNameFromType(selector.value) || "Unknown") + ">";
				case HAS_PSEUDO_CLASS_TYPE: return ":has(" + (selectorToString(selector) || "") + ")";
				case ROLE_TYPE: return "[role=\"" + selector.value + "\"]";
				case TEXT_TYPE: return "\"" + selector.value + "\"";
				case TEST_NAME_TYPE: return "[data-testname=\"" + selector.value + "\"]";
				default: throw Error(formatProdErrorMessage(365));
			}
		}
		function findPaths(root, selectors) {
			var matchingFibers = [];
			root = [root, 0];
			for (var index = 0; index < root.length;) {
				var fiber = root[index++], tag = fiber.tag, selectorIndex = root[index++], selector = selectors[selectorIndex];
				if (5 !== tag && 26 !== tag && 27 !== tag || !isHiddenSubtree(fiber)) {
					for (; null != selector && matchSelector(fiber, selector);) selectorIndex++, selector = selectors[selectorIndex];
					if (selectorIndex === selectors.length) matchingFibers.push(fiber);
					else for (fiber = fiber.child; null !== fiber;) root.push(fiber, selectorIndex), fiber = fiber.sibling;
				}
			}
			return matchingFibers;
		}
		function findAllNodes(hostRoot, selectors) {
			if (!supportsTestSelectors) throw Error(formatProdErrorMessage(363));
			hostRoot = findFiberRootForHostRoot(hostRoot);
			hostRoot = findPaths(hostRoot, selectors);
			selectors = [];
			hostRoot = Array.from(hostRoot);
			for (var index = 0; index < hostRoot.length;) {
				var node = hostRoot[index++], tag = node.tag;
				if (5 === tag || 26 === tag || 27 === tag) isHiddenSubtree(node) || selectors.push(node.stateNode);
				else for (node = node.child; null !== node;) hostRoot.push(node), node = node.sibling;
			}
			return selectors;
		}
		function requestUpdateLane() {
			if (0 !== (executionContext & 2) && 0 !== workInProgressRootRenderLanes) return workInProgressRootRenderLanes & -workInProgressRootRenderLanes;
			if (null !== ReactSharedInternals$1.T) {
				var actionScopeLane = currentEntangledLane;
				return 0 !== actionScopeLane ? actionScopeLane : requestTransitionLane();
			}
			return resolveUpdatePriority();
		}
		function requestDeferredLane() {
			0 === workInProgressDeferredLane && (workInProgressDeferredLane = 0 === (workInProgressRootRenderLanes & 536870912) || isHydrating ? claimNextTransitionLane() : 536870912);
			var suspenseHandler = suspenseHandlerStackCursor.current;
			null !== suspenseHandler && (suspenseHandler.flags |= 32);
			return workInProgressDeferredLane;
		}
		function scheduleUpdateOnFiber(root, fiber, lane) {
			if (root === workInProgressRoot && (2 === workInProgressSuspendedReason || 9 === workInProgressSuspendedReason) || null !== root.cancelPendingCommit) prepareFreshStack(root, 0), markRootSuspended(root, workInProgressRootRenderLanes, workInProgressDeferredLane, !1);
			markRootUpdated$1(root, lane);
			if (0 === (executionContext & 2) || root !== workInProgressRoot) root === workInProgressRoot && (0 === (executionContext & 2) && (workInProgressRootInterleavedUpdatedLanes |= lane), 4 === workInProgressRootExitStatus && markRootSuspended(root, workInProgressRootRenderLanes, workInProgressDeferredLane, !1)), ensureRootIsScheduled(root);
		}
		function performWorkOnRoot(root$jscomp$0, lanes, forceSync) {
			if (0 !== (executionContext & 6)) throw Error(formatProdErrorMessage(327));
			var shouldTimeSlice = !forceSync && 0 === (lanes & 124) && 0 === (lanes & root$jscomp$0.expiredLanes) || checkIfRootIsPrerendering(root$jscomp$0, lanes), exitStatus = shouldTimeSlice ? renderRootConcurrent(root$jscomp$0, lanes) : renderRootSync(root$jscomp$0, lanes, !0), renderWasConcurrent = shouldTimeSlice;
			do {
				if (0 === exitStatus) {
					workInProgressRootIsPrerendering && !shouldTimeSlice && markRootSuspended(root$jscomp$0, lanes, 0, !1);
					break;
				} else {
					forceSync = root$jscomp$0.current.alternate;
					if (renderWasConcurrent && !isRenderConsistentWithExternalStores(forceSync)) {
						exitStatus = renderRootSync(root$jscomp$0, lanes, !1);
						renderWasConcurrent = !1;
						continue;
					}
					if (2 === exitStatus) {
						renderWasConcurrent = lanes;
						if (root$jscomp$0.errorRecoveryDisabledLanes & renderWasConcurrent) var JSCompiler_inline_result = 0;
						else JSCompiler_inline_result = root$jscomp$0.pendingLanes & -536870913, JSCompiler_inline_result = 0 !== JSCompiler_inline_result ? JSCompiler_inline_result : JSCompiler_inline_result & 536870912 ? 536870912 : 0;
						if (0 !== JSCompiler_inline_result) {
							lanes = JSCompiler_inline_result;
							a: {
								var root = root$jscomp$0;
								exitStatus = workInProgressRootConcurrentErrors;
								var wasRootDehydrated = supportsHydration && root.current.memoizedState.isDehydrated;
								wasRootDehydrated && (prepareFreshStack(root, JSCompiler_inline_result).flags |= 256);
								JSCompiler_inline_result = renderRootSync(root, JSCompiler_inline_result, !1);
								if (2 !== JSCompiler_inline_result) {
									if (workInProgressRootDidAttachPingListener && !wasRootDehydrated) {
										root.errorRecoveryDisabledLanes |= renderWasConcurrent;
										workInProgressRootInterleavedUpdatedLanes |= renderWasConcurrent;
										exitStatus = 4;
										break a;
									}
									renderWasConcurrent = workInProgressRootRecoverableErrors;
									workInProgressRootRecoverableErrors = exitStatus;
									null !== renderWasConcurrent && (null === workInProgressRootRecoverableErrors ? workInProgressRootRecoverableErrors = renderWasConcurrent : workInProgressRootRecoverableErrors.push.apply(workInProgressRootRecoverableErrors, renderWasConcurrent));
								}
								exitStatus = JSCompiler_inline_result;
							}
							renderWasConcurrent = !1;
							if (2 !== exitStatus) continue;
						}
					}
					if (1 === exitStatus) {
						prepareFreshStack(root$jscomp$0, 0);
						markRootSuspended(root$jscomp$0, lanes, 0, !0);
						break;
					}
					a: {
						shouldTimeSlice = root$jscomp$0;
						renderWasConcurrent = exitStatus;
						switch (renderWasConcurrent) {
							case 0:
							case 1: throw Error(formatProdErrorMessage(345));
							case 4: if ((lanes & 4194048) !== lanes) break;
							case 6:
								markRootSuspended(shouldTimeSlice, lanes, workInProgressDeferredLane, !workInProgressRootDidSkipSuspendedSiblings);
								break a;
							case 2:
								workInProgressRootRecoverableErrors = null;
								break;
							case 3:
							case 5: break;
							default: throw Error(formatProdErrorMessage(329));
						}
						if ((lanes & 62914560) === lanes && (exitStatus = globalMostRecentFallbackTime + 300 - now(), 10 < exitStatus)) {
							markRootSuspended(shouldTimeSlice, lanes, workInProgressDeferredLane, !workInProgressRootDidSkipSuspendedSiblings);
							if (0 !== getNextLanes(shouldTimeSlice, 0, !0)) break a;
							shouldTimeSlice.timeoutHandle = scheduleTimeout(commitRootWhenReady.bind(null, shouldTimeSlice, forceSync, workInProgressRootRecoverableErrors, workInProgressTransitions, workInProgressRootDidIncludeRecursiveRenderUpdate, lanes, workInProgressDeferredLane, workInProgressRootInterleavedUpdatedLanes, workInProgressSuspendedRetryLanes, workInProgressRootDidSkipSuspendedSiblings, renderWasConcurrent, 2, -0, 0), exitStatus);
							break a;
						}
						commitRootWhenReady(shouldTimeSlice, forceSync, workInProgressRootRecoverableErrors, workInProgressTransitions, workInProgressRootDidIncludeRecursiveRenderUpdate, lanes, workInProgressDeferredLane, workInProgressRootInterleavedUpdatedLanes, workInProgressSuspendedRetryLanes, workInProgressRootDidSkipSuspendedSiblings, renderWasConcurrent, 0, -0, 0);
					}
				}
				break;
			} while (1);
			ensureRootIsScheduled(root$jscomp$0);
		}
		function commitRootWhenReady(root, finishedWork, recoverableErrors, transitions, didIncludeRenderPhaseUpdate, lanes, spawnedLane, updatedLanes, suspendedRetryLanes, didSkipSuspendedSiblings, exitStatus, suspendedCommitReason, completedRenderStartTime, completedRenderEndTime) {
			root.timeoutHandle = noTimeout;
			suspendedCommitReason = finishedWork.subtreeFlags;
			if (suspendedCommitReason & 8192 || 16785408 === (suspendedCommitReason & 16785408)) {
				if (startSuspendingCommit(), accumulateSuspenseyCommitOnFiber(finishedWork), suspendedCommitReason = waitForCommitToBeReady(), null !== suspendedCommitReason) {
					root.cancelPendingCommit = suspendedCommitReason(commitRoot.bind(null, root, finishedWork, lanes, recoverableErrors, transitions, didIncludeRenderPhaseUpdate, spawnedLane, updatedLanes, suspendedRetryLanes, exitStatus, 1, completedRenderStartTime, completedRenderEndTime));
					markRootSuspended(root, lanes, spawnedLane, !didSkipSuspendedSiblings);
					return;
				}
			}
			commitRoot(root, finishedWork, lanes, recoverableErrors, transitions, didIncludeRenderPhaseUpdate, spawnedLane, updatedLanes, suspendedRetryLanes);
		}
		function isRenderConsistentWithExternalStores(finishedWork) {
			for (var node = finishedWork;;) {
				var tag = node.tag;
				if ((0 === tag || 11 === tag || 15 === tag) && node.flags & 16384 && (tag = node.updateQueue, null !== tag && (tag = tag.stores, null !== tag))) for (var i = 0; i < tag.length; i++) {
					var check$1 = tag[i], getSnapshot = check$1.getSnapshot;
					check$1 = check$1.value;
					try {
						if (!objectIs(getSnapshot(), check$1)) return !1;
					} catch (error) {
						return !1;
					}
				}
				tag = node.child;
				if (node.subtreeFlags & 16384 && null !== tag) tag.return = node, node = tag;
				else {
					if (node === finishedWork) break;
					for (; null === node.sibling;) {
						if (null === node.return || node.return === finishedWork) return !0;
						node = node.return;
					}
					node.sibling.return = node.return;
					node = node.sibling;
				}
			}
			return !0;
		}
		function markRootSuspended(root, suspendedLanes, spawnedLane, didAttemptEntireTree) {
			suspendedLanes &= ~workInProgressRootPingedLanes;
			suspendedLanes &= ~workInProgressRootInterleavedUpdatedLanes;
			root.suspendedLanes |= suspendedLanes;
			root.pingedLanes &= ~suspendedLanes;
			didAttemptEntireTree && (root.warmLanes |= suspendedLanes);
			didAttemptEntireTree = root.expirationTimes;
			for (var lanes = suspendedLanes; 0 < lanes;) {
				var index$4 = 31 - clz32(lanes), lane = 1 << index$4;
				didAttemptEntireTree[index$4] = -1;
				lanes &= ~lane;
			}
			0 !== spawnedLane && markSpawnedDeferredLane(root, spawnedLane, suspendedLanes);
		}
		function flushSyncWork() {
			return 0 === (executionContext & 6) ? (flushSyncWorkAcrossRoots_impl(0, !1), !1) : !0;
		}
		function resetWorkInProgressStack() {
			if (null !== workInProgress) {
				if (0 === workInProgressSuspendedReason) var interruptedWork = workInProgress.return;
				else interruptedWork = workInProgress, lastContextDependency = currentlyRenderingFiber$1 = null, resetHooksOnUnwind(interruptedWork), thenableState = null, thenableIndexCounter = 0, interruptedWork = workInProgress;
				for (; null !== interruptedWork;) unwindInterruptedWork(interruptedWork.alternate, interruptedWork), interruptedWork = interruptedWork.return;
				workInProgress = null;
			}
		}
		function prepareFreshStack(root, lanes) {
			var timeoutHandle = root.timeoutHandle;
			timeoutHandle !== noTimeout && (root.timeoutHandle = noTimeout, cancelTimeout(timeoutHandle));
			timeoutHandle = root.cancelPendingCommit;
			null !== timeoutHandle && (root.cancelPendingCommit = null, timeoutHandle());
			resetWorkInProgressStack();
			workInProgressRoot = root;
			workInProgress = timeoutHandle = createWorkInProgress(root.current, null);
			workInProgressRootRenderLanes = lanes;
			workInProgressSuspendedReason = 0;
			workInProgressThrownValue = null;
			workInProgressRootDidSkipSuspendedSiblings = !1;
			workInProgressRootIsPrerendering = checkIfRootIsPrerendering(root, lanes);
			workInProgressRootDidAttachPingListener = !1;
			workInProgressSuspendedRetryLanes = workInProgressDeferredLane = workInProgressRootPingedLanes = workInProgressRootInterleavedUpdatedLanes = workInProgressRootSkippedLanes = workInProgressRootExitStatus = 0;
			workInProgressRootRecoverableErrors = workInProgressRootConcurrentErrors = null;
			workInProgressRootDidIncludeRecursiveRenderUpdate = !1;
			0 !== (lanes & 8) && (lanes |= lanes & 32);
			var allEntangledLanes = root.entangledLanes;
			if (0 !== allEntangledLanes) for (root = root.entanglements, allEntangledLanes &= lanes; 0 < allEntangledLanes;) {
				var index$2 = 31 - clz32(allEntangledLanes), lane = 1 << index$2;
				lanes |= root[index$2];
				allEntangledLanes &= ~lane;
			}
			entangledRenderLanes = lanes;
			finishQueueingConcurrentUpdates();
			return timeoutHandle;
		}
		function handleThrow(root, thrownValue) {
			currentlyRenderingFiber = null;
			ReactSharedInternals$1.H = ContextOnlyDispatcher;
			thrownValue === SuspenseException || thrownValue === SuspenseActionException ? (thrownValue = getSuspendedThenable(), workInProgressSuspendedReason = 3) : thrownValue === SuspenseyCommitException ? (thrownValue = getSuspendedThenable(), workInProgressSuspendedReason = 4) : workInProgressSuspendedReason = thrownValue === SelectiveHydrationException ? 8 : null !== thrownValue && "object" === typeof thrownValue && "function" === typeof thrownValue.then ? 6 : 1;
			workInProgressThrownValue = thrownValue;
			null === workInProgress && (workInProgressRootExitStatus = 1, logUncaughtError(root, createCapturedValueAtFiber(thrownValue, root.current)));
		}
		function shouldRemainOnPreviousScreen() {
			var handler = suspenseHandlerStackCursor.current;
			return null === handler ? !0 : (workInProgressRootRenderLanes & 4194048) === workInProgressRootRenderLanes ? null === shellBoundary ? !0 : !1 : (workInProgressRootRenderLanes & 62914560) === workInProgressRootRenderLanes || 0 !== (workInProgressRootRenderLanes & 536870912) ? handler === shellBoundary : !1;
		}
		function pushDispatcher() {
			var prevDispatcher = ReactSharedInternals$1.H;
			ReactSharedInternals$1.H = ContextOnlyDispatcher;
			return null === prevDispatcher ? ContextOnlyDispatcher : prevDispatcher;
		}
		function pushAsyncDispatcher() {
			var prevAsyncDispatcher = ReactSharedInternals$1.A;
			ReactSharedInternals$1.A = DefaultAsyncDispatcher;
			return prevAsyncDispatcher;
		}
		function renderDidSuspendDelayIfPossible() {
			workInProgressRootExitStatus = 4;
			workInProgressRootDidSkipSuspendedSiblings || (workInProgressRootRenderLanes & 4194048) !== workInProgressRootRenderLanes && null !== suspenseHandlerStackCursor.current || (workInProgressRootIsPrerendering = !0);
			0 === (workInProgressRootSkippedLanes & 134217727) && 0 === (workInProgressRootInterleavedUpdatedLanes & 134217727) || null === workInProgressRoot || markRootSuspended(workInProgressRoot, workInProgressRootRenderLanes, workInProgressDeferredLane, !1);
		}
		function renderRootSync(root, lanes, shouldYieldForPrerendering) {
			var prevExecutionContext = executionContext;
			executionContext |= 2;
			var prevDispatcher = pushDispatcher(), prevAsyncDispatcher = pushAsyncDispatcher();
			if (workInProgressRoot !== root || workInProgressRootRenderLanes !== lanes) workInProgressTransitions = null, prepareFreshStack(root, lanes);
			lanes = !1;
			var exitStatus = workInProgressRootExitStatus;
			a: do
				try {
					if (0 !== workInProgressSuspendedReason && null !== workInProgress) {
						var unitOfWork = workInProgress, thrownValue = workInProgressThrownValue;
						switch (workInProgressSuspendedReason) {
							case 8:
								resetWorkInProgressStack();
								exitStatus = 6;
								break a;
							case 3:
							case 2:
							case 9:
							case 6:
								null === suspenseHandlerStackCursor.current && (lanes = !0);
								var reason = workInProgressSuspendedReason;
								workInProgressSuspendedReason = 0;
								workInProgressThrownValue = null;
								throwAndUnwindWorkLoop(root, unitOfWork, thrownValue, reason);
								if (shouldYieldForPrerendering && workInProgressRootIsPrerendering) {
									exitStatus = 0;
									break a;
								}
								break;
							default: reason = workInProgressSuspendedReason, workInProgressSuspendedReason = 0, workInProgressThrownValue = null, throwAndUnwindWorkLoop(root, unitOfWork, thrownValue, reason);
						}
					}
					workLoopSync();
					exitStatus = workInProgressRootExitStatus;
					break;
				} catch (thrownValue$155) {
					handleThrow(root, thrownValue$155);
				}
			while (1);
			lanes && root.shellSuspendCounter++;
			lastContextDependency = currentlyRenderingFiber$1 = null;
			executionContext = prevExecutionContext;
			ReactSharedInternals$1.H = prevDispatcher;
			ReactSharedInternals$1.A = prevAsyncDispatcher;
			null === workInProgress && (workInProgressRoot = null, workInProgressRootRenderLanes = 0, finishQueueingConcurrentUpdates());
			return exitStatus;
		}
		function workLoopSync() {
			for (; null !== workInProgress;) performUnitOfWork(workInProgress);
		}
		function renderRootConcurrent(root, lanes) {
			var prevExecutionContext = executionContext;
			executionContext |= 2;
			var prevDispatcher = pushDispatcher(), prevAsyncDispatcher = pushAsyncDispatcher();
			workInProgressRoot !== root || workInProgressRootRenderLanes !== lanes ? (workInProgressTransitions = null, workInProgressRootRenderTargetTime = now() + 500, prepareFreshStack(root, lanes)) : workInProgressRootIsPrerendering = checkIfRootIsPrerendering(root, lanes);
			a: do
				try {
					if (0 !== workInProgressSuspendedReason && null !== workInProgress) {
						lanes = workInProgress;
						var thrownValue = workInProgressThrownValue;
						b: switch (workInProgressSuspendedReason) {
							case 1:
								workInProgressSuspendedReason = 0;
								workInProgressThrownValue = null;
								throwAndUnwindWorkLoop(root, lanes, thrownValue, 1);
								break;
							case 2:
							case 9:
								if (isThenableResolved(thrownValue)) {
									workInProgressSuspendedReason = 0;
									workInProgressThrownValue = null;
									replaySuspendedUnitOfWork(lanes);
									break;
								}
								lanes = function() {
									2 !== workInProgressSuspendedReason && 9 !== workInProgressSuspendedReason || workInProgressRoot !== root || (workInProgressSuspendedReason = 7);
									ensureRootIsScheduled(root);
								};
								thrownValue.then(lanes, lanes);
								break a;
							case 3:
								workInProgressSuspendedReason = 7;
								break a;
							case 4:
								workInProgressSuspendedReason = 5;
								break a;
							case 7:
								isThenableResolved(thrownValue) ? (workInProgressSuspendedReason = 0, workInProgressThrownValue = null, replaySuspendedUnitOfWork(lanes)) : (workInProgressSuspendedReason = 0, workInProgressThrownValue = null, throwAndUnwindWorkLoop(root, lanes, thrownValue, 7));
								break;
							case 5:
								var resource = null;
								switch (workInProgress.tag) {
									case 26: resource = workInProgress.memoizedState;
									case 5:
									case 27:
										var hostFiber = workInProgress, type = hostFiber.type, props = hostFiber.pendingProps;
										if (resource ? preloadResource(resource) : preloadInstance(type, props)) {
											workInProgressSuspendedReason = 0;
											workInProgressThrownValue = null;
											var sibling = hostFiber.sibling;
											if (null !== sibling) workInProgress = sibling;
											else {
												var returnFiber = hostFiber.return;
												null !== returnFiber ? (workInProgress = returnFiber, completeUnitOfWork(returnFiber)) : workInProgress = null;
											}
											break b;
										}
								}
								workInProgressSuspendedReason = 0;
								workInProgressThrownValue = null;
								throwAndUnwindWorkLoop(root, lanes, thrownValue, 5);
								break;
							case 6:
								workInProgressSuspendedReason = 0;
								workInProgressThrownValue = null;
								throwAndUnwindWorkLoop(root, lanes, thrownValue, 6);
								break;
							case 8:
								resetWorkInProgressStack();
								workInProgressRootExitStatus = 6;
								break a;
							default: throw Error(formatProdErrorMessage(462));
						}
					}
					workLoopConcurrentByScheduler();
					break;
				} catch (thrownValue$157) {
					handleThrow(root, thrownValue$157);
				}
			while (1);
			lastContextDependency = currentlyRenderingFiber$1 = null;
			ReactSharedInternals$1.H = prevDispatcher;
			ReactSharedInternals$1.A = prevAsyncDispatcher;
			executionContext = prevExecutionContext;
			if (null !== workInProgress) return 0;
			workInProgressRoot = null;
			workInProgressRootRenderLanes = 0;
			finishQueueingConcurrentUpdates();
			return workInProgressRootExitStatus;
		}
		function workLoopConcurrentByScheduler() {
			for (; null !== workInProgress && !shouldYield();) performUnitOfWork(workInProgress);
		}
		function performUnitOfWork(unitOfWork) {
			var next = beginWork(unitOfWork.alternate, unitOfWork, entangledRenderLanes);
			unitOfWork.memoizedProps = unitOfWork.pendingProps;
			null === next ? completeUnitOfWork(unitOfWork) : workInProgress = next;
		}
		function replaySuspendedUnitOfWork(unitOfWork) {
			var next = unitOfWork;
			var current = next.alternate;
			switch (next.tag) {
				case 15:
				case 0:
					next = replayFunctionComponent(current, next, next.pendingProps, next.type, void 0, workInProgressRootRenderLanes);
					break;
				case 11:
					next = replayFunctionComponent(current, next, next.pendingProps, next.type.render, next.ref, workInProgressRootRenderLanes);
					break;
				case 5: resetHooksOnUnwind(next);
				default: unwindInterruptedWork(current, next), next = workInProgress = resetWorkInProgress(next, entangledRenderLanes), next = beginWork(current, next, entangledRenderLanes);
			}
			unitOfWork.memoizedProps = unitOfWork.pendingProps;
			null === next ? completeUnitOfWork(unitOfWork) : workInProgress = next;
		}
		function throwAndUnwindWorkLoop(root, unitOfWork, thrownValue, suspendedReason) {
			lastContextDependency = currentlyRenderingFiber$1 = null;
			resetHooksOnUnwind(unitOfWork);
			thenableState = null;
			thenableIndexCounter = 0;
			var returnFiber = unitOfWork.return;
			try {
				if (throwException(root, returnFiber, unitOfWork, thrownValue, workInProgressRootRenderLanes)) {
					workInProgressRootExitStatus = 1;
					logUncaughtError(root, createCapturedValueAtFiber(thrownValue, root.current));
					workInProgress = null;
					return;
				}
			} catch (error) {
				if (null !== returnFiber) throw workInProgress = returnFiber, error;
				workInProgressRootExitStatus = 1;
				logUncaughtError(root, createCapturedValueAtFiber(thrownValue, root.current));
				workInProgress = null;
				return;
			}
			if (unitOfWork.flags & 32768) {
				if (isHydrating || 1 === suspendedReason) root = !0;
				else if (workInProgressRootIsPrerendering || 0 !== (workInProgressRootRenderLanes & 536870912)) root = !1;
				else if (workInProgressRootDidSkipSuspendedSiblings = root = !0, 2 === suspendedReason || 9 === suspendedReason || 3 === suspendedReason || 6 === suspendedReason) suspendedReason = suspenseHandlerStackCursor.current, null !== suspendedReason && 13 === suspendedReason.tag && (suspendedReason.flags |= 16384);
				unwindUnitOfWork(unitOfWork, root);
			} else completeUnitOfWork(unitOfWork);
		}
		function completeUnitOfWork(unitOfWork) {
			var completedWork = unitOfWork;
			do {
				if (0 !== (completedWork.flags & 32768)) {
					unwindUnitOfWork(completedWork, workInProgressRootDidSkipSuspendedSiblings);
					return;
				}
				unitOfWork = completedWork.return;
				var next = completeWork(completedWork.alternate, completedWork, entangledRenderLanes);
				if (null !== next) {
					workInProgress = next;
					return;
				}
				completedWork = completedWork.sibling;
				if (null !== completedWork) {
					workInProgress = completedWork;
					return;
				}
				workInProgress = completedWork = unitOfWork;
			} while (null !== completedWork);
			0 === workInProgressRootExitStatus && (workInProgressRootExitStatus = 5);
		}
		function unwindUnitOfWork(unitOfWork, skipSiblings) {
			do {
				var next = unwindWork(unitOfWork.alternate, unitOfWork);
				if (null !== next) {
					next.flags &= 32767;
					workInProgress = next;
					return;
				}
				next = unitOfWork.return;
				null !== next && (next.flags |= 32768, next.subtreeFlags = 0, next.deletions = null);
				if (!skipSiblings && (unitOfWork = unitOfWork.sibling, null !== unitOfWork)) {
					workInProgress = unitOfWork;
					return;
				}
				workInProgress = unitOfWork = next;
			} while (null !== unitOfWork);
			workInProgressRootExitStatus = 6;
			workInProgress = null;
		}
		function commitRoot(root, finishedWork, lanes, recoverableErrors, transitions, didIncludeRenderPhaseUpdate, spawnedLane, updatedLanes, suspendedRetryLanes) {
			root.cancelPendingCommit = null;
			do
				flushPendingEffects();
			while (0 !== pendingEffectsStatus);
			if (0 !== (executionContext & 6)) throw Error(formatProdErrorMessage(327));
			if (null !== finishedWork) {
				if (finishedWork === root.current) throw Error(formatProdErrorMessage(177));
				didIncludeRenderPhaseUpdate = finishedWork.lanes | finishedWork.childLanes;
				didIncludeRenderPhaseUpdate |= concurrentlyUpdatedLanes;
				markRootFinished(root, lanes, didIncludeRenderPhaseUpdate, spawnedLane, updatedLanes, suspendedRetryLanes);
				root === workInProgressRoot && (workInProgress = workInProgressRoot = null, workInProgressRootRenderLanes = 0);
				pendingFinishedWork = finishedWork;
				pendingEffectsRoot = root;
				pendingEffectsLanes = lanes;
				pendingEffectsRemainingLanes = didIncludeRenderPhaseUpdate;
				pendingPassiveTransitions = transitions;
				pendingRecoverableErrors = recoverableErrors;
				0 !== (finishedWork.subtreeFlags & 10256) || 0 !== (finishedWork.flags & 10256) ? (root.callbackNode = null, root.callbackPriority = 0, scheduleCallback(NormalPriority$1, function() {
					flushPassiveEffects(!0);
					return null;
				})) : (root.callbackNode = null, root.callbackPriority = 0);
				recoverableErrors = 0 !== (finishedWork.flags & 13878);
				if (0 !== (finishedWork.subtreeFlags & 13878) || recoverableErrors) {
					recoverableErrors = ReactSharedInternals$1.T;
					ReactSharedInternals$1.T = null;
					transitions = getCurrentUpdatePriority();
					setCurrentUpdatePriority(2);
					spawnedLane = executionContext;
					executionContext |= 4;
					try {
						commitBeforeMutationEffects(root, finishedWork, lanes);
					} finally {
						executionContext = spawnedLane, setCurrentUpdatePriority(transitions), ReactSharedInternals$1.T = recoverableErrors;
					}
				}
				pendingEffectsStatus = 1;
				flushMutationEffects();
				flushLayoutEffects();
				flushSpawnedWork();
			}
		}
		function flushMutationEffects() {
			if (1 === pendingEffectsStatus) {
				pendingEffectsStatus = 0;
				var root = pendingEffectsRoot, finishedWork = pendingFinishedWork, rootMutationHasEffect = 0 !== (finishedWork.flags & 13878);
				if (0 !== (finishedWork.subtreeFlags & 13878) || rootMutationHasEffect) {
					rootMutationHasEffect = ReactSharedInternals$1.T;
					ReactSharedInternals$1.T = null;
					var previousPriority = getCurrentUpdatePriority();
					setCurrentUpdatePriority(2);
					var prevExecutionContext = executionContext;
					executionContext |= 4;
					try {
						commitMutationEffectsOnFiber(finishedWork, root), resetAfterCommit(root.containerInfo);
					} finally {
						executionContext = prevExecutionContext, setCurrentUpdatePriority(previousPriority), ReactSharedInternals$1.T = rootMutationHasEffect;
					}
				}
				root.current = finishedWork;
				pendingEffectsStatus = 2;
			}
		}
		function flushLayoutEffects() {
			if (2 === pendingEffectsStatus) {
				pendingEffectsStatus = 0;
				var root = pendingEffectsRoot, finishedWork = pendingFinishedWork, rootHasLayoutEffect = 0 !== (finishedWork.flags & 8772);
				if (0 !== (finishedWork.subtreeFlags & 8772) || rootHasLayoutEffect) {
					rootHasLayoutEffect = ReactSharedInternals$1.T;
					ReactSharedInternals$1.T = null;
					var previousPriority = getCurrentUpdatePriority();
					setCurrentUpdatePriority(2);
					var prevExecutionContext = executionContext;
					executionContext |= 4;
					try {
						commitLayoutEffectOnFiber(root, finishedWork.alternate, finishedWork);
					} finally {
						executionContext = prevExecutionContext, setCurrentUpdatePriority(previousPriority), ReactSharedInternals$1.T = rootHasLayoutEffect;
					}
				}
				pendingEffectsStatus = 3;
			}
		}
		function flushSpawnedWork() {
			if (4 === pendingEffectsStatus || 3 === pendingEffectsStatus) {
				pendingEffectsStatus = 0;
				requestPaint();
				var root = pendingEffectsRoot, finishedWork = pendingFinishedWork, lanes = pendingEffectsLanes, recoverableErrors = pendingRecoverableErrors;
				0 !== (finishedWork.subtreeFlags & 10256) || 0 !== (finishedWork.flags & 10256) ? pendingEffectsStatus = 5 : (pendingEffectsStatus = 0, pendingFinishedWork = pendingEffectsRoot = null, releaseRootPooledCache(root, root.pendingLanes));
				var remainingLanes = root.pendingLanes;
				0 === remainingLanes && (legacyErrorBoundariesThatAlreadyFailed = null);
				lanesToEventPriority(lanes);
				finishedWork = finishedWork.stateNode;
				if (injectedHook && "function" === typeof injectedHook.onCommitFiberRoot) try {
					injectedHook.onCommitFiberRoot(rendererID, finishedWork, void 0, 128 === (finishedWork.current.flags & 128));
				} catch (err) {}
				if (null !== recoverableErrors) {
					finishedWork = ReactSharedInternals$1.T;
					remainingLanes = getCurrentUpdatePriority();
					setCurrentUpdatePriority(2);
					ReactSharedInternals$1.T = null;
					try {
						for (var onRecoverableError = root.onRecoverableError, i = 0; i < recoverableErrors.length; i++) {
							var recoverableError = recoverableErrors[i];
							onRecoverableError(recoverableError.value, { componentStack: recoverableError.stack });
						}
					} finally {
						ReactSharedInternals$1.T = finishedWork, setCurrentUpdatePriority(remainingLanes);
					}
				}
				0 !== (pendingEffectsLanes & 3) && flushPendingEffects();
				ensureRootIsScheduled(root);
				remainingLanes = root.pendingLanes;
				0 !== (lanes & 4194090) && 0 !== (remainingLanes & 42) ? root === rootWithNestedUpdates ? nestedUpdateCount++ : (nestedUpdateCount = 0, rootWithNestedUpdates = root) : nestedUpdateCount = 0;
				flushSyncWorkAcrossRoots_impl(0, !1);
			}
		}
		function releaseRootPooledCache(root, remainingLanes) {
			0 === (root.pooledCacheLanes &= remainingLanes) && (remainingLanes = root.pooledCache, null != remainingLanes && (root.pooledCache = null, releaseCache(remainingLanes)));
		}
		function flushPendingEffects(wasDelayedCommit) {
			flushMutationEffects();
			flushLayoutEffects();
			flushSpawnedWork();
			return flushPassiveEffects(wasDelayedCommit);
		}
		function flushPassiveEffects() {
			if (5 !== pendingEffectsStatus) return !1;
			var root = pendingEffectsRoot, remainingLanes = pendingEffectsRemainingLanes;
			pendingEffectsRemainingLanes = 0;
			var renderPriority = lanesToEventPriority(pendingEffectsLanes), priority = 32 > renderPriority ? 32 : renderPriority;
			renderPriority = ReactSharedInternals$1.T;
			var previousPriority = getCurrentUpdatePriority();
			try {
				setCurrentUpdatePriority(priority);
				ReactSharedInternals$1.T = null;
				priority = pendingPassiveTransitions;
				pendingPassiveTransitions = null;
				var root$jscomp$0 = pendingEffectsRoot, lanes = pendingEffectsLanes;
				pendingEffectsStatus = 0;
				pendingFinishedWork = pendingEffectsRoot = null;
				pendingEffectsLanes = 0;
				if (0 !== (executionContext & 6)) throw Error(formatProdErrorMessage(331));
				var prevExecutionContext = executionContext;
				executionContext |= 4;
				commitPassiveUnmountOnFiber(root$jscomp$0.current);
				commitPassiveMountOnFiber(root$jscomp$0, root$jscomp$0.current, lanes, priority);
				executionContext = prevExecutionContext;
				flushSyncWorkAcrossRoots_impl(0, !1);
				if (injectedHook && "function" === typeof injectedHook.onPostCommitFiberRoot) try {
					injectedHook.onPostCommitFiberRoot(rendererID, root$jscomp$0);
				} catch (err) {}
				return !0;
			} finally {
				setCurrentUpdatePriority(previousPriority), ReactSharedInternals$1.T = renderPriority, releaseRootPooledCache(root, remainingLanes);
			}
		}
		function captureCommitPhaseErrorOnRoot(rootFiber, sourceFiber, error) {
			sourceFiber = createCapturedValueAtFiber(error, sourceFiber);
			sourceFiber = createRootErrorUpdate(rootFiber.stateNode, sourceFiber, 2);
			rootFiber = enqueueUpdate(rootFiber, sourceFiber, 2);
			null !== rootFiber && (markRootUpdated$1(rootFiber, 2), ensureRootIsScheduled(rootFiber));
		}
		function captureCommitPhaseError(sourceFiber, nearestMountedAncestor, error) {
			if (3 === sourceFiber.tag) captureCommitPhaseErrorOnRoot(sourceFiber, sourceFiber, error);
			else for (; null !== nearestMountedAncestor;) {
				if (3 === nearestMountedAncestor.tag) {
					captureCommitPhaseErrorOnRoot(nearestMountedAncestor, sourceFiber, error);
					break;
				} else if (1 === nearestMountedAncestor.tag) {
					var instance = nearestMountedAncestor.stateNode;
					if ("function" === typeof nearestMountedAncestor.type.getDerivedStateFromError || "function" === typeof instance.componentDidCatch && (null === legacyErrorBoundariesThatAlreadyFailed || !legacyErrorBoundariesThatAlreadyFailed.has(instance))) {
						sourceFiber = createCapturedValueAtFiber(error, sourceFiber);
						error = createClassErrorUpdate(2);
						instance = enqueueUpdate(nearestMountedAncestor, error, 2);
						null !== instance && (initializeClassErrorUpdate(error, instance, nearestMountedAncestor, sourceFiber), markRootUpdated$1(instance, 2), ensureRootIsScheduled(instance));
						break;
					}
				}
				nearestMountedAncestor = nearestMountedAncestor.return;
			}
		}
		function attachPingListener(root, wakeable, lanes) {
			var pingCache = root.pingCache;
			if (null === pingCache) {
				pingCache = root.pingCache = new PossiblyWeakMap();
				var threadIDs = /* @__PURE__ */ new Set();
				pingCache.set(wakeable, threadIDs);
			} else threadIDs = pingCache.get(wakeable), void 0 === threadIDs && (threadIDs = /* @__PURE__ */ new Set(), pingCache.set(wakeable, threadIDs));
			threadIDs.has(lanes) || (workInProgressRootDidAttachPingListener = !0, threadIDs.add(lanes), root = pingSuspendedRoot.bind(null, root, wakeable, lanes), wakeable.then(root, root));
		}
		function pingSuspendedRoot(root, wakeable, pingedLanes) {
			var pingCache = root.pingCache;
			null !== pingCache && pingCache.delete(wakeable);
			root.pingedLanes |= root.suspendedLanes & pingedLanes;
			root.warmLanes &= ~pingedLanes;
			workInProgressRoot === root && (workInProgressRootRenderLanes & pingedLanes) === pingedLanes && (4 === workInProgressRootExitStatus || 3 === workInProgressRootExitStatus && (workInProgressRootRenderLanes & 62914560) === workInProgressRootRenderLanes && 300 > now() - globalMostRecentFallbackTime ? 0 === (executionContext & 2) && prepareFreshStack(root, 0) : workInProgressRootPingedLanes |= pingedLanes, workInProgressSuspendedRetryLanes === workInProgressRootRenderLanes && (workInProgressSuspendedRetryLanes = 0));
			ensureRootIsScheduled(root);
		}
		function retryTimedOutBoundary(boundaryFiber, retryLane) {
			0 === retryLane && (retryLane = claimNextRetryLane());
			boundaryFiber = enqueueConcurrentRenderForLane(boundaryFiber, retryLane);
			null !== boundaryFiber && (markRootUpdated$1(boundaryFiber, retryLane), ensureRootIsScheduled(boundaryFiber));
		}
		function retryDehydratedSuspenseBoundary(boundaryFiber) {
			var suspenseState = boundaryFiber.memoizedState, retryLane = 0;
			null !== suspenseState && (retryLane = suspenseState.retryLane);
			retryTimedOutBoundary(boundaryFiber, retryLane);
		}
		function resolveRetryWakeable(boundaryFiber, wakeable) {
			var retryLane = 0;
			switch (boundaryFiber.tag) {
				case 13:
					var retryCache = boundaryFiber.stateNode;
					var suspenseState = boundaryFiber.memoizedState;
					null !== suspenseState && (retryLane = suspenseState.retryLane);
					break;
				case 19:
					retryCache = boundaryFiber.stateNode;
					break;
				case 22:
					retryCache = boundaryFiber.stateNode._retryCache;
					break;
				default: throw Error(formatProdErrorMessage(314));
			}
			null !== retryCache && retryCache.delete(wakeable);
			retryTimedOutBoundary(boundaryFiber, retryLane);
		}
		function scheduleCallback(priorityLevel, callback) {
			return scheduleCallback$3(priorityLevel, callback);
		}
		function FiberNode(tag, pendingProps, key, mode) {
			this.tag = tag;
			this.key = key;
			this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null;
			this.index = 0;
			this.refCleanup = this.ref = null;
			this.pendingProps = pendingProps;
			this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null;
			this.mode = mode;
			this.subtreeFlags = this.flags = 0;
			this.deletions = null;
			this.childLanes = this.lanes = 0;
			this.alternate = null;
		}
		function shouldConstruct(Component$1) {
			Component$1 = Component$1.prototype;
			return !(!Component$1 || !Component$1.isReactComponent);
		}
		function createWorkInProgress(current, pendingProps) {
			var workInProgress$1 = current.alternate;
			null === workInProgress$1 ? (workInProgress$1 = createFiber(current.tag, pendingProps, current.key, current.mode), workInProgress$1.elementType = current.elementType, workInProgress$1.type = current.type, workInProgress$1.stateNode = current.stateNode, workInProgress$1.alternate = current, current.alternate = workInProgress$1) : (workInProgress$1.pendingProps = pendingProps, workInProgress$1.type = current.type, workInProgress$1.flags = 0, workInProgress$1.subtreeFlags = 0, workInProgress$1.deletions = null);
			workInProgress$1.flags = current.flags & 65011712;
			workInProgress$1.childLanes = current.childLanes;
			workInProgress$1.lanes = current.lanes;
			workInProgress$1.child = current.child;
			workInProgress$1.memoizedProps = current.memoizedProps;
			workInProgress$1.memoizedState = current.memoizedState;
			workInProgress$1.updateQueue = current.updateQueue;
			pendingProps = current.dependencies;
			workInProgress$1.dependencies = null === pendingProps ? null : {
				lanes: pendingProps.lanes,
				firstContext: pendingProps.firstContext
			};
			workInProgress$1.sibling = current.sibling;
			workInProgress$1.index = current.index;
			workInProgress$1.ref = current.ref;
			workInProgress$1.refCleanup = current.refCleanup;
			return workInProgress$1;
		}
		function resetWorkInProgress(workInProgress$1, renderLanes$1) {
			workInProgress$1.flags &= 65011714;
			var current = workInProgress$1.alternate;
			null === current ? (workInProgress$1.childLanes = 0, workInProgress$1.lanes = renderLanes$1, workInProgress$1.child = null, workInProgress$1.subtreeFlags = 0, workInProgress$1.memoizedProps = null, workInProgress$1.memoizedState = null, workInProgress$1.updateQueue = null, workInProgress$1.dependencies = null, workInProgress$1.stateNode = null) : (workInProgress$1.childLanes = current.childLanes, workInProgress$1.lanes = current.lanes, workInProgress$1.child = current.child, workInProgress$1.subtreeFlags = 0, workInProgress$1.deletions = null, workInProgress$1.memoizedProps = current.memoizedProps, workInProgress$1.memoizedState = current.memoizedState, workInProgress$1.updateQueue = current.updateQueue, workInProgress$1.type = current.type, renderLanes$1 = current.dependencies, workInProgress$1.dependencies = null === renderLanes$1 ? null : {
				lanes: renderLanes$1.lanes,
				firstContext: renderLanes$1.firstContext
			});
			return workInProgress$1;
		}
		function createFiberFromTypeAndProps(type, key, pendingProps, owner, mode, lanes) {
			var fiberTag = 0;
			owner = type;
			if ("function" === typeof type) shouldConstruct(type) && (fiberTag = 1);
			else if ("string" === typeof type) fiberTag = supportsResources && supportsSingletons ? isHostHoistableType(type, pendingProps, contextStackCursor.current) ? 26 : isHostSingletonType(type) ? 27 : 5 : supportsResources ? isHostHoistableType(type, pendingProps, contextStackCursor.current) ? 26 : 5 : supportsSingletons ? isHostSingletonType(type) ? 27 : 5 : 5;
			else a: switch (type) {
				case REACT_ACTIVITY_TYPE$1: return type = createFiber(31, pendingProps, key, mode), type.elementType = REACT_ACTIVITY_TYPE$1, type.lanes = lanes, type;
				case REACT_FRAGMENT_TYPE$2: return createFiberFromFragment(pendingProps.children, mode, lanes, key);
				case REACT_STRICT_MODE_TYPE$1:
					fiberTag = 8;
					mode |= 24;
					break;
				case REACT_PROFILER_TYPE$1: return type = createFiber(12, pendingProps, key, mode | 2), type.elementType = REACT_PROFILER_TYPE$1, type.lanes = lanes, type;
				case REACT_SUSPENSE_TYPE$1: return type = createFiber(13, pendingProps, key, mode), type.elementType = REACT_SUSPENSE_TYPE$1, type.lanes = lanes, type;
				case REACT_SUSPENSE_LIST_TYPE: return type = createFiber(19, pendingProps, key, mode), type.elementType = REACT_SUSPENSE_LIST_TYPE, type.lanes = lanes, type;
				default:
					if ("object" === typeof type && null !== type) switch (type.$$typeof) {
						case REACT_PROVIDER_TYPE:
						case REACT_CONTEXT_TYPE$1:
							fiberTag = 10;
							break a;
						case REACT_CONSUMER_TYPE$1:
							fiberTag = 9;
							break a;
						case REACT_FORWARD_REF_TYPE$1:
							fiberTag = 11;
							break a;
						case REACT_MEMO_TYPE$1:
							fiberTag = 14;
							break a;
						case REACT_LAZY_TYPE$1:
							fiberTag = 16;
							owner = null;
							break a;
					}
					fiberTag = 29;
					pendingProps = Error(formatProdErrorMessage(130, null === type ? "null" : typeof type, ""));
					owner = null;
			}
			key = createFiber(fiberTag, pendingProps, key, mode);
			key.elementType = type;
			key.type = owner;
			key.lanes = lanes;
			return key;
		}
		function createFiberFromFragment(elements, mode, lanes, key) {
			elements = createFiber(7, elements, key, mode);
			elements.lanes = lanes;
			return elements;
		}
		function createFiberFromText(content, mode, lanes) {
			content = createFiber(6, content, null, mode);
			content.lanes = lanes;
			return content;
		}
		function createFiberFromPortal(portal, mode, lanes) {
			mode = createFiber(4, null !== portal.children ? portal.children : [], portal.key, mode);
			mode.lanes = lanes;
			mode.stateNode = {
				containerInfo: portal.containerInfo,
				pendingChildren: null,
				implementation: portal.implementation
			};
			return mode;
		}
		function FiberRootNode(containerInfo, tag, hydrate, identifierPrefix, onUncaughtError, onCaughtError, onRecoverableError, formState) {
			this.tag = 1;
			this.containerInfo = containerInfo;
			this.pingCache = this.current = this.pendingChildren = null;
			this.timeoutHandle = noTimeout;
			this.callbackNode = this.next = this.pendingContext = this.context = this.cancelPendingCommit = null;
			this.callbackPriority = 0;
			this.expirationTimes = createLaneMap(-1);
			this.entangledLanes = this.shellSuspendCounter = this.errorRecoveryDisabledLanes = this.expiredLanes = this.warmLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0;
			this.entanglements = createLaneMap(0);
			this.hiddenUpdates = createLaneMap(null);
			this.identifierPrefix = identifierPrefix;
			this.onUncaughtError = onUncaughtError;
			this.onCaughtError = onCaughtError;
			this.onRecoverableError = onRecoverableError;
			this.pooledCache = null;
			this.pooledCacheLanes = 0;
			this.formState = formState;
			this.incompleteTransitions = /* @__PURE__ */ new Map();
		}
		function createFiberRoot(containerInfo, tag, hydrate, initialChildren, hydrationCallbacks, isStrictMode, identifierPrefix, onUncaughtError, onCaughtError, onRecoverableError, transitionCallbacks, formState) {
			containerInfo = new FiberRootNode(containerInfo, tag, hydrate, identifierPrefix, onUncaughtError, onCaughtError, onRecoverableError, formState);
			tag = 1;
			!0 === isStrictMode && (tag |= 24);
			isStrictMode = createFiber(3, null, null, tag);
			containerInfo.current = isStrictMode;
			isStrictMode.stateNode = containerInfo;
			tag = createCache();
			tag.refCount++;
			containerInfo.pooledCache = tag;
			tag.refCount++;
			isStrictMode.memoizedState = {
				element: initialChildren,
				isDehydrated: hydrate,
				cache: tag
			};
			initializeUpdateQueue(isStrictMode);
			return containerInfo;
		}
		function getContextForSubtree(parentComponent) {
			if (!parentComponent) return emptyContextObject;
			parentComponent = emptyContextObject;
			return parentComponent;
		}
		function findHostInstance(component) {
			var fiber = component._reactInternals;
			if (void 0 === fiber) {
				if ("function" === typeof component.render) throw Error(formatProdErrorMessage(188));
				component = Object.keys(component).join(",");
				throw Error(formatProdErrorMessage(268, component));
			}
			component = findCurrentFiberUsingSlowPath(fiber);
			component = null !== component ? findCurrentHostFiberImpl(component) : null;
			return null === component ? null : getPublicInstance(component.stateNode);
		}
		function updateContainerImpl(rootFiber, lane, element, container, parentComponent, callback) {
			parentComponent = getContextForSubtree(parentComponent);
			null === container.context ? container.context = parentComponent : container.pendingContext = parentComponent;
			container = createUpdate(lane);
			container.payload = { element };
			callback = void 0 === callback ? null : callback;
			null !== callback && (container.callback = callback);
			element = enqueueUpdate(rootFiber, container, lane);
			null !== element && (scheduleUpdateOnFiber(element, rootFiber, lane), entangleTransitions(element, rootFiber, lane));
		}
		function markRetryLaneImpl(fiber, retryLane) {
			fiber = fiber.memoizedState;
			if (null !== fiber && null !== fiber.dehydrated) {
				var a = fiber.retryLane;
				fiber.retryLane = 0 !== a && a < retryLane ? a : retryLane;
			}
		}
		function markRetryLaneIfNotHydrated(fiber, retryLane) {
			markRetryLaneImpl(fiber, retryLane);
			(fiber = fiber.alternate) && markRetryLaneImpl(fiber, retryLane);
		}
		var exports$1 = {};
		var React$10 = require_react(), Scheduler = require_scheduler(), assign$1 = Object.assign, REACT_LEGACY_ELEMENT_TYPE = Symbol.for("react.element"), REACT_ELEMENT_TYPE$2 = Symbol.for("react.transitional.element"), REACT_PORTAL_TYPE$1 = Symbol.for("react.portal"), REACT_FRAGMENT_TYPE$2 = Symbol.for("react.fragment"), REACT_STRICT_MODE_TYPE$1 = Symbol.for("react.strict_mode"), REACT_PROFILER_TYPE$1 = Symbol.for("react.profiler"), REACT_PROVIDER_TYPE = Symbol.for("react.provider"), REACT_CONSUMER_TYPE$1 = Symbol.for("react.consumer"), REACT_CONTEXT_TYPE$1 = Symbol.for("react.context"), REACT_FORWARD_REF_TYPE$1 = Symbol.for("react.forward_ref"), REACT_SUSPENSE_TYPE$1 = Symbol.for("react.suspense"), REACT_SUSPENSE_LIST_TYPE = Symbol.for("react.suspense_list"), REACT_MEMO_TYPE$1 = Symbol.for("react.memo"), REACT_LAZY_TYPE$1 = Symbol.for("react.lazy");
		var REACT_ACTIVITY_TYPE$1 = Symbol.for("react.activity");
		var REACT_MEMO_CACHE_SENTINEL = Symbol.for("react.memo_cache_sentinel");
		var MAYBE_ITERATOR_SYMBOL$1 = Symbol.iterator, REACT_CLIENT_REFERENCE = Symbol.for("react.client.reference"), isArrayImpl$1 = Array.isArray, ReactSharedInternals$1 = React$10.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE, rendererVersion = $$$config.rendererVersion, rendererPackageName = $$$config.rendererPackageName, extraDevToolsConfig = $$$config.extraDevToolsConfig, getPublicInstance = $$$config.getPublicInstance, getRootHostContext = $$$config.getRootHostContext, getChildHostContext = $$$config.getChildHostContext, prepareForCommit = $$$config.prepareForCommit, resetAfterCommit = $$$config.resetAfterCommit, createInstance = $$$config.createInstance;
		$$$config.cloneMutableInstance;
		var appendInitialChild = $$$config.appendInitialChild, finalizeInitialChildren = $$$config.finalizeInitialChildren, shouldSetTextContent = $$$config.shouldSetTextContent, createTextInstance = $$$config.createTextInstance;
		$$$config.cloneMutableTextInstance;
		var scheduleTimeout = $$$config.scheduleTimeout, cancelTimeout = $$$config.cancelTimeout, noTimeout = $$$config.noTimeout, isPrimaryRenderer = $$$config.isPrimaryRenderer;
		$$$config.warnsIfNotActing;
		var supportsMutation = $$$config.supportsMutation, supportsPersistence = $$$config.supportsPersistence, supportsHydration = $$$config.supportsHydration, getInstanceFromNode = $$$config.getInstanceFromNode;
		$$$config.beforeActiveInstanceBlur;
		var preparePortalMount = $$$config.preparePortalMount;
		$$$config.prepareScopeUpdate;
		$$$config.getInstanceFromScope;
		var setCurrentUpdatePriority = $$$config.setCurrentUpdatePriority, getCurrentUpdatePriority = $$$config.getCurrentUpdatePriority, resolveUpdatePriority = $$$config.resolveUpdatePriority;
		$$$config.trackSchedulerEvent;
		$$$config.resolveEventType;
		$$$config.resolveEventTimeStamp;
		var shouldAttemptEagerTransition = $$$config.shouldAttemptEagerTransition, detachDeletedInstance = $$$config.detachDeletedInstance;
		$$$config.requestPostPaintCallback;
		var maySuspendCommit = $$$config.maySuspendCommit, preloadInstance = $$$config.preloadInstance, startSuspendingCommit = $$$config.startSuspendingCommit, suspendInstance = $$$config.suspendInstance;
		$$$config.suspendOnActiveViewTransition;
		var waitForCommitToBeReady = $$$config.waitForCommitToBeReady, NotPendingTransition = $$$config.NotPendingTransition, HostTransitionContext = $$$config.HostTransitionContext, resetFormInstance = $$$config.resetFormInstance;
		$$$config.bindToConsole;
		var supportsMicrotasks = $$$config.supportsMicrotasks, scheduleMicrotask = $$$config.scheduleMicrotask, supportsTestSelectors = $$$config.supportsTestSelectors, findFiberRoot = $$$config.findFiberRoot, getBoundingRect = $$$config.getBoundingRect, getTextContent = $$$config.getTextContent, isHiddenSubtree = $$$config.isHiddenSubtree, matchAccessibilityRole = $$$config.matchAccessibilityRole, setFocusIfFocusable = $$$config.setFocusIfFocusable, setupIntersectionObserver = $$$config.setupIntersectionObserver, appendChild = $$$config.appendChild, appendChildToContainer = $$$config.appendChildToContainer, commitTextUpdate = $$$config.commitTextUpdate, commitMount = $$$config.commitMount, commitUpdate = $$$config.commitUpdate, insertBefore = $$$config.insertBefore, insertInContainerBefore = $$$config.insertInContainerBefore, removeChild = $$$config.removeChild, removeChildFromContainer = $$$config.removeChildFromContainer, resetTextContent = $$$config.resetTextContent, hideInstance = $$$config.hideInstance, hideTextInstance = $$$config.hideTextInstance, unhideInstance = $$$config.unhideInstance, unhideTextInstance = $$$config.unhideTextInstance;
		$$$config.cancelViewTransitionName;
		$$$config.cancelRootViewTransitionName;
		$$$config.restoreRootViewTransitionName;
		$$$config.cloneRootViewTransitionContainer;
		$$$config.removeRootViewTransitionClone;
		$$$config.measureClonedInstance;
		$$$config.hasInstanceChanged;
		$$$config.hasInstanceAffectedParent;
		$$$config.startViewTransition;
		$$$config.startGestureTransition;
		$$$config.stopGestureTransition;
		$$$config.getCurrentGestureOffset;
		$$$config.subscribeToGestureDirection;
		$$$config.createViewTransitionInstance;
		var clearContainer = $$$config.clearContainer;
		$$$config.createFragmentInstance;
		$$$config.updateFragmentInstanceFiber;
		$$$config.commitNewChildToFragmentInstance;
		$$$config.deleteChildFromFragmentInstance;
		var cloneInstance = $$$config.cloneInstance, createContainerChildSet = $$$config.createContainerChildSet, appendChildToContainerChildSet = $$$config.appendChildToContainerChildSet, finalizeContainerChildren = $$$config.finalizeContainerChildren, replaceContainerChildren = $$$config.replaceContainerChildren, cloneHiddenInstance = $$$config.cloneHiddenInstance, cloneHiddenTextInstance = $$$config.cloneHiddenTextInstance, isSuspenseInstancePending = $$$config.isSuspenseInstancePending, isSuspenseInstanceFallback = $$$config.isSuspenseInstanceFallback, getSuspenseInstanceFallbackErrorDetails = $$$config.getSuspenseInstanceFallbackErrorDetails, registerSuspenseInstanceRetry = $$$config.registerSuspenseInstanceRetry, canHydrateFormStateMarker = $$$config.canHydrateFormStateMarker, isFormStateMarkerMatching = $$$config.isFormStateMarkerMatching, getNextHydratableSibling = $$$config.getNextHydratableSibling, getNextHydratableSiblingAfterSingleton = $$$config.getNextHydratableSiblingAfterSingleton, getFirstHydratableChild = $$$config.getFirstHydratableChild, getFirstHydratableChildWithinContainer = $$$config.getFirstHydratableChildWithinContainer, getFirstHydratableChildWithinSuspenseInstance = $$$config.getFirstHydratableChildWithinSuspenseInstance, getFirstHydratableChildWithinSingleton = $$$config.getFirstHydratableChildWithinSingleton, canHydrateInstance = $$$config.canHydrateInstance, canHydrateTextInstance = $$$config.canHydrateTextInstance, canHydrateSuspenseInstance = $$$config.canHydrateSuspenseInstance, hydrateInstance = $$$config.hydrateInstance, hydrateTextInstance = $$$config.hydrateTextInstance, hydrateSuspenseInstance = $$$config.hydrateSuspenseInstance, getNextHydratableInstanceAfterSuspenseInstance = $$$config.getNextHydratableInstanceAfterSuspenseInstance, commitHydratedContainer = $$$config.commitHydratedContainer, commitHydratedSuspenseInstance = $$$config.commitHydratedSuspenseInstance, clearSuspenseBoundary = $$$config.clearSuspenseBoundary, clearSuspenseBoundaryFromContainer = $$$config.clearSuspenseBoundaryFromContainer, shouldDeleteUnhydratedTailInstances = $$$config.shouldDeleteUnhydratedTailInstances;
		$$$config.diffHydratedPropsForDevWarnings;
		$$$config.diffHydratedTextForDevWarnings;
		$$$config.describeHydratableInstanceForDevWarnings;
		var validateHydratableInstance = $$$config.validateHydratableInstance, validateHydratableTextInstance = $$$config.validateHydratableTextInstance, supportsResources = $$$config.supportsResources, isHostHoistableType = $$$config.isHostHoistableType, getHoistableRoot = $$$config.getHoistableRoot, getResource = $$$config.getResource, acquireResource = $$$config.acquireResource, releaseResource = $$$config.releaseResource, hydrateHoistable = $$$config.hydrateHoistable, mountHoistable = $$$config.mountHoistable, unmountHoistable = $$$config.unmountHoistable, createHoistableInstance = $$$config.createHoistableInstance, prepareToCommitHoistables = $$$config.prepareToCommitHoistables, mayResourceSuspendCommit = $$$config.mayResourceSuspendCommit, preloadResource = $$$config.preloadResource, suspendResource = $$$config.suspendResource, supportsSingletons = $$$config.supportsSingletons, resolveSingletonInstance = $$$config.resolveSingletonInstance, acquireSingletonInstance = $$$config.acquireSingletonInstance, releaseSingletonInstance = $$$config.releaseSingletonInstance, isHostSingletonType = $$$config.isHostSingletonType, isSingletonScope = $$$config.isSingletonScope, valueStack = [], index$jscomp$0 = -1, emptyContextObject = {}, clz32 = Math.clz32 ? Math.clz32 : clz32Fallback, log$1 = Math.log, LN2 = Math.LN2, nextTransitionLane = 256, nextRetryLane = 4194304, scheduleCallback$3 = Scheduler.unstable_scheduleCallback, cancelCallback$1 = Scheduler.unstable_cancelCallback, shouldYield = Scheduler.unstable_shouldYield, requestPaint = Scheduler.unstable_requestPaint, now = Scheduler.unstable_now, ImmediatePriority = Scheduler.unstable_ImmediatePriority, UserBlockingPriority = Scheduler.unstable_UserBlockingPriority, NormalPriority$1 = Scheduler.unstable_NormalPriority, IdlePriority = Scheduler.unstable_IdlePriority, log = Scheduler.log, unstable_setDisableYieldValue = Scheduler.unstable_setDisableYieldValue, rendererID = null, injectedHook = null, prefix, suffix, reentry = !1, CapturedStacks = /* @__PURE__ */ new WeakMap(), forkStack = [], forkStackIndex = 0, treeForkProvider = null, treeForkCount = 0, idStack = [], idStackIndex = 0, treeContextProvider = null, treeContextId = 1, treeContextOverflow = "", contextStackCursor = createCursor(null), contextFiberStackCursor = createCursor(null), rootInstanceStackCursor = createCursor(null), hostTransitionProviderCursor = createCursor(null), hydrationParentFiber = null, nextHydratableInstance = null, isHydrating = !1, hydrationErrors = null, rootOrSingletonContext = !1, HydrationMismatchException = Error(formatProdErrorMessage(519)), objectIs = "function" === typeof Object.is ? Object.is : is, valueCursor = createCursor(null), currentlyRenderingFiber$1 = null, lastContextDependency = null, AbortControllerLocal = "undefined" !== typeof AbortController ? AbortController : function() {
			var listeners = [], signal = this.signal = {
				aborted: !1,
				addEventListener: function(type, listener) {
					listeners.push(listener);
				}
			};
			this.abort = function() {
				signal.aborted = !0;
				listeners.forEach(function(listener) {
					return listener();
				});
			};
		}, scheduleCallback$2 = Scheduler.unstable_scheduleCallback, NormalPriority = Scheduler.unstable_NormalPriority, CacheContext = {
			$$typeof: REACT_CONTEXT_TYPE$1,
			Consumer: null,
			Provider: null,
			_currentValue: null,
			_currentValue2: null,
			_threadCount: 0
		}, firstScheduledRoot = null, lastScheduledRoot = null, didScheduleMicrotask = !1, mightHavePendingSyncWork = !1, isFlushingWork = !1, currentEventTransitionLane = 0, currentEntangledListeners = null, currentEntangledPendingCount = 0, currentEntangledLane = 0, currentEntangledActionThenable = null, prevOnStartTransitionFinish = ReactSharedInternals$1.S;
		ReactSharedInternals$1.S = function(transition, returnValue) {
			"object" === typeof returnValue && null !== returnValue && "function" === typeof returnValue.then && entangleAsyncAction(transition, returnValue);
			null !== prevOnStartTransitionFinish && prevOnStartTransitionFinish(transition, returnValue);
		};
		var resumedCache = createCursor(null), hasOwnProperty$1 = Object.prototype.hasOwnProperty, SuspenseException = Error(formatProdErrorMessage(460)), SuspenseyCommitException = Error(formatProdErrorMessage(474)), SuspenseActionException = Error(formatProdErrorMessage(542)), noopSuspenseyCommitThenable = { then: function() {} }, suspendedThenable = null, concurrentQueues = [], concurrentQueuesIndex = 0, concurrentlyUpdatedLanes = 0, hasForceUpdate = !1, didReadFromEntangledAsyncAction = !1, currentTreeHiddenStackCursor = createCursor(null), prevEntangledRenderLanesCursor = createCursor(0), renderLanes = 0, currentlyRenderingFiber = null, currentHook = null, workInProgressHook = null, didScheduleRenderPhaseUpdate = !1, didScheduleRenderPhaseUpdateDuringThisPass = !1, shouldDoubleInvokeUserFnsInHooksDEV = !1, localIdCounter = 0, thenableIndexCounter$1 = 0, thenableState$1 = null, globalClientIdCounter = 0, ContextOnlyDispatcher = {
			readContext,
			use,
			useCallback: throwInvalidHookError,
			useContext: throwInvalidHookError,
			useEffect: throwInvalidHookError,
			useImperativeHandle: throwInvalidHookError,
			useLayoutEffect: throwInvalidHookError,
			useInsertionEffect: throwInvalidHookError,
			useMemo: throwInvalidHookError,
			useReducer: throwInvalidHookError,
			useRef: throwInvalidHookError,
			useState: throwInvalidHookError,
			useDebugValue: throwInvalidHookError,
			useDeferredValue: throwInvalidHookError,
			useTransition: throwInvalidHookError,
			useSyncExternalStore: throwInvalidHookError,
			useId: throwInvalidHookError,
			useHostTransitionStatus: throwInvalidHookError,
			useFormState: throwInvalidHookError,
			useActionState: throwInvalidHookError,
			useOptimistic: throwInvalidHookError,
			useMemoCache: throwInvalidHookError,
			useCacheRefresh: throwInvalidHookError
		}, HooksDispatcherOnMount = {
			readContext,
			use,
			useCallback: function(callback, deps) {
				mountWorkInProgressHook().memoizedState = [callback, void 0 === deps ? null : deps];
				return callback;
			},
			useContext: readContext,
			useEffect: mountEffect,
			useImperativeHandle: function(ref, create$1, deps) {
				deps = null !== deps && void 0 !== deps ? deps.concat([ref]) : null;
				mountEffectImpl(4194308, 4, imperativeHandleEffect.bind(null, create$1, ref), deps);
			},
			useLayoutEffect: function(create$1, deps) {
				return mountEffectImpl(4194308, 4, create$1, deps);
			},
			useInsertionEffect: function(create$1, deps) {
				mountEffectImpl(4, 2, create$1, deps);
			},
			useMemo: function(nextCreate, deps) {
				var hook = mountWorkInProgressHook();
				deps = void 0 === deps ? null : deps;
				var nextValue = nextCreate();
				if (shouldDoubleInvokeUserFnsInHooksDEV) {
					setIsStrictModeForDevtools(!0);
					try {
						nextCreate();
					} finally {
						setIsStrictModeForDevtools(!1);
					}
				}
				hook.memoizedState = [nextValue, deps];
				return nextValue;
			},
			useReducer: function(reducer, initialArg, init) {
				var hook = mountWorkInProgressHook();
				if (void 0 !== init) {
					var initialState = init(initialArg);
					if (shouldDoubleInvokeUserFnsInHooksDEV) {
						setIsStrictModeForDevtools(!0);
						try {
							init(initialArg);
						} finally {
							setIsStrictModeForDevtools(!1);
						}
					}
				} else initialState = initialArg;
				hook.memoizedState = hook.baseState = initialState;
				reducer = {
					pending: null,
					lanes: 0,
					dispatch: null,
					lastRenderedReducer: reducer,
					lastRenderedState: initialState
				};
				hook.queue = reducer;
				reducer = reducer.dispatch = dispatchReducerAction.bind(null, currentlyRenderingFiber, reducer);
				return [hook.memoizedState, reducer];
			},
			useRef: function(initialValue) {
				var hook = mountWorkInProgressHook();
				initialValue = { current: initialValue };
				return hook.memoizedState = initialValue;
			},
			useState: function(initialState) {
				initialState = mountStateImpl(initialState);
				var queue = initialState.queue, dispatch = dispatchSetState.bind(null, currentlyRenderingFiber, queue);
				queue.dispatch = dispatch;
				return [initialState.memoizedState, dispatch];
			},
			useDebugValue: mountDebugValue,
			useDeferredValue: function(value, initialValue) {
				return mountDeferredValueImpl(mountWorkInProgressHook(), value, initialValue);
			},
			useTransition: function() {
				var stateHook = mountStateImpl(!1);
				stateHook = startTransition.bind(null, currentlyRenderingFiber, stateHook.queue, !0, !1);
				mountWorkInProgressHook().memoizedState = stateHook;
				return [!1, stateHook];
			},
			useSyncExternalStore: function(subscribe, getSnapshot, getServerSnapshot) {
				var fiber = currentlyRenderingFiber, hook = mountWorkInProgressHook();
				if (isHydrating) {
					if (void 0 === getServerSnapshot) throw Error(formatProdErrorMessage(407));
					getServerSnapshot = getServerSnapshot();
				} else {
					getServerSnapshot = getSnapshot();
					if (null === workInProgressRoot) throw Error(formatProdErrorMessage(349));
					0 !== (workInProgressRootRenderLanes & 124) || pushStoreConsistencyCheck(fiber, getSnapshot, getServerSnapshot);
				}
				hook.memoizedState = getServerSnapshot;
				var inst = {
					value: getServerSnapshot,
					getSnapshot
				};
				hook.queue = inst;
				mountEffect(subscribeToStore.bind(null, fiber, inst, subscribe), [subscribe]);
				fiber.flags |= 2048;
				pushSimpleEffect(9, createEffectInstance(), updateStoreInstance.bind(null, fiber, inst, getServerSnapshot, getSnapshot), null);
				return getServerSnapshot;
			},
			useId: function() {
				var hook = mountWorkInProgressHook(), identifierPrefix = workInProgressRoot.identifierPrefix;
				if (isHydrating) {
					var JSCompiler_inline_result = treeContextOverflow;
					var idWithLeadingBit = treeContextId;
					JSCompiler_inline_result = (idWithLeadingBit & ~(1 << 32 - clz32(idWithLeadingBit) - 1)).toString(32) + JSCompiler_inline_result;
					identifierPrefix = "" + identifierPrefix + "R" + JSCompiler_inline_result;
					JSCompiler_inline_result = localIdCounter++;
					0 < JSCompiler_inline_result && (identifierPrefix += "H" + JSCompiler_inline_result.toString(32));
					identifierPrefix += "";
				} else JSCompiler_inline_result = globalClientIdCounter++, identifierPrefix = "" + identifierPrefix + "r" + JSCompiler_inline_result.toString(32) + "";
				return hook.memoizedState = identifierPrefix;
			},
			useHostTransitionStatus,
			useFormState: mountActionState,
			useActionState: mountActionState,
			useOptimistic: function(passthrough) {
				var hook = mountWorkInProgressHook();
				hook.memoizedState = hook.baseState = passthrough;
				var queue = {
					pending: null,
					lanes: 0,
					dispatch: null,
					lastRenderedReducer: null,
					lastRenderedState: null
				};
				hook.queue = queue;
				hook = dispatchOptimisticSetState.bind(null, currentlyRenderingFiber, !0, queue);
				queue.dispatch = hook;
				return [passthrough, hook];
			},
			useMemoCache,
			useCacheRefresh: function() {
				return mountWorkInProgressHook().memoizedState = refreshCache.bind(null, currentlyRenderingFiber);
			}
		}, HooksDispatcherOnUpdate = {
			readContext,
			use,
			useCallback: updateCallback,
			useContext: readContext,
			useEffect: updateEffect,
			useImperativeHandle: updateImperativeHandle,
			useInsertionEffect: updateInsertionEffect,
			useLayoutEffect: updateLayoutEffect,
			useMemo: updateMemo,
			useReducer: updateReducer,
			useRef: updateRef,
			useState: function() {
				return updateReducer(basicStateReducer);
			},
			useDebugValue: mountDebugValue,
			useDeferredValue: function(value, initialValue) {
				return updateDeferredValueImpl(updateWorkInProgressHook(), currentHook.memoizedState, value, initialValue);
			},
			useTransition: function() {
				var booleanOrThenable = updateReducer(basicStateReducer)[0], start = updateWorkInProgressHook().memoizedState;
				return ["boolean" === typeof booleanOrThenable ? booleanOrThenable : useThenable(booleanOrThenable), start];
			},
			useSyncExternalStore: updateSyncExternalStore,
			useId: updateId,
			useHostTransitionStatus,
			useFormState: updateActionState,
			useActionState: updateActionState,
			useOptimistic: function(passthrough, reducer) {
				return updateOptimisticImpl(updateWorkInProgressHook(), currentHook, passthrough, reducer);
			},
			useMemoCache,
			useCacheRefresh: updateRefresh
		}, HooksDispatcherOnRerender = {
			readContext,
			use,
			useCallback: updateCallback,
			useContext: readContext,
			useEffect: updateEffect,
			useImperativeHandle: updateImperativeHandle,
			useInsertionEffect: updateInsertionEffect,
			useLayoutEffect: updateLayoutEffect,
			useMemo: updateMemo,
			useReducer: rerenderReducer,
			useRef: updateRef,
			useState: function() {
				return rerenderReducer(basicStateReducer);
			},
			useDebugValue: mountDebugValue,
			useDeferredValue: function(value, initialValue) {
				var hook = updateWorkInProgressHook();
				return null === currentHook ? mountDeferredValueImpl(hook, value, initialValue) : updateDeferredValueImpl(hook, currentHook.memoizedState, value, initialValue);
			},
			useTransition: function() {
				var booleanOrThenable = rerenderReducer(basicStateReducer)[0], start = updateWorkInProgressHook().memoizedState;
				return ["boolean" === typeof booleanOrThenable ? booleanOrThenable : useThenable(booleanOrThenable), start];
			},
			useSyncExternalStore: updateSyncExternalStore,
			useId: updateId,
			useHostTransitionStatus,
			useFormState: rerenderActionState,
			useActionState: rerenderActionState,
			useOptimistic: function(passthrough, reducer) {
				var hook = updateWorkInProgressHook();
				if (null !== currentHook) return updateOptimisticImpl(hook, currentHook, passthrough, reducer);
				hook.baseState = passthrough;
				return [passthrough, hook.queue.dispatch];
			},
			useMemoCache,
			useCacheRefresh: updateRefresh
		}, thenableState = null, thenableIndexCounter = 0, reconcileChildFibers = createChildReconciler(!0), mountChildFibers = createChildReconciler(!1), suspenseHandlerStackCursor = createCursor(null), shellBoundary = null, suspenseStackCursor = createCursor(0), classComponentUpdater = {
			enqueueSetState: function(inst, payload, callback) {
				inst = inst._reactInternals;
				var lane = requestUpdateLane(), update = createUpdate(lane);
				update.payload = payload;
				void 0 !== callback && null !== callback && (update.callback = callback);
				payload = enqueueUpdate(inst, update, lane);
				null !== payload && (scheduleUpdateOnFiber(payload, inst, lane), entangleTransitions(payload, inst, lane));
			},
			enqueueReplaceState: function(inst, payload, callback) {
				inst = inst._reactInternals;
				var lane = requestUpdateLane(), update = createUpdate(lane);
				update.tag = 1;
				update.payload = payload;
				void 0 !== callback && null !== callback && (update.callback = callback);
				payload = enqueueUpdate(inst, update, lane);
				null !== payload && (scheduleUpdateOnFiber(payload, inst, lane), entangleTransitions(payload, inst, lane));
			},
			enqueueForceUpdate: function(inst, callback) {
				inst = inst._reactInternals;
				var lane = requestUpdateLane(), update = createUpdate(lane);
				update.tag = 2;
				void 0 !== callback && null !== callback && (update.callback = callback);
				callback = enqueueUpdate(inst, update, lane);
				null !== callback && (scheduleUpdateOnFiber(callback, inst, lane), entangleTransitions(callback, inst, lane));
			}
		}, reportGlobalError$1 = "function" === typeof reportError ? reportError : function(error) {
			if ("object" === typeof window && "function" === typeof window.ErrorEvent) {
				var event = new window.ErrorEvent("error", {
					bubbles: !0,
					cancelable: !0,
					message: "object" === typeof error && null !== error && "string" === typeof error.message ? String(error.message) : String(error),
					error
				});
				if (!window.dispatchEvent(event)) return;
			} else if ("object" === typeof process && "function" === typeof process.emit) {
				process.emit("uncaughtException", error);
				return;
			}
			console.error(error);
		}, SelectiveHydrationException = Error(formatProdErrorMessage(461)), didReceiveUpdate = !1, SUSPENDED_MARKER = {
			dehydrated: null,
			treeContext: null,
			retryLane: 0,
			hydrationErrors: null
		}, offscreenSubtreeIsHidden = !1, offscreenSubtreeWasHidden = !1, needsFormReset = !1, PossiblyWeakSet = "function" === typeof WeakSet ? WeakSet : Set, nextEffect = null, hostParent = null, hostParentIsContainer = !1, currentHoistableRoot = null, suspenseyCommitFlag = 8192, DefaultAsyncDispatcher = { getCacheForType: function(resourceType) {
			var cache$4 = readContext(CacheContext), cacheForType = cache$4.data.get(resourceType);
			void 0 === cacheForType && (cacheForType = resourceType(), cache$4.data.set(resourceType, cacheForType));
			return cacheForType;
		} }, COMPONENT_TYPE = 0, HAS_PSEUDO_CLASS_TYPE = 1, ROLE_TYPE = 2, TEST_NAME_TYPE = 3, TEXT_TYPE = 4;
		if ("function" === typeof Symbol && Symbol.for) {
			var symbolFor = Symbol.for;
			COMPONENT_TYPE = symbolFor("selector.component");
			HAS_PSEUDO_CLASS_TYPE = symbolFor("selector.has_pseudo_class");
			ROLE_TYPE = symbolFor("selector.role");
			TEST_NAME_TYPE = symbolFor("selector.test_id");
			TEXT_TYPE = symbolFor("selector.text");
		}
		var PossiblyWeakMap = "function" === typeof WeakMap ? WeakMap : Map, executionContext = 0, workInProgressRoot = null, workInProgress = null, workInProgressRootRenderLanes = 0, workInProgressSuspendedReason = 0, workInProgressThrownValue = null, workInProgressRootDidSkipSuspendedSiblings = !1, workInProgressRootIsPrerendering = !1, workInProgressRootDidAttachPingListener = !1, entangledRenderLanes = 0, workInProgressRootExitStatus = 0, workInProgressRootSkippedLanes = 0, workInProgressRootInterleavedUpdatedLanes = 0, workInProgressRootPingedLanes = 0, workInProgressDeferredLane = 0, workInProgressSuspendedRetryLanes = 0, workInProgressRootConcurrentErrors = null, workInProgressRootRecoverableErrors = null, workInProgressRootDidIncludeRecursiveRenderUpdate = !1, globalMostRecentFallbackTime = 0, workInProgressRootRenderTargetTime = Infinity, workInProgressTransitions = null, legacyErrorBoundariesThatAlreadyFailed = null, pendingEffectsStatus = 0, pendingEffectsRoot = null, pendingFinishedWork = null, pendingEffectsLanes = 0, pendingEffectsRemainingLanes = 0, pendingPassiveTransitions = null, pendingRecoverableErrors = null, nestedUpdateCount = 0, rootWithNestedUpdates = null;
		exports$1.attemptContinuousHydration = function(fiber) {
			if (13 === fiber.tag) {
				var root = enqueueConcurrentRenderForLane(fiber, 67108864);
				null !== root && scheduleUpdateOnFiber(root, fiber, 67108864);
				markRetryLaneIfNotHydrated(fiber, 67108864);
			}
		};
		exports$1.attemptHydrationAtCurrentPriority = function(fiber) {
			if (13 === fiber.tag) {
				var lane = requestUpdateLane();
				lane = getBumpedLaneForHydrationByLane(lane);
				var root = enqueueConcurrentRenderForLane(fiber, lane);
				null !== root && scheduleUpdateOnFiber(root, fiber, lane);
				markRetryLaneIfNotHydrated(fiber, lane);
			}
		};
		exports$1.attemptSynchronousHydration = function(fiber) {
			switch (fiber.tag) {
				case 3:
					fiber = fiber.stateNode;
					if (fiber.current.memoizedState.isDehydrated) {
						var lanes = getHighestPriorityLanes(fiber.pendingLanes);
						if (0 !== lanes) {
							fiber.pendingLanes |= 2;
							for (fiber.entangledLanes |= 2; lanes;) {
								var lane = 1 << 31 - clz32(lanes);
								fiber.entanglements[1] |= lane;
								lanes &= ~lane;
							}
							ensureRootIsScheduled(fiber);
							0 === (executionContext & 6) && (workInProgressRootRenderTargetTime = now() + 500, flushSyncWorkAcrossRoots_impl(0, !1));
						}
					}
					break;
				case 13: lanes = enqueueConcurrentRenderForLane(fiber, 2), null !== lanes && scheduleUpdateOnFiber(lanes, fiber, 2), flushSyncWork(), markRetryLaneIfNotHydrated(fiber, 2);
			}
		};
		exports$1.batchedUpdates = function(fn, a) {
			return fn(a);
		};
		exports$1.createComponentSelector = function(component) {
			return {
				$$typeof: COMPONENT_TYPE,
				value: component
			};
		};
		exports$1.createContainer = function(containerInfo, tag, hydrationCallbacks, isStrictMode, concurrentUpdatesByDefaultOverride, identifierPrefix, onUncaughtError, onCaughtError, onRecoverableError, transitionCallbacks) {
			return createFiberRoot(containerInfo, tag, !1, null, hydrationCallbacks, isStrictMode, identifierPrefix, onUncaughtError, onCaughtError, onRecoverableError, transitionCallbacks, null);
		};
		exports$1.createHasPseudoClassSelector = function(selectors) {
			return {
				$$typeof: HAS_PSEUDO_CLASS_TYPE,
				value: selectors
			};
		};
		exports$1.createHydrationContainer = function(initialChildren, callback, containerInfo, tag, hydrationCallbacks, isStrictMode, concurrentUpdatesByDefaultOverride, identifierPrefix, onUncaughtError, onCaughtError, onRecoverableError, transitionCallbacks, formState) {
			initialChildren = createFiberRoot(containerInfo, tag, !0, initialChildren, hydrationCallbacks, isStrictMode, identifierPrefix, onUncaughtError, onCaughtError, onRecoverableError, transitionCallbacks, formState);
			initialChildren.context = getContextForSubtree(null);
			containerInfo = initialChildren.current;
			tag = requestUpdateLane();
			tag = getBumpedLaneForHydrationByLane(tag);
			hydrationCallbacks = createUpdate(tag);
			hydrationCallbacks.callback = void 0 !== callback && null !== callback ? callback : null;
			enqueueUpdate(containerInfo, hydrationCallbacks, tag);
			callback = tag;
			initialChildren.current.lanes = callback;
			markRootUpdated$1(initialChildren, callback);
			ensureRootIsScheduled(initialChildren);
			return initialChildren;
		};
		exports$1.createPortal = function(children, containerInfo, implementation) {
			var key = 3 < arguments.length && void 0 !== arguments[3] ? arguments[3] : null;
			return {
				$$typeof: REACT_PORTAL_TYPE$1,
				key: null == key ? null : "" + key,
				children,
				containerInfo,
				implementation
			};
		};
		exports$1.createRoleSelector = function(role) {
			return {
				$$typeof: ROLE_TYPE,
				value: role
			};
		};
		exports$1.createTestNameSelector = function(id) {
			return {
				$$typeof: TEST_NAME_TYPE,
				value: id
			};
		};
		exports$1.createTextSelector = function(text) {
			return {
				$$typeof: TEXT_TYPE,
				value: text
			};
		};
		exports$1.defaultOnCaughtError = function(error) {
			console.error(error);
		};
		exports$1.defaultOnRecoverableError = function(error) {
			reportGlobalError$1(error);
		};
		exports$1.defaultOnUncaughtError = function(error) {
			reportGlobalError$1(error);
		};
		exports$1.deferredUpdates = function(fn) {
			var prevTransition = ReactSharedInternals$1.T, previousPriority = getCurrentUpdatePriority();
			try {
				return setCurrentUpdatePriority(32), ReactSharedInternals$1.T = null, fn();
			} finally {
				setCurrentUpdatePriority(previousPriority), ReactSharedInternals$1.T = prevTransition;
			}
		};
		exports$1.discreteUpdates = function(fn, a, b, c, d) {
			var prevTransition = ReactSharedInternals$1.T, previousPriority = getCurrentUpdatePriority();
			try {
				return setCurrentUpdatePriority(2), ReactSharedInternals$1.T = null, fn(a, b, c, d);
			} finally {
				setCurrentUpdatePriority(previousPriority), ReactSharedInternals$1.T = prevTransition, 0 === executionContext && (workInProgressRootRenderTargetTime = now() + 500);
			}
		};
		exports$1.findAllNodes = findAllNodes;
		exports$1.findBoundingRects = function(hostRoot, selectors) {
			if (!supportsTestSelectors) throw Error(formatProdErrorMessage(363));
			selectors = findAllNodes(hostRoot, selectors);
			hostRoot = [];
			for (var i = 0; i < selectors.length; i++) hostRoot.push(getBoundingRect(selectors[i]));
			for (selectors = hostRoot.length - 1; 0 < selectors; selectors--) {
				i = hostRoot[selectors];
				for (var targetLeft = i.x, targetRight = targetLeft + i.width, targetTop = i.y, targetBottom = targetTop + i.height, j = selectors - 1; 0 <= j; j--) if (selectors !== j) {
					var otherRect = hostRoot[j], otherLeft = otherRect.x, otherRight = otherLeft + otherRect.width, otherTop = otherRect.y, otherBottom = otherTop + otherRect.height;
					if (targetLeft >= otherLeft && targetTop >= otherTop && targetRight <= otherRight && targetBottom <= otherBottom) {
						hostRoot.splice(selectors, 1);
						break;
					} else if (!(targetLeft !== otherLeft || i.width !== otherRect.width || otherBottom < targetTop || otherTop > targetBottom)) {
						otherTop > targetTop && (otherRect.height += otherTop - targetTop, otherRect.y = targetTop);
						otherBottom < targetBottom && (otherRect.height = targetBottom - otherTop);
						hostRoot.splice(selectors, 1);
						break;
					} else if (!(targetTop !== otherTop || i.height !== otherRect.height || otherRight < targetLeft || otherLeft > targetRight)) {
						otherLeft > targetLeft && (otherRect.width += otherLeft - targetLeft, otherRect.x = targetLeft);
						otherRight < targetRight && (otherRect.width = targetRight - otherLeft);
						hostRoot.splice(selectors, 1);
						break;
					}
				}
			}
			return hostRoot;
		};
		exports$1.findHostInstance = findHostInstance;
		exports$1.findHostInstanceWithNoPortals = function(fiber) {
			fiber = findCurrentFiberUsingSlowPath(fiber);
			fiber = null !== fiber ? findCurrentHostFiberWithNoPortalsImpl(fiber) : null;
			return null === fiber ? null : getPublicInstance(fiber.stateNode);
		};
		exports$1.findHostInstanceWithWarning = function(component) {
			return findHostInstance(component);
		};
		exports$1.flushPassiveEffects = flushPendingEffects;
		exports$1.flushSyncFromReconciler = function(fn) {
			var prevExecutionContext = executionContext;
			executionContext |= 1;
			var prevTransition = ReactSharedInternals$1.T, previousPriority = getCurrentUpdatePriority();
			try {
				if (setCurrentUpdatePriority(2), ReactSharedInternals$1.T = null, fn) return fn();
			} finally {
				setCurrentUpdatePriority(previousPriority), ReactSharedInternals$1.T = prevTransition, executionContext = prevExecutionContext, 0 === (executionContext & 6) && flushSyncWorkAcrossRoots_impl(0, !1);
			}
		};
		exports$1.flushSyncWork = flushSyncWork;
		exports$1.focusWithin = function(hostRoot, selectors) {
			if (!supportsTestSelectors) throw Error(formatProdErrorMessage(363));
			hostRoot = findFiberRootForHostRoot(hostRoot);
			selectors = findPaths(hostRoot, selectors);
			selectors = Array.from(selectors);
			for (hostRoot = 0; hostRoot < selectors.length;) {
				var fiber = selectors[hostRoot++], tag = fiber.tag;
				if (!isHiddenSubtree(fiber)) {
					if ((5 === tag || 26 === tag || 27 === tag) && setFocusIfFocusable(fiber.stateNode)) return !0;
					for (fiber = fiber.child; null !== fiber;) selectors.push(fiber), fiber = fiber.sibling;
				}
			}
			return !1;
		};
		exports$1.getFindAllNodesFailureDescription = function(hostRoot, selectors) {
			if (!supportsTestSelectors) throw Error(formatProdErrorMessage(363));
			var maxSelectorIndex = 0, matchedNames = [];
			hostRoot = [findFiberRootForHostRoot(hostRoot), 0];
			for (var index = 0; index < hostRoot.length;) {
				var fiber = hostRoot[index++], tag = fiber.tag, selectorIndex = hostRoot[index++], selector = selectors[selectorIndex];
				if (5 !== tag && 26 !== tag && 27 !== tag || !isHiddenSubtree(fiber)) {
					if (matchSelector(fiber, selector) && (matchedNames.push(selectorToString(selector)), selectorIndex++, selectorIndex > maxSelectorIndex && (maxSelectorIndex = selectorIndex)), selectorIndex < selectors.length) for (fiber = fiber.child; null !== fiber;) hostRoot.push(fiber, selectorIndex), fiber = fiber.sibling;
				}
			}
			if (maxSelectorIndex < selectors.length) {
				for (hostRoot = []; maxSelectorIndex < selectors.length; maxSelectorIndex++) hostRoot.push(selectorToString(selectors[maxSelectorIndex]));
				return "findAllNodes was able to match part of the selector:\n  " + (matchedNames.join(" > ") + "\n\nNo matching component was found for:\n  ") + hostRoot.join(" > ");
			}
			return null;
		};
		exports$1.getPublicRootInstance = function(container) {
			container = container.current;
			if (!container.child) return null;
			switch (container.child.tag) {
				case 27:
				case 5: return getPublicInstance(container.child.stateNode);
				default: return container.child.stateNode;
			}
		};
		exports$1.injectIntoDevTools = function() {
			var internals = {
				bundleType: 0,
				version: rendererVersion,
				rendererPackageName,
				currentDispatcherRef: ReactSharedInternals$1,
				reconcilerVersion: "19.1.0"
			};
			null !== extraDevToolsConfig && (internals.rendererConfig = extraDevToolsConfig);
			if ("undefined" === typeof __REACT_DEVTOOLS_GLOBAL_HOOK__) internals = !1;
			else {
				var hook = __REACT_DEVTOOLS_GLOBAL_HOOK__;
				if (hook.isDisabled || !hook.supportsFiber) internals = !0;
				else {
					try {
						rendererID = hook.inject(internals), injectedHook = hook;
					} catch (err) {}
					internals = hook.checkDCE ? !0 : !1;
				}
			}
			return internals;
		};
		exports$1.isAlreadyRendering = function() {
			return 0 !== (executionContext & 6);
		};
		exports$1.observeVisibleRects = function(hostRoot, selectors, callback, options) {
			if (!supportsTestSelectors) throw Error(formatProdErrorMessage(363));
			hostRoot = findAllNodes(hostRoot, selectors);
			var disconnect = setupIntersectionObserver(hostRoot, callback, options).disconnect;
			return { disconnect: function() {
				disconnect();
			} };
		};
		exports$1.shouldError = function() {
			return null;
		};
		exports$1.shouldSuspend = function() {
			return !1;
		};
		exports$1.startHostTransition = function(formFiber, pendingState, action, formData) {
			if (5 !== formFiber.tag) throw Error(formatProdErrorMessage(476));
			var queue = ensureFormComponentIsStateful(formFiber).queue;
			startTransition(formFiber, queue, pendingState, NotPendingTransition, null === action ? noop$2 : function() {
				var resetStateQueue = ensureFormComponentIsStateful(formFiber).next.queue;
				dispatchSetStateInternal(formFiber, resetStateQueue, {}, requestUpdateLane());
				return action(formData);
			});
		};
		exports$1.updateContainer = function(element, container, parentComponent, callback) {
			var current = container.current, lane = requestUpdateLane();
			updateContainerImpl(current, lane, element, container, parentComponent, callback);
			return lane;
		};
		exports$1.updateContainerSync = function(element, container, parentComponent, callback) {
			updateContainerImpl(container.current, 2, element, container, parentComponent, callback);
			return 2;
		};
		return exports$1;
	};
	module.exports.default = module.exports;
	Object.defineProperty(module.exports, "__esModule", { value: !0 });
}) });

//#endregion
//#region node_modules/react-reconciler/index.js
var require_react_reconciler = /* @__PURE__ */ __commonJS({ "node_modules/react-reconciler/index.js": ((exports, module) => {
	module.exports = require_react_reconciler_production();
}) });

//#endregion
//#region node_modules/widest-line/index.js
var import_react_reconciler = /* @__PURE__ */ __toESM(require_react_reconciler(), 1);
function widestLine(string) {
	let lineWidth = 0;
	for (const line of string.split("\n")) lineWidth = Math.max(lineWidth, stringWidth(line));
	return lineWidth;
}

//#endregion
//#region node_modules/ink/build/measure-text.js
const cache$3 = /* @__PURE__ */ new Map();
const measureText = (text) => {
	if (text.length === 0) return {
		width: 0,
		height: 0
	};
	const cachedDimensions = cache$3.get(text);
	if (cachedDimensions) return cachedDimensions;
	const dimensions = {
		width: widestLine(text),
		height: text.split("\n").length
	};
	cache$3.set(text, dimensions);
	return dimensions;
};
var measure_text_default = measureText;

//#endregion
//#region node_modules/cli-truncate/node_modules/is-fullwidth-code-point/index.js
function isFullwidthCodePoint$1(codePoint) {
	if (!Number.isInteger(codePoint)) return false;
	return codePoint >= 4352 && (codePoint <= 4447 || codePoint === 9001 || codePoint === 9002 || 11904 <= codePoint && codePoint <= 12871 && codePoint !== 12351 || 12880 <= codePoint && codePoint <= 19903 || 19968 <= codePoint && codePoint <= 42182 || 43360 <= codePoint && codePoint <= 43388 || 44032 <= codePoint && codePoint <= 55203 || 63744 <= codePoint && codePoint <= 64255 || 65040 <= codePoint && codePoint <= 65049 || 65072 <= codePoint && codePoint <= 65131 || 65281 <= codePoint && codePoint <= 65376 || 65504 <= codePoint && codePoint <= 65510 || 110592 <= codePoint && codePoint <= 110593 || 127488 <= codePoint && codePoint <= 127569 || 131072 <= codePoint && codePoint <= 262141);
}

//#endregion
//#region node_modules/cli-truncate/node_modules/slice-ansi/index.js
const astralRegex = /^[\uD800-\uDBFF][\uDC00-\uDFFF]$/;
const ESCAPES$2 = ["\x1B", ""];
const wrapAnsi$1 = (code) => `${ESCAPES$2[0]}[${code}m`;
const checkAnsi = (ansiCodes, isEscapes, endAnsiCode) => {
	let output = [];
	ansiCodes = [...ansiCodes];
	for (let ansiCode of ansiCodes) {
		const ansiCodeOrigin = ansiCode;
		if (ansiCode.includes(";")) ansiCode = ansiCode.split(";")[0][0] + "0";
		const item = ansi_styles_default.codes.get(Number.parseInt(ansiCode, 10));
		if (item) {
			const indexEscape = ansiCodes.indexOf(item.toString());
			if (indexEscape === -1) output.push(wrapAnsi$1(isEscapes ? item : ansiCodeOrigin));
			else ansiCodes.splice(indexEscape, 1);
		} else if (isEscapes) {
			output.push(wrapAnsi$1(0));
			break;
		} else output.push(wrapAnsi$1(ansiCodeOrigin));
	}
	if (isEscapes) {
		output = output.filter((element, index) => output.indexOf(element) === index);
		if (endAnsiCode !== void 0) {
			const fistEscapeCode = wrapAnsi$1(ansi_styles_default.codes.get(Number.parseInt(endAnsiCode, 10)));
			output = output.reduce((current, next) => next === fistEscapeCode ? [next, ...current] : [...current, next], []);
		}
	}
	return output.join("");
};
function sliceAnsi$1(string, begin, end) {
	const characters = [...string];
	const ansiCodes = [];
	let stringEnd = typeof end === "number" ? end : characters.length;
	let isInsideEscape = false;
	let ansiCode;
	let visible = 0;
	let output = "";
	for (const [index, character] of characters.entries()) {
		let leftEscape = false;
		if (ESCAPES$2.includes(character)) {
			const code = /\d[^m]*/.exec(string.slice(index, index + 18));
			ansiCode = code && code.length > 0 ? code[0] : void 0;
			if (visible < stringEnd) {
				isInsideEscape = true;
				if (ansiCode !== void 0) ansiCodes.push(ansiCode);
			}
		} else if (isInsideEscape && character === "m") {
			isInsideEscape = false;
			leftEscape = true;
		}
		if (!isInsideEscape && !leftEscape) visible++;
		if (!astralRegex.test(character) && isFullwidthCodePoint$1(character.codePointAt())) {
			visible++;
			if (typeof end !== "number") stringEnd++;
		}
		if (visible > begin && visible <= stringEnd) output += character;
		else if (visible === begin && !isInsideEscape && ansiCode !== void 0) output = checkAnsi(ansiCodes);
		else if (visible >= stringEnd) {
			output += checkAnsi(ansiCodes, true, ansiCode);
			break;
		}
	}
	return output;
}

//#endregion
//#region node_modules/cli-truncate/index.js
function getIndexOfNearestSpace(string, wantedIndex, shouldSearchRight) {
	if (string.charAt(wantedIndex) === " ") return wantedIndex;
	const direction = shouldSearchRight ? 1 : -1;
	for (let index = 0; index <= 3; index++) {
		const finalIndex = wantedIndex + index * direction;
		if (string.charAt(finalIndex) === " ") return finalIndex;
	}
	return wantedIndex;
}
function cliTruncate(text, columns, options = {}) {
	const { position = "end", space = false, preferTruncationOnSpace = false } = options;
	let { truncationCharacter = "" } = options;
	if (typeof text !== "string") throw new TypeError(`Expected \`input\` to be a string, got ${typeof text}`);
	if (typeof columns !== "number") throw new TypeError(`Expected \`columns\` to be a number, got ${typeof columns}`);
	if (columns < 1) return "";
	if (columns === 1) return truncationCharacter;
	const length = stringWidth(text);
	if (length <= columns) return text;
	if (position === "start") {
		if (preferTruncationOnSpace) {
			const nearestSpace = getIndexOfNearestSpace(text, length - columns + 1, true);
			return truncationCharacter + sliceAnsi$1(text, nearestSpace, length).trim();
		}
		if (space === true) truncationCharacter += " ";
		return truncationCharacter + sliceAnsi$1(text, length - columns + stringWidth(truncationCharacter), length);
	}
	if (position === "middle") {
		if (space === true) truncationCharacter = ` ${truncationCharacter} `;
		const half = Math.floor(columns / 2);
		if (preferTruncationOnSpace) {
			const spaceNearFirstBreakPoint = getIndexOfNearestSpace(text, half);
			const spaceNearSecondBreakPoint = getIndexOfNearestSpace(text, length - (columns - half) + 1, true);
			return sliceAnsi$1(text, 0, spaceNearFirstBreakPoint) + truncationCharacter + sliceAnsi$1(text, spaceNearSecondBreakPoint, length).trim();
		}
		return sliceAnsi$1(text, 0, half) + truncationCharacter + sliceAnsi$1(text, length - (columns - half) + stringWidth(truncationCharacter), length);
	}
	if (position === "end") {
		if (preferTruncationOnSpace) return sliceAnsi$1(text, 0, getIndexOfNearestSpace(text, columns - 1)) + truncationCharacter;
		if (space === true) truncationCharacter = ` ${truncationCharacter}`;
		return sliceAnsi$1(text, 0, columns - stringWidth(truncationCharacter)) + truncationCharacter;
	}
	throw new Error(`Expected \`options.position\` to be either \`start\`, \`middle\` or \`end\`, got ${position}`);
}

//#endregion
//#region node_modules/ink/build/wrap-text.js
const cache$2 = {};
const wrapText = (text, maxWidth, wrapType) => {
	const cacheKey = text + String(maxWidth) + String(wrapType);
	const cachedText = cache$2[cacheKey];
	if (cachedText) return cachedText;
	let wrappedText = text;
	if (wrapType === "wrap") wrappedText = wrapAnsi(text, maxWidth, {
		trim: false,
		hard: true
	});
	if (wrapType.startsWith("truncate")) {
		let position = "end";
		if (wrapType === "truncate-middle") position = "middle";
		if (wrapType === "truncate-start") position = "start";
		wrappedText = cliTruncate(text, maxWidth, { position });
	}
	cache$2[cacheKey] = wrappedText;
	return wrappedText;
};
var wrap_text_default = wrapText;

//#endregion
//#region node_modules/ink/build/squash-text-nodes.js
const squashTextNodes = (node) => {
	let text = "";
	for (let index = 0; index < node.childNodes.length; index++) {
		const childNode = node.childNodes[index];
		if (childNode === void 0) continue;
		let nodeText = "";
		if (childNode.nodeName === "#text") nodeText = childNode.nodeValue;
		else {
			if (childNode.nodeName === "ink-text" || childNode.nodeName === "ink-virtual-text") nodeText = squashTextNodes(childNode);
			if (nodeText.length > 0 && typeof childNode.internal_transform === "function") nodeText = childNode.internal_transform(nodeText, index);
		}
		text += nodeText;
	}
	return text;
};
var squash_text_nodes_default = squashTextNodes;

//#endregion
//#region node_modules/ink/build/dom.js
const createNode = (nodeName) => {
	const node = {
		nodeName,
		style: {},
		attributes: {},
		childNodes: [],
		parentNode: void 0,
		yogaNode: nodeName === "ink-virtual-text" ? void 0 : src_default.Node.create(),
		internal_accessibility: {}
	};
	if (nodeName === "ink-text") node.yogaNode?.setMeasureFunc(measureTextNode.bind(null, node));
	return node;
};
const appendChildNode = (node, childNode) => {
	if (childNode.parentNode) removeChildNode(childNode.parentNode, childNode);
	childNode.parentNode = node;
	node.childNodes.push(childNode);
	if (childNode.yogaNode) node.yogaNode?.insertChild(childNode.yogaNode, node.yogaNode.getChildCount());
	if (node.nodeName === "ink-text" || node.nodeName === "ink-virtual-text") markNodeAsDirty(node);
};
const insertBeforeNode = (node, newChildNode, beforeChildNode) => {
	if (newChildNode.parentNode) removeChildNode(newChildNode.parentNode, newChildNode);
	newChildNode.parentNode = node;
	const index = node.childNodes.indexOf(beforeChildNode);
	if (index >= 0) {
		node.childNodes.splice(index, 0, newChildNode);
		if (newChildNode.yogaNode) node.yogaNode?.insertChild(newChildNode.yogaNode, index);
		return;
	}
	node.childNodes.push(newChildNode);
	if (newChildNode.yogaNode) node.yogaNode?.insertChild(newChildNode.yogaNode, node.yogaNode.getChildCount());
	if (node.nodeName === "ink-text" || node.nodeName === "ink-virtual-text") markNodeAsDirty(node);
};
const removeChildNode = (node, removeNode) => {
	if (removeNode.yogaNode) removeNode.parentNode?.yogaNode?.removeChild(removeNode.yogaNode);
	removeNode.parentNode = void 0;
	const index = node.childNodes.indexOf(removeNode);
	if (index >= 0) node.childNodes.splice(index, 1);
	if (node.nodeName === "ink-text" || node.nodeName === "ink-virtual-text") markNodeAsDirty(node);
};
const setAttribute = (node, key, value) => {
	if (key === "internal_accessibility") {
		node.internal_accessibility = value;
		return;
	}
	node.attributes[key] = value;
};
const setStyle = (node, style) => {
	node.style = style;
};
const createTextNode = (text) => {
	const node = {
		nodeName: "#text",
		nodeValue: text,
		yogaNode: void 0,
		parentNode: void 0,
		style: {}
	};
	setTextNodeValue(node, text);
	return node;
};
const measureTextNode = function(node, width) {
	const text = node.nodeName === "#text" ? node.nodeValue : squash_text_nodes_default(node);
	const dimensions = measure_text_default(text);
	if (dimensions.width <= width) return dimensions;
	if (dimensions.width >= 1 && width > 0 && width < 1) return dimensions;
	return measure_text_default(wrap_text_default(text, width, node.style?.textWrap ?? "wrap"));
};
const findClosestYogaNode = (node) => {
	if (!node?.parentNode) return;
	return node.yogaNode ?? findClosestYogaNode(node.parentNode);
};
const markNodeAsDirty = (node) => {
	findClosestYogaNode(node)?.markDirty();
};
const setTextNodeValue = (node, text) => {
	if (typeof text !== "string") text = String(text);
	node.nodeValue = text;
	markNodeAsDirty(node);
};

//#endregion
//#region node_modules/ink/build/styles.js
const applyPositionStyles = (node, style) => {
	if ("position" in style) node.setPositionType(style.position === "absolute" ? src_default.POSITION_TYPE_ABSOLUTE : src_default.POSITION_TYPE_RELATIVE);
};
const applyMarginStyles = (node, style) => {
	if ("margin" in style) node.setMargin(src_default.EDGE_ALL, style.margin ?? 0);
	if ("marginX" in style) node.setMargin(src_default.EDGE_HORIZONTAL, style.marginX ?? 0);
	if ("marginY" in style) node.setMargin(src_default.EDGE_VERTICAL, style.marginY ?? 0);
	if ("marginLeft" in style) node.setMargin(src_default.EDGE_START, style.marginLeft || 0);
	if ("marginRight" in style) node.setMargin(src_default.EDGE_END, style.marginRight || 0);
	if ("marginTop" in style) node.setMargin(src_default.EDGE_TOP, style.marginTop || 0);
	if ("marginBottom" in style) node.setMargin(src_default.EDGE_BOTTOM, style.marginBottom || 0);
};
const applyPaddingStyles = (node, style) => {
	if ("padding" in style) node.setPadding(src_default.EDGE_ALL, style.padding ?? 0);
	if ("paddingX" in style) node.setPadding(src_default.EDGE_HORIZONTAL, style.paddingX ?? 0);
	if ("paddingY" in style) node.setPadding(src_default.EDGE_VERTICAL, style.paddingY ?? 0);
	if ("paddingLeft" in style) node.setPadding(src_default.EDGE_LEFT, style.paddingLeft || 0);
	if ("paddingRight" in style) node.setPadding(src_default.EDGE_RIGHT, style.paddingRight || 0);
	if ("paddingTop" in style) node.setPadding(src_default.EDGE_TOP, style.paddingTop || 0);
	if ("paddingBottom" in style) node.setPadding(src_default.EDGE_BOTTOM, style.paddingBottom || 0);
};
const applyFlexStyles = (node, style) => {
	if ("flexGrow" in style) node.setFlexGrow(style.flexGrow ?? 0);
	if ("flexShrink" in style) node.setFlexShrink(typeof style.flexShrink === "number" ? style.flexShrink : 1);
	if ("flexWrap" in style) {
		if (style.flexWrap === "nowrap") node.setFlexWrap(src_default.WRAP_NO_WRAP);
		if (style.flexWrap === "wrap") node.setFlexWrap(src_default.WRAP_WRAP);
		if (style.flexWrap === "wrap-reverse") node.setFlexWrap(src_default.WRAP_WRAP_REVERSE);
	}
	if ("flexDirection" in style) {
		if (style.flexDirection === "row") node.setFlexDirection(src_default.FLEX_DIRECTION_ROW);
		if (style.flexDirection === "row-reverse") node.setFlexDirection(src_default.FLEX_DIRECTION_ROW_REVERSE);
		if (style.flexDirection === "column") node.setFlexDirection(src_default.FLEX_DIRECTION_COLUMN);
		if (style.flexDirection === "column-reverse") node.setFlexDirection(src_default.FLEX_DIRECTION_COLUMN_REVERSE);
	}
	if ("flexBasis" in style) if (typeof style.flexBasis === "number") node.setFlexBasis(style.flexBasis);
	else if (typeof style.flexBasis === "string") node.setFlexBasisPercent(Number.parseInt(style.flexBasis, 10));
	else node.setFlexBasis(NaN);
	if ("alignItems" in style) {
		if (style.alignItems === "stretch" || !style.alignItems) node.setAlignItems(src_default.ALIGN_STRETCH);
		if (style.alignItems === "flex-start") node.setAlignItems(src_default.ALIGN_FLEX_START);
		if (style.alignItems === "center") node.setAlignItems(src_default.ALIGN_CENTER);
		if (style.alignItems === "flex-end") node.setAlignItems(src_default.ALIGN_FLEX_END);
	}
	if ("alignSelf" in style) {
		if (style.alignSelf === "auto" || !style.alignSelf) node.setAlignSelf(src_default.ALIGN_AUTO);
		if (style.alignSelf === "flex-start") node.setAlignSelf(src_default.ALIGN_FLEX_START);
		if (style.alignSelf === "center") node.setAlignSelf(src_default.ALIGN_CENTER);
		if (style.alignSelf === "flex-end") node.setAlignSelf(src_default.ALIGN_FLEX_END);
	}
	if ("justifyContent" in style) {
		if (style.justifyContent === "flex-start" || !style.justifyContent) node.setJustifyContent(src_default.JUSTIFY_FLEX_START);
		if (style.justifyContent === "center") node.setJustifyContent(src_default.JUSTIFY_CENTER);
		if (style.justifyContent === "flex-end") node.setJustifyContent(src_default.JUSTIFY_FLEX_END);
		if (style.justifyContent === "space-between") node.setJustifyContent(src_default.JUSTIFY_SPACE_BETWEEN);
		if (style.justifyContent === "space-around") node.setJustifyContent(src_default.JUSTIFY_SPACE_AROUND);
		if (style.justifyContent === "space-evenly") node.setJustifyContent(src_default.JUSTIFY_SPACE_EVENLY);
	}
};
const applyDimensionStyles = (node, style) => {
	if ("width" in style) if (typeof style.width === "number") node.setWidth(style.width);
	else if (typeof style.width === "string") node.setWidthPercent(Number.parseInt(style.width, 10));
	else node.setWidthAuto();
	if ("height" in style) if (typeof style.height === "number") node.setHeight(style.height);
	else if (typeof style.height === "string") node.setHeightPercent(Number.parseInt(style.height, 10));
	else node.setHeightAuto();
	if ("minWidth" in style) if (typeof style.minWidth === "string") node.setMinWidthPercent(Number.parseInt(style.minWidth, 10));
	else node.setMinWidth(style.minWidth ?? 0);
	if ("minHeight" in style) if (typeof style.minHeight === "string") node.setMinHeightPercent(Number.parseInt(style.minHeight, 10));
	else node.setMinHeight(style.minHeight ?? 0);
};
const applyDisplayStyles = (node, style) => {
	if ("display" in style) node.setDisplay(style.display === "flex" ? src_default.DISPLAY_FLEX : src_default.DISPLAY_NONE);
};
const applyBorderStyles = (node, style) => {
	if ("borderStyle" in style) {
		const borderWidth = style.borderStyle ? 1 : 0;
		if (style.borderTop !== false) node.setBorder(src_default.EDGE_TOP, borderWidth);
		if (style.borderBottom !== false) node.setBorder(src_default.EDGE_BOTTOM, borderWidth);
		if (style.borderLeft !== false) node.setBorder(src_default.EDGE_LEFT, borderWidth);
		if (style.borderRight !== false) node.setBorder(src_default.EDGE_RIGHT, borderWidth);
	}
};
const applyGapStyles = (node, style) => {
	if ("gap" in style) node.setGap(src_default.GUTTER_ALL, style.gap ?? 0);
	if ("columnGap" in style) node.setGap(src_default.GUTTER_COLUMN, style.columnGap ?? 0);
	if ("rowGap" in style) node.setGap(src_default.GUTTER_ROW, style.rowGap ?? 0);
};
const styles$2 = (node, style = {}) => {
	applyPositionStyles(node, style);
	applyMarginStyles(node, style);
	applyPaddingStyles(node, style);
	applyFlexStyles(node, style);
	applyDimensionStyles(node, style);
	applyDisplayStyles(node, style);
	applyBorderStyles(node, style);
	applyGapStyles(node, style);
};
var styles_default = styles$2;

//#endregion
//#region node_modules/ws/lib/constants.js
var require_constants = /* @__PURE__ */ __commonJS({ "node_modules/ws/lib/constants.js": ((exports, module) => {
	const BINARY_TYPES$2 = [
		"nodebuffer",
		"arraybuffer",
		"fragments"
	];
	const hasBlob$1 = typeof Blob !== "undefined";
	if (hasBlob$1) BINARY_TYPES$2.push("blob");
	module.exports = {
		BINARY_TYPES: BINARY_TYPES$2,
		EMPTY_BUFFER: Buffer.alloc(0),
		GUID: "258EAFA5-E914-47DA-95CA-C5AB0DC85B11",
		hasBlob: hasBlob$1,
		kForOnEventAttribute: Symbol("kIsForOnEventAttribute"),
		kListener: Symbol("kListener"),
		kStatusCode: Symbol("status-code"),
		kWebSocket: Symbol("websocket"),
		NOOP: () => {}
	};
}) });

//#endregion
//#region node_modules/ws/lib/buffer-util.js
var require_buffer_util = /* @__PURE__ */ __commonJS({ "node_modules/ws/lib/buffer-util.js": ((exports, module) => {
	const { EMPTY_BUFFER: EMPTY_BUFFER$3 } = require_constants();
	const FastBuffer$2 = Buffer[Symbol.species];
	/**
	* Merges an array of buffers into a new buffer.
	*
	* @param {Buffer[]} list The array of buffers to concat
	* @param {Number} totalLength The total length of buffers in the list
	* @return {Buffer} The resulting buffer
	* @public
	*/
	function concat$1(list, totalLength) {
		if (list.length === 0) return EMPTY_BUFFER$3;
		if (list.length === 1) return list[0];
		const target = Buffer.allocUnsafe(totalLength);
		let offset = 0;
		for (let i = 0; i < list.length; i++) {
			const buf = list[i];
			target.set(buf, offset);
			offset += buf.length;
		}
		if (offset < totalLength) return new FastBuffer$2(target.buffer, target.byteOffset, offset);
		return target;
	}
	/**
	* Masks a buffer using the given mask.
	*
	* @param {Buffer} source The buffer to mask
	* @param {Buffer} mask The mask to use
	* @param {Buffer} output The buffer where to store the result
	* @param {Number} offset The offset at which to start writing
	* @param {Number} length The number of bytes to mask.
	* @public
	*/
	function _mask(source, mask, output, offset, length) {
		for (let i = 0; i < length; i++) output[offset + i] = source[i] ^ mask[i & 3];
	}
	/**
	* Unmasks a buffer using the given mask.
	*
	* @param {Buffer} buffer The buffer to unmask
	* @param {Buffer} mask The mask to use
	* @public
	*/
	function _unmask(buffer, mask) {
		for (let i = 0; i < buffer.length; i++) buffer[i] ^= mask[i & 3];
	}
	/**
	* Converts a buffer to an `ArrayBuffer`.
	*
	* @param {Buffer} buf The buffer to convert
	* @return {ArrayBuffer} Converted buffer
	* @public
	*/
	function toArrayBuffer$1(buf) {
		if (buf.length === buf.buffer.byteLength) return buf.buffer;
		return buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.length);
	}
	/**
	* Converts `data` to a `Buffer`.
	*
	* @param {*} data The data to convert
	* @return {Buffer} The buffer
	* @throws {TypeError}
	* @public
	*/
	function toBuffer$2(data) {
		toBuffer$2.readOnly = true;
		if (Buffer.isBuffer(data)) return data;
		let buf;
		if (data instanceof ArrayBuffer) buf = new FastBuffer$2(data);
		else if (ArrayBuffer.isView(data)) buf = new FastBuffer$2(data.buffer, data.byteOffset, data.byteLength);
		else {
			buf = Buffer.from(data);
			toBuffer$2.readOnly = false;
		}
		return buf;
	}
	module.exports = {
		concat: concat$1,
		mask: _mask,
		toArrayBuffer: toArrayBuffer$1,
		toBuffer: toBuffer$2,
		unmask: _unmask
	};
	/* istanbul ignore else  */
	if (!process.env.WS_NO_BUFFER_UTIL) try {
		const bufferUtil$1 = __require("bufferutil");
		module.exports.mask = function(source, mask, output, offset, length) {
			if (length < 48) _mask(source, mask, output, offset, length);
			else bufferUtil$1.mask(source, mask, output, offset, length);
		};
		module.exports.unmask = function(buffer, mask) {
			if (buffer.length < 32) _unmask(buffer, mask);
			else bufferUtil$1.unmask(buffer, mask);
		};
	} catch (e) {}
}) });

//#endregion
//#region node_modules/ws/lib/limiter.js
var require_limiter = /* @__PURE__ */ __commonJS({ "node_modules/ws/lib/limiter.js": ((exports, module) => {
	const kDone = Symbol("kDone");
	const kRun = Symbol("kRun");
	/**
	* A very simple job queue with adjustable concurrency. Adapted from
	* https://github.com/STRML/async-limiter
	*/
	var Limiter$1 = class {
		/**
		* Creates a new `Limiter`.
		*
		* @param {Number} [concurrency=Infinity] The maximum number of jobs allowed
		*     to run concurrently
		*/
		constructor(concurrency) {
			this[kDone] = () => {
				this.pending--;
				this[kRun]();
			};
			this.concurrency = concurrency || Infinity;
			this.jobs = [];
			this.pending = 0;
		}
		/**
		* Adds a job to the queue.
		*
		* @param {Function} job The job to run
		* @public
		*/
		add(job) {
			this.jobs.push(job);
			this[kRun]();
		}
		/**
		* Removes a job from the queue and runs it if possible.
		*
		* @private
		*/
		[kRun]() {
			if (this.pending === this.concurrency) return;
			if (this.jobs.length) {
				const job = this.jobs.shift();
				this.pending++;
				job(this[kDone]);
			}
		}
	};
	module.exports = Limiter$1;
}) });

//#endregion
//#region node_modules/ws/lib/permessage-deflate.js
var require_permessage_deflate = /* @__PURE__ */ __commonJS({ "node_modules/ws/lib/permessage-deflate.js": ((exports, module) => {
	const zlib = __require("zlib");
	const bufferUtil = require_buffer_util();
	const Limiter = require_limiter();
	const { kStatusCode: kStatusCode$2 } = require_constants();
	const FastBuffer$1 = Buffer[Symbol.species];
	const TRAILER = Buffer.from([
		0,
		0,
		255,
		255
	]);
	const kPerMessageDeflate = Symbol("permessage-deflate");
	const kTotalLength = Symbol("total-length");
	const kCallback = Symbol("callback");
	const kBuffers = Symbol("buffers");
	const kError$1 = Symbol("error");
	let zlibLimiter;
	/**
	* permessage-deflate implementation.
	*/
	var PerMessageDeflate$4 = class {
		/**
		* Creates a PerMessageDeflate instance.
		*
		* @param {Object} [options] Configuration options
		* @param {(Boolean|Number)} [options.clientMaxWindowBits] Advertise support
		*     for, or request, a custom client window size
		* @param {Boolean} [options.clientNoContextTakeover=false] Advertise/
		*     acknowledge disabling of client context takeover
		* @param {Number} [options.concurrencyLimit=10] The number of concurrent
		*     calls to zlib
		* @param {(Boolean|Number)} [options.serverMaxWindowBits] Request/confirm the
		*     use of a custom server window size
		* @param {Boolean} [options.serverNoContextTakeover=false] Request/accept
		*     disabling of server context takeover
		* @param {Number} [options.threshold=1024] Size (in bytes) below which
		*     messages should not be compressed if context takeover is disabled
		* @param {Object} [options.zlibDeflateOptions] Options to pass to zlib on
		*     deflate
		* @param {Object} [options.zlibInflateOptions] Options to pass to zlib on
		*     inflate
		* @param {Boolean} [isServer=false] Create the instance in either server or
		*     client mode
		* @param {Number} [maxPayload=0] The maximum allowed message length
		*/
		constructor(options, isServer, maxPayload) {
			this._maxPayload = maxPayload | 0;
			this._options = options || {};
			this._threshold = this._options.threshold !== void 0 ? this._options.threshold : 1024;
			this._isServer = !!isServer;
			this._deflate = null;
			this._inflate = null;
			this.params = null;
			if (!zlibLimiter) zlibLimiter = new Limiter(this._options.concurrencyLimit !== void 0 ? this._options.concurrencyLimit : 10);
		}
		/**
		* @type {String}
		*/
		static get extensionName() {
			return "permessage-deflate";
		}
		/**
		* Create an extension negotiation offer.
		*
		* @return {Object} Extension parameters
		* @public
		*/
		offer() {
			const params = {};
			if (this._options.serverNoContextTakeover) params.server_no_context_takeover = true;
			if (this._options.clientNoContextTakeover) params.client_no_context_takeover = true;
			if (this._options.serverMaxWindowBits) params.server_max_window_bits = this._options.serverMaxWindowBits;
			if (this._options.clientMaxWindowBits) params.client_max_window_bits = this._options.clientMaxWindowBits;
			else if (this._options.clientMaxWindowBits == null) params.client_max_window_bits = true;
			return params;
		}
		/**
		* Accept an extension negotiation offer/response.
		*
		* @param {Array} configurations The extension negotiation offers/reponse
		* @return {Object} Accepted configuration
		* @public
		*/
		accept(configurations) {
			configurations = this.normalizeParams(configurations);
			this.params = this._isServer ? this.acceptAsServer(configurations) : this.acceptAsClient(configurations);
			return this.params;
		}
		/**
		* Releases all resources used by the extension.
		*
		* @public
		*/
		cleanup() {
			if (this._inflate) {
				this._inflate.close();
				this._inflate = null;
			}
			if (this._deflate) {
				const callback = this._deflate[kCallback];
				this._deflate.close();
				this._deflate = null;
				if (callback) callback(/* @__PURE__ */ new Error("The deflate stream was closed while data was being processed"));
			}
		}
		/**
		*  Accept an extension negotiation offer.
		*
		* @param {Array} offers The extension negotiation offers
		* @return {Object} Accepted configuration
		* @private
		*/
		acceptAsServer(offers) {
			const opts = this._options;
			const accepted = offers.find((params) => {
				if (opts.serverNoContextTakeover === false && params.server_no_context_takeover || params.server_max_window_bits && (opts.serverMaxWindowBits === false || typeof opts.serverMaxWindowBits === "number" && opts.serverMaxWindowBits > params.server_max_window_bits) || typeof opts.clientMaxWindowBits === "number" && !params.client_max_window_bits) return false;
				return true;
			});
			if (!accepted) throw new Error("None of the extension offers can be accepted");
			if (opts.serverNoContextTakeover) accepted.server_no_context_takeover = true;
			if (opts.clientNoContextTakeover) accepted.client_no_context_takeover = true;
			if (typeof opts.serverMaxWindowBits === "number") accepted.server_max_window_bits = opts.serverMaxWindowBits;
			if (typeof opts.clientMaxWindowBits === "number") accepted.client_max_window_bits = opts.clientMaxWindowBits;
			else if (accepted.client_max_window_bits === true || opts.clientMaxWindowBits === false) delete accepted.client_max_window_bits;
			return accepted;
		}
		/**
		* Accept the extension negotiation response.
		*
		* @param {Array} response The extension negotiation response
		* @return {Object} Accepted configuration
		* @private
		*/
		acceptAsClient(response) {
			const params = response[0];
			if (this._options.clientNoContextTakeover === false && params.client_no_context_takeover) throw new Error("Unexpected parameter \"client_no_context_takeover\"");
			if (!params.client_max_window_bits) {
				if (typeof this._options.clientMaxWindowBits === "number") params.client_max_window_bits = this._options.clientMaxWindowBits;
			} else if (this._options.clientMaxWindowBits === false || typeof this._options.clientMaxWindowBits === "number" && params.client_max_window_bits > this._options.clientMaxWindowBits) throw new Error("Unexpected or invalid parameter \"client_max_window_bits\"");
			return params;
		}
		/**
		* Normalize parameters.
		*
		* @param {Array} configurations The extension negotiation offers/reponse
		* @return {Array} The offers/response with normalized parameters
		* @private
		*/
		normalizeParams(configurations) {
			configurations.forEach((params) => {
				Object.keys(params).forEach((key) => {
					let value = params[key];
					if (value.length > 1) throw new Error(`Parameter "${key}" must have only a single value`);
					value = value[0];
					if (key === "client_max_window_bits") {
						if (value !== true) {
							const num = +value;
							if (!Number.isInteger(num) || num < 8 || num > 15) throw new TypeError(`Invalid value for parameter "${key}": ${value}`);
							value = num;
						} else if (!this._isServer) throw new TypeError(`Invalid value for parameter "${key}": ${value}`);
					} else if (key === "server_max_window_bits") {
						const num = +value;
						if (!Number.isInteger(num) || num < 8 || num > 15) throw new TypeError(`Invalid value for parameter "${key}": ${value}`);
						value = num;
					} else if (key === "client_no_context_takeover" || key === "server_no_context_takeover") {
						if (value !== true) throw new TypeError(`Invalid value for parameter "${key}": ${value}`);
					} else throw new Error(`Unknown parameter "${key}"`);
					params[key] = value;
				});
			});
			return configurations;
		}
		/**
		* Decompress data. Concurrency limited.
		*
		* @param {Buffer} data Compressed data
		* @param {Boolean} fin Specifies whether or not this is the last fragment
		* @param {Function} callback Callback
		* @public
		*/
		decompress(data, fin, callback) {
			zlibLimiter.add((done) => {
				this._decompress(data, fin, (err, result) => {
					done();
					callback(err, result);
				});
			});
		}
		/**
		* Compress data. Concurrency limited.
		*
		* @param {(Buffer|String)} data Data to compress
		* @param {Boolean} fin Specifies whether or not this is the last fragment
		* @param {Function} callback Callback
		* @public
		*/
		compress(data, fin, callback) {
			zlibLimiter.add((done) => {
				this._compress(data, fin, (err, result) => {
					done();
					callback(err, result);
				});
			});
		}
		/**
		* Decompress data.
		*
		* @param {Buffer} data Compressed data
		* @param {Boolean} fin Specifies whether or not this is the last fragment
		* @param {Function} callback Callback
		* @private
		*/
		_decompress(data, fin, callback) {
			const endpoint = this._isServer ? "client" : "server";
			if (!this._inflate) {
				const key = `${endpoint}_max_window_bits`;
				const windowBits = typeof this.params[key] !== "number" ? zlib.Z_DEFAULT_WINDOWBITS : this.params[key];
				this._inflate = zlib.createInflateRaw({
					...this._options.zlibInflateOptions,
					windowBits
				});
				this._inflate[kPerMessageDeflate] = this;
				this._inflate[kTotalLength] = 0;
				this._inflate[kBuffers] = [];
				this._inflate.on("error", inflateOnError);
				this._inflate.on("data", inflateOnData);
			}
			this._inflate[kCallback] = callback;
			this._inflate.write(data);
			if (fin) this._inflate.write(TRAILER);
			this._inflate.flush(() => {
				const err = this._inflate[kError$1];
				if (err) {
					this._inflate.close();
					this._inflate = null;
					callback(err);
					return;
				}
				const data$1 = bufferUtil.concat(this._inflate[kBuffers], this._inflate[kTotalLength]);
				if (this._inflate._readableState.endEmitted) {
					this._inflate.close();
					this._inflate = null;
				} else {
					this._inflate[kTotalLength] = 0;
					this._inflate[kBuffers] = [];
					if (fin && this.params[`${endpoint}_no_context_takeover`]) this._inflate.reset();
				}
				callback(null, data$1);
			});
		}
		/**
		* Compress data.
		*
		* @param {(Buffer|String)} data Data to compress
		* @param {Boolean} fin Specifies whether or not this is the last fragment
		* @param {Function} callback Callback
		* @private
		*/
		_compress(data, fin, callback) {
			const endpoint = this._isServer ? "server" : "client";
			if (!this._deflate) {
				const key = `${endpoint}_max_window_bits`;
				const windowBits = typeof this.params[key] !== "number" ? zlib.Z_DEFAULT_WINDOWBITS : this.params[key];
				this._deflate = zlib.createDeflateRaw({
					...this._options.zlibDeflateOptions,
					windowBits
				});
				this._deflate[kTotalLength] = 0;
				this._deflate[kBuffers] = [];
				this._deflate.on("data", deflateOnData);
			}
			this._deflate[kCallback] = callback;
			this._deflate.write(data);
			this._deflate.flush(zlib.Z_SYNC_FLUSH, () => {
				if (!this._deflate) return;
				let data$1 = bufferUtil.concat(this._deflate[kBuffers], this._deflate[kTotalLength]);
				if (fin) data$1 = new FastBuffer$1(data$1.buffer, data$1.byteOffset, data$1.length - 4);
				this._deflate[kCallback] = null;
				this._deflate[kTotalLength] = 0;
				this._deflate[kBuffers] = [];
				if (fin && this.params[`${endpoint}_no_context_takeover`]) this._deflate.reset();
				callback(null, data$1);
			});
		}
	};
	module.exports = PerMessageDeflate$4;
	/**
	* The listener of the `zlib.DeflateRaw` stream `'data'` event.
	*
	* @param {Buffer} chunk A chunk of data
	* @private
	*/
	function deflateOnData(chunk) {
		this[kBuffers].push(chunk);
		this[kTotalLength] += chunk.length;
	}
	/**
	* The listener of the `zlib.InflateRaw` stream `'data'` event.
	*
	* @param {Buffer} chunk A chunk of data
	* @private
	*/
	function inflateOnData(chunk) {
		this[kTotalLength] += chunk.length;
		if (this[kPerMessageDeflate]._maxPayload < 1 || this[kTotalLength] <= this[kPerMessageDeflate]._maxPayload) {
			this[kBuffers].push(chunk);
			return;
		}
		this[kError$1] = /* @__PURE__ */ new RangeError("Max payload size exceeded");
		this[kError$1].code = "WS_ERR_UNSUPPORTED_MESSAGE_LENGTH";
		this[kError$1][kStatusCode$2] = 1009;
		this.removeListener("data", inflateOnData);
		this.reset();
	}
	/**
	* The listener of the `zlib.InflateRaw` stream `'error'` event.
	*
	* @param {Error} err The emitted error
	* @private
	*/
	function inflateOnError(err) {
		this[kPerMessageDeflate]._inflate = null;
		if (this[kError$1]) {
			this[kCallback](this[kError$1]);
			return;
		}
		err[kStatusCode$2] = 1007;
		this[kCallback](err);
	}
}) });

//#endregion
//#region node_modules/ws/lib/validation.js
var require_validation = /* @__PURE__ */ __commonJS({ "node_modules/ws/lib/validation.js": ((exports, module) => {
	const { isUtf8 } = __require("buffer");
	const { hasBlob } = require_constants();
	const tokenChars$2 = [
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		1,
		0,
		1,
		1,
		1,
		1,
		1,
		0,
		0,
		1,
		1,
		0,
		1,
		1,
		0,
		1,
		1,
		1,
		1,
		1,
		1,
		1,
		1,
		1,
		1,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		1,
		1,
		1,
		1,
		1,
		1,
		1,
		1,
		1,
		1,
		1,
		1,
		1,
		1,
		1,
		1,
		1,
		1,
		1,
		1,
		1,
		1,
		1,
		1,
		1,
		1,
		0,
		0,
		0,
		1,
		1,
		1,
		1,
		1,
		1,
		1,
		1,
		1,
		1,
		1,
		1,
		1,
		1,
		1,
		1,
		1,
		1,
		1,
		1,
		1,
		1,
		1,
		1,
		1,
		1,
		1,
		1,
		1,
		0,
		1,
		0,
		1,
		0
	];
	/**
	* Checks if a status code is allowed in a close frame.
	*
	* @param {Number} code The status code
	* @return {Boolean} `true` if the status code is valid, else `false`
	* @public
	*/
	function isValidStatusCode$2(code) {
		return code >= 1e3 && code <= 1014 && code !== 1004 && code !== 1005 && code !== 1006 || code >= 3e3 && code <= 4999;
	}
	/**
	* Checks if a given buffer contains only correct UTF-8.
	* Ported from https://www.cl.cam.ac.uk/%7Emgk25/ucs/utf8_check.c by
	* Markus Kuhn.
	*
	* @param {Buffer} buf The buffer to check
	* @return {Boolean} `true` if `buf` contains only correct UTF-8, else `false`
	* @public
	*/
	function _isValidUTF8(buf) {
		const len = buf.length;
		let i = 0;
		while (i < len) if ((buf[i] & 128) === 0) i++;
		else if ((buf[i] & 224) === 192) {
			if (i + 1 === len || (buf[i + 1] & 192) !== 128 || (buf[i] & 254) === 192) return false;
			i += 2;
		} else if ((buf[i] & 240) === 224) {
			if (i + 2 >= len || (buf[i + 1] & 192) !== 128 || (buf[i + 2] & 192) !== 128 || buf[i] === 224 && (buf[i + 1] & 224) === 128 || buf[i] === 237 && (buf[i + 1] & 224) === 160) return false;
			i += 3;
		} else if ((buf[i] & 248) === 240) {
			if (i + 3 >= len || (buf[i + 1] & 192) !== 128 || (buf[i + 2] & 192) !== 128 || (buf[i + 3] & 192) !== 128 || buf[i] === 240 && (buf[i + 1] & 240) === 128 || buf[i] === 244 && buf[i + 1] > 143 || buf[i] > 244) return false;
			i += 4;
		} else return false;
		return true;
	}
	/**
	* Determines whether a value is a `Blob`.
	*
	* @param {*} value The value to be tested
	* @return {Boolean} `true` if `value` is a `Blob`, else `false`
	* @private
	*/
	function isBlob$2(value) {
		return hasBlob && typeof value === "object" && typeof value.arrayBuffer === "function" && typeof value.type === "string" && typeof value.stream === "function" && (value[Symbol.toStringTag] === "Blob" || value[Symbol.toStringTag] === "File");
	}
	module.exports = {
		isBlob: isBlob$2,
		isValidStatusCode: isValidStatusCode$2,
		isValidUTF8: _isValidUTF8,
		tokenChars: tokenChars$2
	};
	if (isUtf8) module.exports.isValidUTF8 = function(buf) {
		return buf.length < 24 ? _isValidUTF8(buf) : isUtf8(buf);
	};
	else if (!process.env.WS_NO_UTF_8_VALIDATE) try {
		const isValidUTF8$1 = __require("utf-8-validate");
		module.exports.isValidUTF8 = function(buf) {
			return buf.length < 32 ? _isValidUTF8(buf) : isValidUTF8$1(buf);
		};
	} catch (e) {}
}) });

//#endregion
//#region node_modules/ws/lib/receiver.js
var require_receiver = /* @__PURE__ */ __commonJS({ "node_modules/ws/lib/receiver.js": ((exports, module) => {
	const { Writable } = __require("stream");
	const PerMessageDeflate$3 = require_permessage_deflate();
	const { BINARY_TYPES: BINARY_TYPES$1, EMPTY_BUFFER: EMPTY_BUFFER$2, kStatusCode: kStatusCode$1, kWebSocket: kWebSocket$3 } = require_constants();
	const { concat, toArrayBuffer, unmask } = require_buffer_util();
	const { isValidStatusCode: isValidStatusCode$1, isValidUTF8 } = require_validation();
	const FastBuffer = Buffer[Symbol.species];
	const GET_INFO = 0;
	const GET_PAYLOAD_LENGTH_16 = 1;
	const GET_PAYLOAD_LENGTH_64 = 2;
	const GET_MASK = 3;
	const GET_DATA = 4;
	const INFLATING = 5;
	const DEFER_EVENT = 6;
	/**
	* HyBi Receiver implementation.
	*
	* @extends Writable
	*/
	var Receiver$2 = class extends Writable {
		/**
		* Creates a Receiver instance.
		*
		* @param {Object} [options] Options object
		* @param {Boolean} [options.allowSynchronousEvents=true] Specifies whether
		*     any of the `'message'`, `'ping'`, and `'pong'` events can be emitted
		*     multiple times in the same tick
		* @param {String} [options.binaryType=nodebuffer] The type for binary data
		* @param {Object} [options.extensions] An object containing the negotiated
		*     extensions
		* @param {Boolean} [options.isServer=false] Specifies whether to operate in
		*     client or server mode
		* @param {Number} [options.maxPayload=0] The maximum allowed message length
		* @param {Boolean} [options.skipUTF8Validation=false] Specifies whether or
		*     not to skip UTF-8 validation for text and close messages
		*/
		constructor(options = {}) {
			super();
			this._allowSynchronousEvents = options.allowSynchronousEvents !== void 0 ? options.allowSynchronousEvents : true;
			this._binaryType = options.binaryType || BINARY_TYPES$1[0];
			this._extensions = options.extensions || {};
			this._isServer = !!options.isServer;
			this._maxPayload = options.maxPayload | 0;
			this._skipUTF8Validation = !!options.skipUTF8Validation;
			this[kWebSocket$3] = void 0;
			this._bufferedBytes = 0;
			this._buffers = [];
			this._compressed = false;
			this._payloadLength = 0;
			this._mask = void 0;
			this._fragmented = 0;
			this._masked = false;
			this._fin = false;
			this._opcode = 0;
			this._totalPayloadLength = 0;
			this._messageLength = 0;
			this._fragments = [];
			this._errored = false;
			this._loop = false;
			this._state = GET_INFO;
		}
		/**
		* Implements `Writable.prototype._write()`.
		*
		* @param {Buffer} chunk The chunk of data to write
		* @param {String} encoding The character encoding of `chunk`
		* @param {Function} cb Callback
		* @private
		*/
		_write(chunk, encoding, cb) {
			if (this._opcode === 8 && this._state == GET_INFO) return cb();
			this._bufferedBytes += chunk.length;
			this._buffers.push(chunk);
			this.startLoop(cb);
		}
		/**
		* Consumes `n` bytes from the buffered data.
		*
		* @param {Number} n The number of bytes to consume
		* @return {Buffer} The consumed bytes
		* @private
		*/
		consume(n) {
			this._bufferedBytes -= n;
			if (n === this._buffers[0].length) return this._buffers.shift();
			if (n < this._buffers[0].length) {
				const buf = this._buffers[0];
				this._buffers[0] = new FastBuffer(buf.buffer, buf.byteOffset + n, buf.length - n);
				return new FastBuffer(buf.buffer, buf.byteOffset, n);
			}
			const dst = Buffer.allocUnsafe(n);
			do {
				const buf = this._buffers[0];
				const offset = dst.length - n;
				if (n >= buf.length) dst.set(this._buffers.shift(), offset);
				else {
					dst.set(new Uint8Array(buf.buffer, buf.byteOffset, n), offset);
					this._buffers[0] = new FastBuffer(buf.buffer, buf.byteOffset + n, buf.length - n);
				}
				n -= buf.length;
			} while (n > 0);
			return dst;
		}
		/**
		* Starts the parsing loop.
		*
		* @param {Function} cb Callback
		* @private
		*/
		startLoop(cb) {
			this._loop = true;
			do
				switch (this._state) {
					case GET_INFO:
						this.getInfo(cb);
						break;
					case GET_PAYLOAD_LENGTH_16:
						this.getPayloadLength16(cb);
						break;
					case GET_PAYLOAD_LENGTH_64:
						this.getPayloadLength64(cb);
						break;
					case GET_MASK:
						this.getMask();
						break;
					case GET_DATA:
						this.getData(cb);
						break;
					case INFLATING:
					case DEFER_EVENT:
						this._loop = false;
						return;
				}
			while (this._loop);
			if (!this._errored) cb();
		}
		/**
		* Reads the first two bytes of a frame.
		*
		* @param {Function} cb Callback
		* @private
		*/
		getInfo(cb) {
			if (this._bufferedBytes < 2) {
				this._loop = false;
				return;
			}
			const buf = this.consume(2);
			if ((buf[0] & 48) !== 0) {
				cb(this.createError(RangeError, "RSV2 and RSV3 must be clear", true, 1002, "WS_ERR_UNEXPECTED_RSV_2_3"));
				return;
			}
			const compressed = (buf[0] & 64) === 64;
			if (compressed && !this._extensions[PerMessageDeflate$3.extensionName]) {
				cb(this.createError(RangeError, "RSV1 must be clear", true, 1002, "WS_ERR_UNEXPECTED_RSV_1"));
				return;
			}
			this._fin = (buf[0] & 128) === 128;
			this._opcode = buf[0] & 15;
			this._payloadLength = buf[1] & 127;
			if (this._opcode === 0) {
				if (compressed) {
					cb(this.createError(RangeError, "RSV1 must be clear", true, 1002, "WS_ERR_UNEXPECTED_RSV_1"));
					return;
				}
				if (!this._fragmented) {
					cb(this.createError(RangeError, "invalid opcode 0", true, 1002, "WS_ERR_INVALID_OPCODE"));
					return;
				}
				this._opcode = this._fragmented;
			} else if (this._opcode === 1 || this._opcode === 2) {
				if (this._fragmented) {
					cb(this.createError(RangeError, `invalid opcode ${this._opcode}`, true, 1002, "WS_ERR_INVALID_OPCODE"));
					return;
				}
				this._compressed = compressed;
			} else if (this._opcode > 7 && this._opcode < 11) {
				if (!this._fin) {
					cb(this.createError(RangeError, "FIN must be set", true, 1002, "WS_ERR_EXPECTED_FIN"));
					return;
				}
				if (compressed) {
					cb(this.createError(RangeError, "RSV1 must be clear", true, 1002, "WS_ERR_UNEXPECTED_RSV_1"));
					return;
				}
				if (this._payloadLength > 125 || this._opcode === 8 && this._payloadLength === 1) {
					cb(this.createError(RangeError, `invalid payload length ${this._payloadLength}`, true, 1002, "WS_ERR_INVALID_CONTROL_PAYLOAD_LENGTH"));
					return;
				}
			} else {
				cb(this.createError(RangeError, `invalid opcode ${this._opcode}`, true, 1002, "WS_ERR_INVALID_OPCODE"));
				return;
			}
			if (!this._fin && !this._fragmented) this._fragmented = this._opcode;
			this._masked = (buf[1] & 128) === 128;
			if (this._isServer) {
				if (!this._masked) {
					cb(this.createError(RangeError, "MASK must be set", true, 1002, "WS_ERR_EXPECTED_MASK"));
					return;
				}
			} else if (this._masked) {
				cb(this.createError(RangeError, "MASK must be clear", true, 1002, "WS_ERR_UNEXPECTED_MASK"));
				return;
			}
			if (this._payloadLength === 126) this._state = GET_PAYLOAD_LENGTH_16;
			else if (this._payloadLength === 127) this._state = GET_PAYLOAD_LENGTH_64;
			else this.haveLength(cb);
		}
		/**
		* Gets extended payload length (7+16).
		*
		* @param {Function} cb Callback
		* @private
		*/
		getPayloadLength16(cb) {
			if (this._bufferedBytes < 2) {
				this._loop = false;
				return;
			}
			this._payloadLength = this.consume(2).readUInt16BE(0);
			this.haveLength(cb);
		}
		/**
		* Gets extended payload length (7+64).
		*
		* @param {Function} cb Callback
		* @private
		*/
		getPayloadLength64(cb) {
			if (this._bufferedBytes < 8) {
				this._loop = false;
				return;
			}
			const buf = this.consume(8);
			const num = buf.readUInt32BE(0);
			if (num > Math.pow(2, 21) - 1) {
				cb(this.createError(RangeError, "Unsupported WebSocket frame: payload length > 2^53 - 1", false, 1009, "WS_ERR_UNSUPPORTED_DATA_PAYLOAD_LENGTH"));
				return;
			}
			this._payloadLength = num * Math.pow(2, 32) + buf.readUInt32BE(4);
			this.haveLength(cb);
		}
		/**
		* Payload length has been read.
		*
		* @param {Function} cb Callback
		* @private
		*/
		haveLength(cb) {
			if (this._payloadLength && this._opcode < 8) {
				this._totalPayloadLength += this._payloadLength;
				if (this._totalPayloadLength > this._maxPayload && this._maxPayload > 0) {
					cb(this.createError(RangeError, "Max payload size exceeded", false, 1009, "WS_ERR_UNSUPPORTED_MESSAGE_LENGTH"));
					return;
				}
			}
			if (this._masked) this._state = GET_MASK;
			else this._state = GET_DATA;
		}
		/**
		* Reads mask bytes.
		*
		* @private
		*/
		getMask() {
			if (this._bufferedBytes < 4) {
				this._loop = false;
				return;
			}
			this._mask = this.consume(4);
			this._state = GET_DATA;
		}
		/**
		* Reads data bytes.
		*
		* @param {Function} cb Callback
		* @private
		*/
		getData(cb) {
			let data = EMPTY_BUFFER$2;
			if (this._payloadLength) {
				if (this._bufferedBytes < this._payloadLength) {
					this._loop = false;
					return;
				}
				data = this.consume(this._payloadLength);
				if (this._masked && (this._mask[0] | this._mask[1] | this._mask[2] | this._mask[3]) !== 0) unmask(data, this._mask);
			}
			if (this._opcode > 7) {
				this.controlMessage(data, cb);
				return;
			}
			if (this._compressed) {
				this._state = INFLATING;
				this.decompress(data, cb);
				return;
			}
			if (data.length) {
				this._messageLength = this._totalPayloadLength;
				this._fragments.push(data);
			}
			this.dataMessage(cb);
		}
		/**
		* Decompresses data.
		*
		* @param {Buffer} data Compressed data
		* @param {Function} cb Callback
		* @private
		*/
		decompress(data, cb) {
			this._extensions[PerMessageDeflate$3.extensionName].decompress(data, this._fin, (err, buf) => {
				if (err) return cb(err);
				if (buf.length) {
					this._messageLength += buf.length;
					if (this._messageLength > this._maxPayload && this._maxPayload > 0) {
						cb(this.createError(RangeError, "Max payload size exceeded", false, 1009, "WS_ERR_UNSUPPORTED_MESSAGE_LENGTH"));
						return;
					}
					this._fragments.push(buf);
				}
				this.dataMessage(cb);
				if (this._state === GET_INFO) this.startLoop(cb);
			});
		}
		/**
		* Handles a data message.
		*
		* @param {Function} cb Callback
		* @private
		*/
		dataMessage(cb) {
			if (!this._fin) {
				this._state = GET_INFO;
				return;
			}
			const messageLength = this._messageLength;
			const fragments = this._fragments;
			this._totalPayloadLength = 0;
			this._messageLength = 0;
			this._fragmented = 0;
			this._fragments = [];
			if (this._opcode === 2) {
				let data;
				if (this._binaryType === "nodebuffer") data = concat(fragments, messageLength);
				else if (this._binaryType === "arraybuffer") data = toArrayBuffer(concat(fragments, messageLength));
				else if (this._binaryType === "blob") data = new Blob(fragments);
				else data = fragments;
				if (this._allowSynchronousEvents) {
					this.emit("message", data, true);
					this._state = GET_INFO;
				} else {
					this._state = DEFER_EVENT;
					setImmediate(() => {
						this.emit("message", data, true);
						this._state = GET_INFO;
						this.startLoop(cb);
					});
				}
			} else {
				const buf = concat(fragments, messageLength);
				if (!this._skipUTF8Validation && !isValidUTF8(buf)) {
					cb(this.createError(Error, "invalid UTF-8 sequence", true, 1007, "WS_ERR_INVALID_UTF8"));
					return;
				}
				if (this._state === INFLATING || this._allowSynchronousEvents) {
					this.emit("message", buf, false);
					this._state = GET_INFO;
				} else {
					this._state = DEFER_EVENT;
					setImmediate(() => {
						this.emit("message", buf, false);
						this._state = GET_INFO;
						this.startLoop(cb);
					});
				}
			}
		}
		/**
		* Handles a control message.
		*
		* @param {Buffer} data Data to handle
		* @return {(Error|RangeError|undefined)} A possible error
		* @private
		*/
		controlMessage(data, cb) {
			if (this._opcode === 8) {
				if (data.length === 0) {
					this._loop = false;
					this.emit("conclude", 1005, EMPTY_BUFFER$2);
					this.end();
				} else {
					const code = data.readUInt16BE(0);
					if (!isValidStatusCode$1(code)) {
						cb(this.createError(RangeError, `invalid status code ${code}`, true, 1002, "WS_ERR_INVALID_CLOSE_CODE"));
						return;
					}
					const buf = new FastBuffer(data.buffer, data.byteOffset + 2, data.length - 2);
					if (!this._skipUTF8Validation && !isValidUTF8(buf)) {
						cb(this.createError(Error, "invalid UTF-8 sequence", true, 1007, "WS_ERR_INVALID_UTF8"));
						return;
					}
					this._loop = false;
					this.emit("conclude", code, buf);
					this.end();
				}
				this._state = GET_INFO;
				return;
			}
			if (this._allowSynchronousEvents) {
				this.emit(this._opcode === 9 ? "ping" : "pong", data);
				this._state = GET_INFO;
			} else {
				this._state = DEFER_EVENT;
				setImmediate(() => {
					this.emit(this._opcode === 9 ? "ping" : "pong", data);
					this._state = GET_INFO;
					this.startLoop(cb);
				});
			}
		}
		/**
		* Builds an error object.
		*
		* @param {function(new:Error|RangeError)} ErrorCtor The error constructor
		* @param {String} message The error message
		* @param {Boolean} prefix Specifies whether or not to add a default prefix to
		*     `message`
		* @param {Number} statusCode The status code
		* @param {String} errorCode The exposed error code
		* @return {(Error|RangeError)} The error
		* @private
		*/
		createError(ErrorCtor, message, prefix, statusCode, errorCode) {
			this._loop = false;
			this._errored = true;
			const err = new ErrorCtor(prefix ? `Invalid WebSocket frame: ${message}` : message);
			Error.captureStackTrace(err, this.createError);
			err.code = errorCode;
			err[kStatusCode$1] = statusCode;
			return err;
		}
	};
	module.exports = Receiver$2;
}) });

//#endregion
//#region node_modules/ws/lib/sender.js
var require_sender = /* @__PURE__ */ __commonJS({ "node_modules/ws/lib/sender.js": ((exports, module) => {
	const { Duplex: Duplex$3 } = __require("stream");
	const { randomFillSync } = __require("crypto");
	const PerMessageDeflate$2 = require_permessage_deflate();
	const { EMPTY_BUFFER: EMPTY_BUFFER$1, kWebSocket: kWebSocket$2, NOOP: NOOP$1 } = require_constants();
	const { isBlob: isBlob$1, isValidStatusCode } = require_validation();
	const { mask: applyMask, toBuffer: toBuffer$1 } = require_buffer_util();
	const kByteLength = Symbol("kByteLength");
	const maskBuffer = Buffer.alloc(4);
	const RANDOM_POOL_SIZE = 8 * 1024;
	let randomPool;
	let randomPoolPointer = RANDOM_POOL_SIZE;
	const DEFAULT = 0;
	const DEFLATING = 1;
	const GET_BLOB_DATA = 2;
	/**
	* HyBi Sender implementation.
	*/
	var Sender$2 = class Sender$2 {
		/**
		* Creates a Sender instance.
		*
		* @param {Duplex} socket The connection socket
		* @param {Object} [extensions] An object containing the negotiated extensions
		* @param {Function} [generateMask] The function used to generate the masking
		*     key
		*/
		constructor(socket, extensions, generateMask) {
			this._extensions = extensions || {};
			if (generateMask) {
				this._generateMask = generateMask;
				this._maskBuffer = Buffer.alloc(4);
			}
			this._socket = socket;
			this._firstFragment = true;
			this._compress = false;
			this._bufferedBytes = 0;
			this._queue = [];
			this._state = DEFAULT;
			this.onerror = NOOP$1;
			this[kWebSocket$2] = void 0;
		}
		/**
		* Frames a piece of data according to the HyBi WebSocket protocol.
		*
		* @param {(Buffer|String)} data The data to frame
		* @param {Object} options Options object
		* @param {Boolean} [options.fin=false] Specifies whether or not to set the
		*     FIN bit
		* @param {Function} [options.generateMask] The function used to generate the
		*     masking key
		* @param {Boolean} [options.mask=false] Specifies whether or not to mask
		*     `data`
		* @param {Buffer} [options.maskBuffer] The buffer used to store the masking
		*     key
		* @param {Number} options.opcode The opcode
		* @param {Boolean} [options.readOnly=false] Specifies whether `data` can be
		*     modified
		* @param {Boolean} [options.rsv1=false] Specifies whether or not to set the
		*     RSV1 bit
		* @return {(Buffer|String)[]} The framed data
		* @public
		*/
		static frame(data, options) {
			let mask;
			let merge = false;
			let offset = 2;
			let skipMasking = false;
			if (options.mask) {
				mask = options.maskBuffer || maskBuffer;
				if (options.generateMask) options.generateMask(mask);
				else {
					if (randomPoolPointer === RANDOM_POOL_SIZE) {
						/* istanbul ignore else  */
						if (randomPool === void 0) randomPool = Buffer.alloc(RANDOM_POOL_SIZE);
						randomFillSync(randomPool, 0, RANDOM_POOL_SIZE);
						randomPoolPointer = 0;
					}
					mask[0] = randomPool[randomPoolPointer++];
					mask[1] = randomPool[randomPoolPointer++];
					mask[2] = randomPool[randomPoolPointer++];
					mask[3] = randomPool[randomPoolPointer++];
				}
				skipMasking = (mask[0] | mask[1] | mask[2] | mask[3]) === 0;
				offset = 6;
			}
			let dataLength;
			if (typeof data === "string") if ((!options.mask || skipMasking) && options[kByteLength] !== void 0) dataLength = options[kByteLength];
			else {
				data = Buffer.from(data);
				dataLength = data.length;
			}
			else {
				dataLength = data.length;
				merge = options.mask && options.readOnly && !skipMasking;
			}
			let payloadLength = dataLength;
			if (dataLength >= 65536) {
				offset += 8;
				payloadLength = 127;
			} else if (dataLength > 125) {
				offset += 2;
				payloadLength = 126;
			}
			const target = Buffer.allocUnsafe(merge ? dataLength + offset : offset);
			target[0] = options.fin ? options.opcode | 128 : options.opcode;
			if (options.rsv1) target[0] |= 64;
			target[1] = payloadLength;
			if (payloadLength === 126) target.writeUInt16BE(dataLength, 2);
			else if (payloadLength === 127) {
				target[2] = target[3] = 0;
				target.writeUIntBE(dataLength, 4, 6);
			}
			if (!options.mask) return [target, data];
			target[1] |= 128;
			target[offset - 4] = mask[0];
			target[offset - 3] = mask[1];
			target[offset - 2] = mask[2];
			target[offset - 1] = mask[3];
			if (skipMasking) return [target, data];
			if (merge) {
				applyMask(data, mask, target, offset, dataLength);
				return [target];
			}
			applyMask(data, mask, data, 0, dataLength);
			return [target, data];
		}
		/**
		* Sends a close message to the other peer.
		*
		* @param {Number} [code] The status code component of the body
		* @param {(String|Buffer)} [data] The message component of the body
		* @param {Boolean} [mask=false] Specifies whether or not to mask the message
		* @param {Function} [cb] Callback
		* @public
		*/
		close(code, data, mask, cb) {
			let buf;
			if (code === void 0) buf = EMPTY_BUFFER$1;
			else if (typeof code !== "number" || !isValidStatusCode(code)) throw new TypeError("First argument must be a valid error code number");
			else if (data === void 0 || !data.length) {
				buf = Buffer.allocUnsafe(2);
				buf.writeUInt16BE(code, 0);
			} else {
				const length = Buffer.byteLength(data);
				if (length > 123) throw new RangeError("The message must not be greater than 123 bytes");
				buf = Buffer.allocUnsafe(2 + length);
				buf.writeUInt16BE(code, 0);
				if (typeof data === "string") buf.write(data, 2);
				else buf.set(data, 2);
			}
			const options = {
				[kByteLength]: buf.length,
				fin: true,
				generateMask: this._generateMask,
				mask,
				maskBuffer: this._maskBuffer,
				opcode: 8,
				readOnly: false,
				rsv1: false
			};
			if (this._state !== DEFAULT) this.enqueue([
				this.dispatch,
				buf,
				false,
				options,
				cb
			]);
			else this.sendFrame(Sender$2.frame(buf, options), cb);
		}
		/**
		* Sends a ping message to the other peer.
		*
		* @param {*} data The message to send
		* @param {Boolean} [mask=false] Specifies whether or not to mask `data`
		* @param {Function} [cb] Callback
		* @public
		*/
		ping(data, mask, cb) {
			let byteLength;
			let readOnly;
			if (typeof data === "string") {
				byteLength = Buffer.byteLength(data);
				readOnly = false;
			} else if (isBlob$1(data)) {
				byteLength = data.size;
				readOnly = false;
			} else {
				data = toBuffer$1(data);
				byteLength = data.length;
				readOnly = toBuffer$1.readOnly;
			}
			if (byteLength > 125) throw new RangeError("The data size must not be greater than 125 bytes");
			const options = {
				[kByteLength]: byteLength,
				fin: true,
				generateMask: this._generateMask,
				mask,
				maskBuffer: this._maskBuffer,
				opcode: 9,
				readOnly,
				rsv1: false
			};
			if (isBlob$1(data)) if (this._state !== DEFAULT) this.enqueue([
				this.getBlobData,
				data,
				false,
				options,
				cb
			]);
			else this.getBlobData(data, false, options, cb);
			else if (this._state !== DEFAULT) this.enqueue([
				this.dispatch,
				data,
				false,
				options,
				cb
			]);
			else this.sendFrame(Sender$2.frame(data, options), cb);
		}
		/**
		* Sends a pong message to the other peer.
		*
		* @param {*} data The message to send
		* @param {Boolean} [mask=false] Specifies whether or not to mask `data`
		* @param {Function} [cb] Callback
		* @public
		*/
		pong(data, mask, cb) {
			let byteLength;
			let readOnly;
			if (typeof data === "string") {
				byteLength = Buffer.byteLength(data);
				readOnly = false;
			} else if (isBlob$1(data)) {
				byteLength = data.size;
				readOnly = false;
			} else {
				data = toBuffer$1(data);
				byteLength = data.length;
				readOnly = toBuffer$1.readOnly;
			}
			if (byteLength > 125) throw new RangeError("The data size must not be greater than 125 bytes");
			const options = {
				[kByteLength]: byteLength,
				fin: true,
				generateMask: this._generateMask,
				mask,
				maskBuffer: this._maskBuffer,
				opcode: 10,
				readOnly,
				rsv1: false
			};
			if (isBlob$1(data)) if (this._state !== DEFAULT) this.enqueue([
				this.getBlobData,
				data,
				false,
				options,
				cb
			]);
			else this.getBlobData(data, false, options, cb);
			else if (this._state !== DEFAULT) this.enqueue([
				this.dispatch,
				data,
				false,
				options,
				cb
			]);
			else this.sendFrame(Sender$2.frame(data, options), cb);
		}
		/**
		* Sends a data message to the other peer.
		*
		* @param {*} data The message to send
		* @param {Object} options Options object
		* @param {Boolean} [options.binary=false] Specifies whether `data` is binary
		*     or text
		* @param {Boolean} [options.compress=false] Specifies whether or not to
		*     compress `data`
		* @param {Boolean} [options.fin=false] Specifies whether the fragment is the
		*     last one
		* @param {Boolean} [options.mask=false] Specifies whether or not to mask
		*     `data`
		* @param {Function} [cb] Callback
		* @public
		*/
		send(data, options, cb) {
			const perMessageDeflate = this._extensions[PerMessageDeflate$2.extensionName];
			let opcode = options.binary ? 2 : 1;
			let rsv1 = options.compress;
			let byteLength;
			let readOnly;
			if (typeof data === "string") {
				byteLength = Buffer.byteLength(data);
				readOnly = false;
			} else if (isBlob$1(data)) {
				byteLength = data.size;
				readOnly = false;
			} else {
				data = toBuffer$1(data);
				byteLength = data.length;
				readOnly = toBuffer$1.readOnly;
			}
			if (this._firstFragment) {
				this._firstFragment = false;
				if (rsv1 && perMessageDeflate && perMessageDeflate.params[perMessageDeflate._isServer ? "server_no_context_takeover" : "client_no_context_takeover"]) rsv1 = byteLength >= perMessageDeflate._threshold;
				this._compress = rsv1;
			} else {
				rsv1 = false;
				opcode = 0;
			}
			if (options.fin) this._firstFragment = true;
			const opts = {
				[kByteLength]: byteLength,
				fin: options.fin,
				generateMask: this._generateMask,
				mask: options.mask,
				maskBuffer: this._maskBuffer,
				opcode,
				readOnly,
				rsv1
			};
			if (isBlob$1(data)) if (this._state !== DEFAULT) this.enqueue([
				this.getBlobData,
				data,
				this._compress,
				opts,
				cb
			]);
			else this.getBlobData(data, this._compress, opts, cb);
			else if (this._state !== DEFAULT) this.enqueue([
				this.dispatch,
				data,
				this._compress,
				opts,
				cb
			]);
			else this.dispatch(data, this._compress, opts, cb);
		}
		/**
		* Gets the contents of a blob as binary data.
		*
		* @param {Blob} blob The blob
		* @param {Boolean} [compress=false] Specifies whether or not to compress
		*     the data
		* @param {Object} options Options object
		* @param {Boolean} [options.fin=false] Specifies whether or not to set the
		*     FIN bit
		* @param {Function} [options.generateMask] The function used to generate the
		*     masking key
		* @param {Boolean} [options.mask=false] Specifies whether or not to mask
		*     `data`
		* @param {Buffer} [options.maskBuffer] The buffer used to store the masking
		*     key
		* @param {Number} options.opcode The opcode
		* @param {Boolean} [options.readOnly=false] Specifies whether `data` can be
		*     modified
		* @param {Boolean} [options.rsv1=false] Specifies whether or not to set the
		*     RSV1 bit
		* @param {Function} [cb] Callback
		* @private
		*/
		getBlobData(blob, compress, options, cb) {
			this._bufferedBytes += options[kByteLength];
			this._state = GET_BLOB_DATA;
			blob.arrayBuffer().then((arrayBuffer) => {
				if (this._socket.destroyed) {
					const err = /* @__PURE__ */ new Error("The socket was closed while the blob was being read");
					process.nextTick(callCallbacks, this, err, cb);
					return;
				}
				this._bufferedBytes -= options[kByteLength];
				const data = toBuffer$1(arrayBuffer);
				if (!compress) {
					this._state = DEFAULT;
					this.sendFrame(Sender$2.frame(data, options), cb);
					this.dequeue();
				} else this.dispatch(data, compress, options, cb);
			}).catch((err) => {
				process.nextTick(onError, this, err, cb);
			});
		}
		/**
		* Dispatches a message.
		*
		* @param {(Buffer|String)} data The message to send
		* @param {Boolean} [compress=false] Specifies whether or not to compress
		*     `data`
		* @param {Object} options Options object
		* @param {Boolean} [options.fin=false] Specifies whether or not to set the
		*     FIN bit
		* @param {Function} [options.generateMask] The function used to generate the
		*     masking key
		* @param {Boolean} [options.mask=false] Specifies whether or not to mask
		*     `data`
		* @param {Buffer} [options.maskBuffer] The buffer used to store the masking
		*     key
		* @param {Number} options.opcode The opcode
		* @param {Boolean} [options.readOnly=false] Specifies whether `data` can be
		*     modified
		* @param {Boolean} [options.rsv1=false] Specifies whether or not to set the
		*     RSV1 bit
		* @param {Function} [cb] Callback
		* @private
		*/
		dispatch(data, compress, options, cb) {
			if (!compress) {
				this.sendFrame(Sender$2.frame(data, options), cb);
				return;
			}
			const perMessageDeflate = this._extensions[PerMessageDeflate$2.extensionName];
			this._bufferedBytes += options[kByteLength];
			this._state = DEFLATING;
			perMessageDeflate.compress(data, options.fin, (_, buf) => {
				if (this._socket.destroyed) {
					callCallbacks(this, /* @__PURE__ */ new Error("The socket was closed while data was being compressed"), cb);
					return;
				}
				this._bufferedBytes -= options[kByteLength];
				this._state = DEFAULT;
				options.readOnly = false;
				this.sendFrame(Sender$2.frame(buf, options), cb);
				this.dequeue();
			});
		}
		/**
		* Executes queued send operations.
		*
		* @private
		*/
		dequeue() {
			while (this._state === DEFAULT && this._queue.length) {
				const params = this._queue.shift();
				this._bufferedBytes -= params[3][kByteLength];
				Reflect.apply(params[0], this, params.slice(1));
			}
		}
		/**
		* Enqueues a send operation.
		*
		* @param {Array} params Send operation parameters.
		* @private
		*/
		enqueue(params) {
			this._bufferedBytes += params[3][kByteLength];
			this._queue.push(params);
		}
		/**
		* Sends a frame.
		*
		* @param {(Buffer | String)[]} list The frame to send
		* @param {Function} [cb] Callback
		* @private
		*/
		sendFrame(list, cb) {
			if (list.length === 2) {
				this._socket.cork();
				this._socket.write(list[0]);
				this._socket.write(list[1], cb);
				this._socket.uncork();
			} else this._socket.write(list[0], cb);
		}
	};
	module.exports = Sender$2;
	/**
	* Calls queued callbacks with an error.
	*
	* @param {Sender} sender The `Sender` instance
	* @param {Error} err The error to call the callbacks with
	* @param {Function} [cb] The first callback
	* @private
	*/
	function callCallbacks(sender, err, cb) {
		if (typeof cb === "function") cb(err);
		for (let i = 0; i < sender._queue.length; i++) {
			const params = sender._queue[i];
			const callback = params[params.length - 1];
			if (typeof callback === "function") callback(err);
		}
	}
	/**
	* Handles a `Sender` error.
	*
	* @param {Sender} sender The `Sender` instance
	* @param {Error} err The error
	* @param {Function} [cb] The first pending callback
	* @private
	*/
	function onError(sender, err, cb) {
		callCallbacks(sender, err, cb);
		sender.onerror(err);
	}
}) });

//#endregion
//#region node_modules/ws/lib/event-target.js
var require_event_target = /* @__PURE__ */ __commonJS({ "node_modules/ws/lib/event-target.js": ((exports, module) => {
	const { kForOnEventAttribute: kForOnEventAttribute$1, kListener: kListener$1 } = require_constants();
	const kCode = Symbol("kCode");
	const kData = Symbol("kData");
	const kError = Symbol("kError");
	const kMessage = Symbol("kMessage");
	const kReason = Symbol("kReason");
	const kTarget = Symbol("kTarget");
	const kType = Symbol("kType");
	const kWasClean = Symbol("kWasClean");
	/**
	* Class representing an event.
	*/
	var Event = class {
		/**
		* Create a new `Event`.
		*
		* @param {String} type The name of the event
		* @throws {TypeError} If the `type` argument is not specified
		*/
		constructor(type) {
			this[kTarget] = null;
			this[kType] = type;
		}
		/**
		* @type {*}
		*/
		get target() {
			return this[kTarget];
		}
		/**
		* @type {String}
		*/
		get type() {
			return this[kType];
		}
	};
	Object.defineProperty(Event.prototype, "target", { enumerable: true });
	Object.defineProperty(Event.prototype, "type", { enumerable: true });
	/**
	* Class representing a close event.
	*
	* @extends Event
	*/
	var CloseEvent = class extends Event {
		/**
		* Create a new `CloseEvent`.
		*
		* @param {String} type The name of the event
		* @param {Object} [options] A dictionary object that allows for setting
		*     attributes via object members of the same name
		* @param {Number} [options.code=0] The status code explaining why the
		*     connection was closed
		* @param {String} [options.reason=''] A human-readable string explaining why
		*     the connection was closed
		* @param {Boolean} [options.wasClean=false] Indicates whether or not the
		*     connection was cleanly closed
		*/
		constructor(type, options = {}) {
			super(type);
			this[kCode] = options.code === void 0 ? 0 : options.code;
			this[kReason] = options.reason === void 0 ? "" : options.reason;
			this[kWasClean] = options.wasClean === void 0 ? false : options.wasClean;
		}
		/**
		* @type {Number}
		*/
		get code() {
			return this[kCode];
		}
		/**
		* @type {String}
		*/
		get reason() {
			return this[kReason];
		}
		/**
		* @type {Boolean}
		*/
		get wasClean() {
			return this[kWasClean];
		}
	};
	Object.defineProperty(CloseEvent.prototype, "code", { enumerable: true });
	Object.defineProperty(CloseEvent.prototype, "reason", { enumerable: true });
	Object.defineProperty(CloseEvent.prototype, "wasClean", { enumerable: true });
	/**
	* Class representing an error event.
	*
	* @extends Event
	*/
	var ErrorEvent = class extends Event {
		/**
		* Create a new `ErrorEvent`.
		*
		* @param {String} type The name of the event
		* @param {Object} [options] A dictionary object that allows for setting
		*     attributes via object members of the same name
		* @param {*} [options.error=null] The error that generated this event
		* @param {String} [options.message=''] The error message
		*/
		constructor(type, options = {}) {
			super(type);
			this[kError] = options.error === void 0 ? null : options.error;
			this[kMessage] = options.message === void 0 ? "" : options.message;
		}
		/**
		* @type {*}
		*/
		get error() {
			return this[kError];
		}
		/**
		* @type {String}
		*/
		get message() {
			return this[kMessage];
		}
	};
	Object.defineProperty(ErrorEvent.prototype, "error", { enumerable: true });
	Object.defineProperty(ErrorEvent.prototype, "message", { enumerable: true });
	/**
	* Class representing a message event.
	*
	* @extends Event
	*/
	var MessageEvent = class extends Event {
		/**
		* Create a new `MessageEvent`.
		*
		* @param {String} type The name of the event
		* @param {Object} [options] A dictionary object that allows for setting
		*     attributes via object members of the same name
		* @param {*} [options.data=null] The message content
		*/
		constructor(type, options = {}) {
			super(type);
			this[kData] = options.data === void 0 ? null : options.data;
		}
		/**
		* @type {*}
		*/
		get data() {
			return this[kData];
		}
	};
	Object.defineProperty(MessageEvent.prototype, "data", { enumerable: true });
	/**
	* This provides methods for emulating the `EventTarget` interface. It's not
	* meant to be used directly.
	*
	* @mixin
	*/
	const EventTarget = {
		addEventListener(type, handler, options = {}) {
			for (const listener of this.listeners(type)) if (!options[kForOnEventAttribute$1] && listener[kListener$1] === handler && !listener[kForOnEventAttribute$1]) return;
			let wrapper;
			if (type === "message") wrapper = function onMessage(data, isBinary) {
				const event = new MessageEvent("message", { data: isBinary ? data : data.toString() });
				event[kTarget] = this;
				callListener(handler, this, event);
			};
			else if (type === "close") wrapper = function onClose(code, message) {
				const event = new CloseEvent("close", {
					code,
					reason: message.toString(),
					wasClean: this._closeFrameReceived && this._closeFrameSent
				});
				event[kTarget] = this;
				callListener(handler, this, event);
			};
			else if (type === "error") wrapper = function onError$1(error) {
				const event = new ErrorEvent("error", {
					error,
					message: error.message
				});
				event[kTarget] = this;
				callListener(handler, this, event);
			};
			else if (type === "open") wrapper = function onOpen() {
				const event = new Event("open");
				event[kTarget] = this;
				callListener(handler, this, event);
			};
			else return;
			wrapper[kForOnEventAttribute$1] = !!options[kForOnEventAttribute$1];
			wrapper[kListener$1] = handler;
			if (options.once) this.once(type, wrapper);
			else this.on(type, wrapper);
		},
		removeEventListener(type, handler) {
			for (const listener of this.listeners(type)) if (listener[kListener$1] === handler && !listener[kForOnEventAttribute$1]) {
				this.removeListener(type, listener);
				break;
			}
		}
	};
	module.exports = {
		CloseEvent,
		ErrorEvent,
		Event,
		EventTarget,
		MessageEvent
	};
	/**
	* Call an event listener
	*
	* @param {(Function|Object)} listener The listener to call
	* @param {*} thisArg The value to use as `this`` when calling the listener
	* @param {Event} event The event to pass to the listener
	* @private
	*/
	function callListener(listener, thisArg, event) {
		if (typeof listener === "object" && listener.handleEvent) listener.handleEvent.call(listener, event);
		else listener.call(thisArg, event);
	}
}) });

//#endregion
//#region node_modules/ws/lib/extension.js
var require_extension = /* @__PURE__ */ __commonJS({ "node_modules/ws/lib/extension.js": ((exports, module) => {
	const { tokenChars: tokenChars$1 } = require_validation();
	/**
	* Adds an offer to the map of extension offers or a parameter to the map of
	* parameters.
	*
	* @param {Object} dest The map of extension offers or parameters
	* @param {String} name The extension or parameter name
	* @param {(Object|Boolean|String)} elem The extension parameters or the
	*     parameter value
	* @private
	*/
	function push(dest, name, elem) {
		if (dest[name] === void 0) dest[name] = [elem];
		else dest[name].push(elem);
	}
	/**
	* Parses the `Sec-WebSocket-Extensions` header into an object.
	*
	* @param {String} header The field value of the header
	* @return {Object} The parsed object
	* @public
	*/
	function parse$3(header) {
		const offers = Object.create(null);
		let params = Object.create(null);
		let mustUnescape = false;
		let isEscaping = false;
		let inQuotes = false;
		let extensionName;
		let paramName;
		let start = -1;
		let code = -1;
		let end = -1;
		let i = 0;
		for (; i < header.length; i++) {
			code = header.charCodeAt(i);
			if (extensionName === void 0) if (end === -1 && tokenChars$1[code] === 1) {
				if (start === -1) start = i;
			} else if (i !== 0 && (code === 32 || code === 9)) {
				if (end === -1 && start !== -1) end = i;
			} else if (code === 59 || code === 44) {
				if (start === -1) throw new SyntaxError(`Unexpected character at index ${i}`);
				if (end === -1) end = i;
				const name = header.slice(start, end);
				if (code === 44) {
					push(offers, name, params);
					params = Object.create(null);
				} else extensionName = name;
				start = end = -1;
			} else throw new SyntaxError(`Unexpected character at index ${i}`);
			else if (paramName === void 0) if (end === -1 && tokenChars$1[code] === 1) {
				if (start === -1) start = i;
			} else if (code === 32 || code === 9) {
				if (end === -1 && start !== -1) end = i;
			} else if (code === 59 || code === 44) {
				if (start === -1) throw new SyntaxError(`Unexpected character at index ${i}`);
				if (end === -1) end = i;
				push(params, header.slice(start, end), true);
				if (code === 44) {
					push(offers, extensionName, params);
					params = Object.create(null);
					extensionName = void 0;
				}
				start = end = -1;
			} else if (code === 61 && start !== -1 && end === -1) {
				paramName = header.slice(start, i);
				start = end = -1;
			} else throw new SyntaxError(`Unexpected character at index ${i}`);
			else if (isEscaping) {
				if (tokenChars$1[code] !== 1) throw new SyntaxError(`Unexpected character at index ${i}`);
				if (start === -1) start = i;
				else if (!mustUnescape) mustUnescape = true;
				isEscaping = false;
			} else if (inQuotes) if (tokenChars$1[code] === 1) {
				if (start === -1) start = i;
			} else if (code === 34 && start !== -1) {
				inQuotes = false;
				end = i;
			} else if (code === 92) isEscaping = true;
			else throw new SyntaxError(`Unexpected character at index ${i}`);
			else if (code === 34 && header.charCodeAt(i - 1) === 61) inQuotes = true;
			else if (end === -1 && tokenChars$1[code] === 1) {
				if (start === -1) start = i;
			} else if (start !== -1 && (code === 32 || code === 9)) {
				if (end === -1) end = i;
			} else if (code === 59 || code === 44) {
				if (start === -1) throw new SyntaxError(`Unexpected character at index ${i}`);
				if (end === -1) end = i;
				let value = header.slice(start, end);
				if (mustUnescape) {
					value = value.replace(/\\/g, "");
					mustUnescape = false;
				}
				push(params, paramName, value);
				if (code === 44) {
					push(offers, extensionName, params);
					params = Object.create(null);
					extensionName = void 0;
				}
				paramName = void 0;
				start = end = -1;
			} else throw new SyntaxError(`Unexpected character at index ${i}`);
		}
		if (start === -1 || inQuotes || code === 32 || code === 9) throw new SyntaxError("Unexpected end of input");
		if (end === -1) end = i;
		const token = header.slice(start, end);
		if (extensionName === void 0) push(offers, token, params);
		else {
			if (paramName === void 0) push(params, token, true);
			else if (mustUnescape) push(params, paramName, token.replace(/\\/g, ""));
			else push(params, paramName, token);
			push(offers, extensionName, params);
		}
		return offers;
	}
	/**
	* Builds the `Sec-WebSocket-Extensions` header field value.
	*
	* @param {Object} extensions The map of extensions and parameters to format
	* @return {String} A string representing the given object
	* @public
	*/
	function format$2(extensions) {
		return Object.keys(extensions).map((extension$1) => {
			let configurations = extensions[extension$1];
			if (!Array.isArray(configurations)) configurations = [configurations];
			return configurations.map((params) => {
				return [extension$1].concat(Object.keys(params).map((k) => {
					let values = params[k];
					if (!Array.isArray(values)) values = [values];
					return values.map((v) => v === true ? k : `${k}=${v}`).join("; ");
				})).join("; ");
			}).join(", ");
		}).join(", ");
	}
	module.exports = {
		format: format$2,
		parse: parse$3
	};
}) });

//#endregion
//#region node_modules/ws/lib/websocket.js
var require_websocket = /* @__PURE__ */ __commonJS({ "node_modules/ws/lib/websocket.js": ((exports, module) => {
	const EventEmitter$2 = __require("events");
	const https = __require("https");
	const http$1 = __require("http");
	const net = __require("net");
	const tls = __require("tls");
	const { randomBytes, createHash: createHash$1 } = __require("crypto");
	const { Duplex: Duplex$2, Readable } = __require("stream");
	const { URL: URL$1 } = __require("url");
	const PerMessageDeflate$1 = require_permessage_deflate();
	const Receiver$1 = require_receiver();
	const Sender$1 = require_sender();
	const { isBlob } = require_validation();
	const { BINARY_TYPES, EMPTY_BUFFER, GUID: GUID$1, kForOnEventAttribute, kListener, kStatusCode, kWebSocket: kWebSocket$1, NOOP } = require_constants();
	const { EventTarget: { addEventListener, removeEventListener } } = require_event_target();
	const { format: format$1, parse: parse$2 } = require_extension();
	const { toBuffer } = require_buffer_util();
	const closeTimeout = 30 * 1e3;
	const kAborted = Symbol("kAborted");
	const protocolVersions = [8, 13];
	const readyStates = [
		"CONNECTING",
		"OPEN",
		"CLOSING",
		"CLOSED"
	];
	const subprotocolRegex = /^[!#$%&'*+\-.0-9A-Z^_`|a-z~]+$/;
	/**
	* Class representing a WebSocket.
	*
	* @extends EventEmitter
	*/
	var WebSocket$2 = class WebSocket$2 extends EventEmitter$2 {
		/**
		* Create a new `WebSocket`.
		*
		* @param {(String|URL)} address The URL to which to connect
		* @param {(String|String[])} [protocols] The subprotocols
		* @param {Object} [options] Connection options
		*/
		constructor(address, protocols, options) {
			super();
			this._binaryType = BINARY_TYPES[0];
			this._closeCode = 1006;
			this._closeFrameReceived = false;
			this._closeFrameSent = false;
			this._closeMessage = EMPTY_BUFFER;
			this._closeTimer = null;
			this._errorEmitted = false;
			this._extensions = {};
			this._paused = false;
			this._protocol = "";
			this._readyState = WebSocket$2.CONNECTING;
			this._receiver = null;
			this._sender = null;
			this._socket = null;
			if (address !== null) {
				this._bufferedAmount = 0;
				this._isServer = false;
				this._redirects = 0;
				if (protocols === void 0) protocols = [];
				else if (!Array.isArray(protocols)) if (typeof protocols === "object" && protocols !== null) {
					options = protocols;
					protocols = [];
				} else protocols = [protocols];
				initAsClient(this, address, protocols, options);
			} else {
				this._autoPong = options.autoPong;
				this._isServer = true;
			}
		}
		/**
		* For historical reasons, the custom "nodebuffer" type is used by the default
		* instead of "blob".
		*
		* @type {String}
		*/
		get binaryType() {
			return this._binaryType;
		}
		set binaryType(type) {
			if (!BINARY_TYPES.includes(type)) return;
			this._binaryType = type;
			if (this._receiver) this._receiver._binaryType = type;
		}
		/**
		* @type {Number}
		*/
		get bufferedAmount() {
			if (!this._socket) return this._bufferedAmount;
			return this._socket._writableState.length + this._sender._bufferedBytes;
		}
		/**
		* @type {String}
		*/
		get extensions() {
			return Object.keys(this._extensions).join();
		}
		/**
		* @type {Boolean}
		*/
		get isPaused() {
			return this._paused;
		}
		/**
		* @type {Function}
		*/
		/* istanbul ignore next */
		get onclose() {
			return null;
		}
		/**
		* @type {Function}
		*/
		/* istanbul ignore next */
		get onerror() {
			return null;
		}
		/**
		* @type {Function}
		*/
		/* istanbul ignore next */
		get onopen() {
			return null;
		}
		/**
		* @type {Function}
		*/
		/* istanbul ignore next */
		get onmessage() {
			return null;
		}
		/**
		* @type {String}
		*/
		get protocol() {
			return this._protocol;
		}
		/**
		* @type {Number}
		*/
		get readyState() {
			return this._readyState;
		}
		/**
		* @type {String}
		*/
		get url() {
			return this._url;
		}
		/**
		* Set up the socket and the internal resources.
		*
		* @param {Duplex} socket The network socket between the server and client
		* @param {Buffer} head The first packet of the upgraded stream
		* @param {Object} options Options object
		* @param {Boolean} [options.allowSynchronousEvents=false] Specifies whether
		*     any of the `'message'`, `'ping'`, and `'pong'` events can be emitted
		*     multiple times in the same tick
		* @param {Function} [options.generateMask] The function used to generate the
		*     masking key
		* @param {Number} [options.maxPayload=0] The maximum allowed message size
		* @param {Boolean} [options.skipUTF8Validation=false] Specifies whether or
		*     not to skip UTF-8 validation for text and close messages
		* @private
		*/
		setSocket(socket, head, options) {
			const receiver = new Receiver$1({
				allowSynchronousEvents: options.allowSynchronousEvents,
				binaryType: this.binaryType,
				extensions: this._extensions,
				isServer: this._isServer,
				maxPayload: options.maxPayload,
				skipUTF8Validation: options.skipUTF8Validation
			});
			const sender = new Sender$1(socket, this._extensions, options.generateMask);
			this._receiver = receiver;
			this._sender = sender;
			this._socket = socket;
			receiver[kWebSocket$1] = this;
			sender[kWebSocket$1] = this;
			socket[kWebSocket$1] = this;
			receiver.on("conclude", receiverOnConclude);
			receiver.on("drain", receiverOnDrain);
			receiver.on("error", receiverOnError);
			receiver.on("message", receiverOnMessage);
			receiver.on("ping", receiverOnPing);
			receiver.on("pong", receiverOnPong);
			sender.onerror = senderOnError;
			if (socket.setTimeout) socket.setTimeout(0);
			if (socket.setNoDelay) socket.setNoDelay();
			if (head.length > 0) socket.unshift(head);
			socket.on("close", socketOnClose);
			socket.on("data", socketOnData);
			socket.on("end", socketOnEnd);
			socket.on("error", socketOnError$1);
			this._readyState = WebSocket$2.OPEN;
			this.emit("open");
		}
		/**
		* Emit the `'close'` event.
		*
		* @private
		*/
		emitClose() {
			if (!this._socket) {
				this._readyState = WebSocket$2.CLOSED;
				this.emit("close", this._closeCode, this._closeMessage);
				return;
			}
			if (this._extensions[PerMessageDeflate$1.extensionName]) this._extensions[PerMessageDeflate$1.extensionName].cleanup();
			this._receiver.removeAllListeners();
			this._readyState = WebSocket$2.CLOSED;
			this.emit("close", this._closeCode, this._closeMessage);
		}
		/**
		* Start a closing handshake.
		*
		*          +----------+   +-----------+   +----------+
		*     - - -|ws.close()|-->|close frame|-->|ws.close()|- - -
		*    |     +----------+   +-----------+   +----------+     |
		*          +----------+   +-----------+         |
		* CLOSING  |ws.close()|<--|close frame|<--+-----+       CLOSING
		*          +----------+   +-----------+   |
		*    |           |                        |   +---+        |
		*                +------------------------+-->|fin| - - - -
		*    |         +---+                      |   +---+
		*     - - - - -|fin|<---------------------+
		*              +---+
		*
		* @param {Number} [code] Status code explaining why the connection is closing
		* @param {(String|Buffer)} [data] The reason why the connection is
		*     closing
		* @public
		*/
		close(code, data) {
			if (this.readyState === WebSocket$2.CLOSED) return;
			if (this.readyState === WebSocket$2.CONNECTING) {
				abortHandshake$1(this, this._req, "WebSocket was closed before the connection was established");
				return;
			}
			if (this.readyState === WebSocket$2.CLOSING) {
				if (this._closeFrameSent && (this._closeFrameReceived || this._receiver._writableState.errorEmitted)) this._socket.end();
				return;
			}
			this._readyState = WebSocket$2.CLOSING;
			this._sender.close(code, data, !this._isServer, (err) => {
				if (err) return;
				this._closeFrameSent = true;
				if (this._closeFrameReceived || this._receiver._writableState.errorEmitted) this._socket.end();
			});
			setCloseTimer(this);
		}
		/**
		* Pause the socket.
		*
		* @public
		*/
		pause() {
			if (this.readyState === WebSocket$2.CONNECTING || this.readyState === WebSocket$2.CLOSED) return;
			this._paused = true;
			this._socket.pause();
		}
		/**
		* Send a ping.
		*
		* @param {*} [data] The data to send
		* @param {Boolean} [mask] Indicates whether or not to mask `data`
		* @param {Function} [cb] Callback which is executed when the ping is sent
		* @public
		*/
		ping(data, mask, cb) {
			if (this.readyState === WebSocket$2.CONNECTING) throw new Error("WebSocket is not open: readyState 0 (CONNECTING)");
			if (typeof data === "function") {
				cb = data;
				data = mask = void 0;
			} else if (typeof mask === "function") {
				cb = mask;
				mask = void 0;
			}
			if (typeof data === "number") data = data.toString();
			if (this.readyState !== WebSocket$2.OPEN) {
				sendAfterClose(this, data, cb);
				return;
			}
			if (mask === void 0) mask = !this._isServer;
			this._sender.ping(data || EMPTY_BUFFER, mask, cb);
		}
		/**
		* Send a pong.
		*
		* @param {*} [data] The data to send
		* @param {Boolean} [mask] Indicates whether or not to mask `data`
		* @param {Function} [cb] Callback which is executed when the pong is sent
		* @public
		*/
		pong(data, mask, cb) {
			if (this.readyState === WebSocket$2.CONNECTING) throw new Error("WebSocket is not open: readyState 0 (CONNECTING)");
			if (typeof data === "function") {
				cb = data;
				data = mask = void 0;
			} else if (typeof mask === "function") {
				cb = mask;
				mask = void 0;
			}
			if (typeof data === "number") data = data.toString();
			if (this.readyState !== WebSocket$2.OPEN) {
				sendAfterClose(this, data, cb);
				return;
			}
			if (mask === void 0) mask = !this._isServer;
			this._sender.pong(data || EMPTY_BUFFER, mask, cb);
		}
		/**
		* Resume the socket.
		*
		* @public
		*/
		resume() {
			if (this.readyState === WebSocket$2.CONNECTING || this.readyState === WebSocket$2.CLOSED) return;
			this._paused = false;
			if (!this._receiver._writableState.needDrain) this._socket.resume();
		}
		/**
		* Send a data message.
		*
		* @param {*} data The message to send
		* @param {Object} [options] Options object
		* @param {Boolean} [options.binary] Specifies whether `data` is binary or
		*     text
		* @param {Boolean} [options.compress] Specifies whether or not to compress
		*     `data`
		* @param {Boolean} [options.fin=true] Specifies whether the fragment is the
		*     last one
		* @param {Boolean} [options.mask] Specifies whether or not to mask `data`
		* @param {Function} [cb] Callback which is executed when data is written out
		* @public
		*/
		send(data, options, cb) {
			if (this.readyState === WebSocket$2.CONNECTING) throw new Error("WebSocket is not open: readyState 0 (CONNECTING)");
			if (typeof options === "function") {
				cb = options;
				options = {};
			}
			if (typeof data === "number") data = data.toString();
			if (this.readyState !== WebSocket$2.OPEN) {
				sendAfterClose(this, data, cb);
				return;
			}
			const opts = {
				binary: typeof data !== "string",
				mask: !this._isServer,
				compress: true,
				fin: true,
				...options
			};
			if (!this._extensions[PerMessageDeflate$1.extensionName]) opts.compress = false;
			this._sender.send(data || EMPTY_BUFFER, opts, cb);
		}
		/**
		* Forcibly close the connection.
		*
		* @public
		*/
		terminate() {
			if (this.readyState === WebSocket$2.CLOSED) return;
			if (this.readyState === WebSocket$2.CONNECTING) {
				abortHandshake$1(this, this._req, "WebSocket was closed before the connection was established");
				return;
			}
			if (this._socket) {
				this._readyState = WebSocket$2.CLOSING;
				this._socket.destroy();
			}
		}
	};
	/**
	* @constant {Number} CONNECTING
	* @memberof WebSocket
	*/
	Object.defineProperty(WebSocket$2, "CONNECTING", {
		enumerable: true,
		value: readyStates.indexOf("CONNECTING")
	});
	/**
	* @constant {Number} CONNECTING
	* @memberof WebSocket.prototype
	*/
	Object.defineProperty(WebSocket$2.prototype, "CONNECTING", {
		enumerable: true,
		value: readyStates.indexOf("CONNECTING")
	});
	/**
	* @constant {Number} OPEN
	* @memberof WebSocket
	*/
	Object.defineProperty(WebSocket$2, "OPEN", {
		enumerable: true,
		value: readyStates.indexOf("OPEN")
	});
	/**
	* @constant {Number} OPEN
	* @memberof WebSocket.prototype
	*/
	Object.defineProperty(WebSocket$2.prototype, "OPEN", {
		enumerable: true,
		value: readyStates.indexOf("OPEN")
	});
	/**
	* @constant {Number} CLOSING
	* @memberof WebSocket
	*/
	Object.defineProperty(WebSocket$2, "CLOSING", {
		enumerable: true,
		value: readyStates.indexOf("CLOSING")
	});
	/**
	* @constant {Number} CLOSING
	* @memberof WebSocket.prototype
	*/
	Object.defineProperty(WebSocket$2.prototype, "CLOSING", {
		enumerable: true,
		value: readyStates.indexOf("CLOSING")
	});
	/**
	* @constant {Number} CLOSED
	* @memberof WebSocket
	*/
	Object.defineProperty(WebSocket$2, "CLOSED", {
		enumerable: true,
		value: readyStates.indexOf("CLOSED")
	});
	/**
	* @constant {Number} CLOSED
	* @memberof WebSocket.prototype
	*/
	Object.defineProperty(WebSocket$2.prototype, "CLOSED", {
		enumerable: true,
		value: readyStates.indexOf("CLOSED")
	});
	[
		"binaryType",
		"bufferedAmount",
		"extensions",
		"isPaused",
		"protocol",
		"readyState",
		"url"
	].forEach((property) => {
		Object.defineProperty(WebSocket$2.prototype, property, { enumerable: true });
	});
	[
		"open",
		"error",
		"close",
		"message"
	].forEach((method) => {
		Object.defineProperty(WebSocket$2.prototype, `on${method}`, {
			enumerable: true,
			get() {
				for (const listener of this.listeners(method)) if (listener[kForOnEventAttribute]) return listener[kListener];
				return null;
			},
			set(handler) {
				for (const listener of this.listeners(method)) if (listener[kForOnEventAttribute]) {
					this.removeListener(method, listener);
					break;
				}
				if (typeof handler !== "function") return;
				this.addEventListener(method, handler, { [kForOnEventAttribute]: true });
			}
		});
	});
	WebSocket$2.prototype.addEventListener = addEventListener;
	WebSocket$2.prototype.removeEventListener = removeEventListener;
	module.exports = WebSocket$2;
	/**
	* Initialize a WebSocket client.
	*
	* @param {WebSocket} websocket The client to initialize
	* @param {(String|URL)} address The URL to which to connect
	* @param {Array} protocols The subprotocols
	* @param {Object} [options] Connection options
	* @param {Boolean} [options.allowSynchronousEvents=true] Specifies whether any
	*     of the `'message'`, `'ping'`, and `'pong'` events can be emitted multiple
	*     times in the same tick
	* @param {Boolean} [options.autoPong=true] Specifies whether or not to
	*     automatically send a pong in response to a ping
	* @param {Function} [options.finishRequest] A function which can be used to
	*     customize the headers of each http request before it is sent
	* @param {Boolean} [options.followRedirects=false] Whether or not to follow
	*     redirects
	* @param {Function} [options.generateMask] The function used to generate the
	*     masking key
	* @param {Number} [options.handshakeTimeout] Timeout in milliseconds for the
	*     handshake request
	* @param {Number} [options.maxPayload=104857600] The maximum allowed message
	*     size
	* @param {Number} [options.maxRedirects=10] The maximum number of redirects
	*     allowed
	* @param {String} [options.origin] Value of the `Origin` or
	*     `Sec-WebSocket-Origin` header
	* @param {(Boolean|Object)} [options.perMessageDeflate=true] Enable/disable
	*     permessage-deflate
	* @param {Number} [options.protocolVersion=13] Value of the
	*     `Sec-WebSocket-Version` header
	* @param {Boolean} [options.skipUTF8Validation=false] Specifies whether or
	*     not to skip UTF-8 validation for text and close messages
	* @private
	*/
	function initAsClient(websocket, address, protocols, options) {
		const opts = {
			allowSynchronousEvents: true,
			autoPong: true,
			protocolVersion: protocolVersions[1],
			maxPayload: 100 * 1024 * 1024,
			skipUTF8Validation: false,
			perMessageDeflate: true,
			followRedirects: false,
			maxRedirects: 10,
			...options,
			socketPath: void 0,
			hostname: void 0,
			protocol: void 0,
			timeout: void 0,
			method: "GET",
			host: void 0,
			path: void 0,
			port: void 0
		};
		websocket._autoPong = opts.autoPong;
		if (!protocolVersions.includes(opts.protocolVersion)) throw new RangeError(`Unsupported protocol version: ${opts.protocolVersion} (supported versions: ${protocolVersions.join(", ")})`);
		let parsedUrl;
		if (address instanceof URL$1) parsedUrl = address;
		else try {
			parsedUrl = new URL$1(address);
		} catch (e) {
			throw new SyntaxError(`Invalid URL: ${address}`);
		}
		if (parsedUrl.protocol === "http:") parsedUrl.protocol = "ws:";
		else if (parsedUrl.protocol === "https:") parsedUrl.protocol = "wss:";
		websocket._url = parsedUrl.href;
		const isSecure = parsedUrl.protocol === "wss:";
		const isIpcUrl = parsedUrl.protocol === "ws+unix:";
		let invalidUrlMessage;
		if (parsedUrl.protocol !== "ws:" && !isSecure && !isIpcUrl) invalidUrlMessage = "The URL's protocol must be one of \"ws:\", \"wss:\", \"http:\", \"https:\", or \"ws+unix:\"";
		else if (isIpcUrl && !parsedUrl.pathname) invalidUrlMessage = "The URL's pathname is empty";
		else if (parsedUrl.hash) invalidUrlMessage = "The URL contains a fragment identifier";
		if (invalidUrlMessage) {
			const err = new SyntaxError(invalidUrlMessage);
			if (websocket._redirects === 0) throw err;
			else {
				emitErrorAndClose(websocket, err);
				return;
			}
		}
		const defaultPort = isSecure ? 443 : 80;
		const key = randomBytes(16).toString("base64");
		const request = isSecure ? https.request : http$1.request;
		const protocolSet = /* @__PURE__ */ new Set();
		let perMessageDeflate;
		opts.createConnection = opts.createConnection || (isSecure ? tlsConnect : netConnect);
		opts.defaultPort = opts.defaultPort || defaultPort;
		opts.port = parsedUrl.port || defaultPort;
		opts.host = parsedUrl.hostname.startsWith("[") ? parsedUrl.hostname.slice(1, -1) : parsedUrl.hostname;
		opts.headers = {
			...opts.headers,
			"Sec-WebSocket-Version": opts.protocolVersion,
			"Sec-WebSocket-Key": key,
			Connection: "Upgrade",
			Upgrade: "websocket"
		};
		opts.path = parsedUrl.pathname + parsedUrl.search;
		opts.timeout = opts.handshakeTimeout;
		if (opts.perMessageDeflate) {
			perMessageDeflate = new PerMessageDeflate$1(opts.perMessageDeflate !== true ? opts.perMessageDeflate : {}, false, opts.maxPayload);
			opts.headers["Sec-WebSocket-Extensions"] = format$1({ [PerMessageDeflate$1.extensionName]: perMessageDeflate.offer() });
		}
		if (protocols.length) {
			for (const protocol of protocols) {
				if (typeof protocol !== "string" || !subprotocolRegex.test(protocol) || protocolSet.has(protocol)) throw new SyntaxError("An invalid or duplicated subprotocol was specified");
				protocolSet.add(protocol);
			}
			opts.headers["Sec-WebSocket-Protocol"] = protocols.join(",");
		}
		if (opts.origin) if (opts.protocolVersion < 13) opts.headers["Sec-WebSocket-Origin"] = opts.origin;
		else opts.headers.Origin = opts.origin;
		if (parsedUrl.username || parsedUrl.password) opts.auth = `${parsedUrl.username}:${parsedUrl.password}`;
		if (isIpcUrl) {
			const parts = opts.path.split(":");
			opts.socketPath = parts[0];
			opts.path = parts[1];
		}
		let req;
		if (opts.followRedirects) {
			if (websocket._redirects === 0) {
				websocket._originalIpc = isIpcUrl;
				websocket._originalSecure = isSecure;
				websocket._originalHostOrSocketPath = isIpcUrl ? opts.socketPath : parsedUrl.host;
				const headers = options && options.headers;
				options = {
					...options,
					headers: {}
				};
				if (headers) for (const [key$1, value] of Object.entries(headers)) options.headers[key$1.toLowerCase()] = value;
			} else if (websocket.listenerCount("redirect") === 0) {
				const isSameHost = isIpcUrl ? websocket._originalIpc ? opts.socketPath === websocket._originalHostOrSocketPath : false : websocket._originalIpc ? false : parsedUrl.host === websocket._originalHostOrSocketPath;
				if (!isSameHost || websocket._originalSecure && !isSecure) {
					delete opts.headers.authorization;
					delete opts.headers.cookie;
					if (!isSameHost) delete opts.headers.host;
					opts.auth = void 0;
				}
			}
			if (opts.auth && !options.headers.authorization) options.headers.authorization = "Basic " + Buffer.from(opts.auth).toString("base64");
			req = websocket._req = request(opts);
			if (websocket._redirects) websocket.emit("redirect", websocket.url, req);
		} else req = websocket._req = request(opts);
		if (opts.timeout) req.on("timeout", () => {
			abortHandshake$1(websocket, req, "Opening handshake has timed out");
		});
		req.on("error", (err) => {
			if (req === null || req[kAborted]) return;
			req = websocket._req = null;
			emitErrorAndClose(websocket, err);
		});
		req.on("response", (res) => {
			const location = res.headers.location;
			const statusCode = res.statusCode;
			if (location && opts.followRedirects && statusCode >= 300 && statusCode < 400) {
				if (++websocket._redirects > opts.maxRedirects) {
					abortHandshake$1(websocket, req, "Maximum redirects exceeded");
					return;
				}
				req.abort();
				let addr;
				try {
					addr = new URL$1(location, address);
				} catch (e) {
					emitErrorAndClose(websocket, /* @__PURE__ */ new SyntaxError(`Invalid URL: ${location}`));
					return;
				}
				initAsClient(websocket, addr, protocols, options);
			} else if (!websocket.emit("unexpected-response", req, res)) abortHandshake$1(websocket, req, `Unexpected server response: ${res.statusCode}`);
		});
		req.on("upgrade", (res, socket, head) => {
			websocket.emit("upgrade", res);
			if (websocket.readyState !== WebSocket$2.CONNECTING) return;
			req = websocket._req = null;
			const upgrade = res.headers.upgrade;
			if (upgrade === void 0 || upgrade.toLowerCase() !== "websocket") {
				abortHandshake$1(websocket, socket, "Invalid Upgrade header");
				return;
			}
			const digest = createHash$1("sha1").update(key + GUID$1).digest("base64");
			if (res.headers["sec-websocket-accept"] !== digest) {
				abortHandshake$1(websocket, socket, "Invalid Sec-WebSocket-Accept header");
				return;
			}
			const serverProt = res.headers["sec-websocket-protocol"];
			let protError;
			if (serverProt !== void 0) {
				if (!protocolSet.size) protError = "Server sent a subprotocol but none was requested";
				else if (!protocolSet.has(serverProt)) protError = "Server sent an invalid subprotocol";
			} else if (protocolSet.size) protError = "Server sent no subprotocol";
			if (protError) {
				abortHandshake$1(websocket, socket, protError);
				return;
			}
			if (serverProt) websocket._protocol = serverProt;
			const secWebSocketExtensions = res.headers["sec-websocket-extensions"];
			if (secWebSocketExtensions !== void 0) {
				if (!perMessageDeflate) {
					abortHandshake$1(websocket, socket, "Server sent a Sec-WebSocket-Extensions header but no extension was requested");
					return;
				}
				let extensions;
				try {
					extensions = parse$2(secWebSocketExtensions);
				} catch (err) {
					abortHandshake$1(websocket, socket, "Invalid Sec-WebSocket-Extensions header");
					return;
				}
				const extensionNames = Object.keys(extensions);
				if (extensionNames.length !== 1 || extensionNames[0] !== PerMessageDeflate$1.extensionName) {
					abortHandshake$1(websocket, socket, "Server indicated an extension that was not requested");
					return;
				}
				try {
					perMessageDeflate.accept(extensions[PerMessageDeflate$1.extensionName]);
				} catch (err) {
					abortHandshake$1(websocket, socket, "Invalid Sec-WebSocket-Extensions header");
					return;
				}
				websocket._extensions[PerMessageDeflate$1.extensionName] = perMessageDeflate;
			}
			websocket.setSocket(socket, head, {
				allowSynchronousEvents: opts.allowSynchronousEvents,
				generateMask: opts.generateMask,
				maxPayload: opts.maxPayload,
				skipUTF8Validation: opts.skipUTF8Validation
			});
		});
		if (opts.finishRequest) opts.finishRequest(req, websocket);
		else req.end();
	}
	/**
	* Emit the `'error'` and `'close'` events.
	*
	* @param {WebSocket} websocket The WebSocket instance
	* @param {Error} The error to emit
	* @private
	*/
	function emitErrorAndClose(websocket, err) {
		websocket._readyState = WebSocket$2.CLOSING;
		websocket._errorEmitted = true;
		websocket.emit("error", err);
		websocket.emitClose();
	}
	/**
	* Create a `net.Socket` and initiate a connection.
	*
	* @param {Object} options Connection options
	* @return {net.Socket} The newly created socket used to start the connection
	* @private
	*/
	function netConnect(options) {
		options.path = options.socketPath;
		return net.connect(options);
	}
	/**
	* Create a `tls.TLSSocket` and initiate a connection.
	*
	* @param {Object} options Connection options
	* @return {tls.TLSSocket} The newly created socket used to start the connection
	* @private
	*/
	function tlsConnect(options) {
		options.path = void 0;
		if (!options.servername && options.servername !== "") options.servername = net.isIP(options.host) ? "" : options.host;
		return tls.connect(options);
	}
	/**
	* Abort the handshake and emit an error.
	*
	* @param {WebSocket} websocket The WebSocket instance
	* @param {(http.ClientRequest|net.Socket|tls.Socket)} stream The request to
	*     abort or the socket to destroy
	* @param {String} message The error message
	* @private
	*/
	function abortHandshake$1(websocket, stream, message) {
		websocket._readyState = WebSocket$2.CLOSING;
		const err = new Error(message);
		Error.captureStackTrace(err, abortHandshake$1);
		if (stream.setHeader) {
			stream[kAborted] = true;
			stream.abort();
			if (stream.socket && !stream.socket.destroyed) stream.socket.destroy();
			process.nextTick(emitErrorAndClose, websocket, err);
		} else {
			stream.destroy(err);
			stream.once("error", websocket.emit.bind(websocket, "error"));
			stream.once("close", websocket.emitClose.bind(websocket));
		}
	}
	/**
	* Handle cases where the `ping()`, `pong()`, or `send()` methods are called
	* when the `readyState` attribute is `CLOSING` or `CLOSED`.
	*
	* @param {WebSocket} websocket The WebSocket instance
	* @param {*} [data] The data to send
	* @param {Function} [cb] Callback
	* @private
	*/
	function sendAfterClose(websocket, data, cb) {
		if (data) {
			const length = isBlob(data) ? data.size : toBuffer(data).length;
			if (websocket._socket) websocket._sender._bufferedBytes += length;
			else websocket._bufferedAmount += length;
		}
		if (cb) {
			const err = /* @__PURE__ */ new Error(`WebSocket is not open: readyState ${websocket.readyState} (${readyStates[websocket.readyState]})`);
			process.nextTick(cb, err);
		}
	}
	/**
	* The listener of the `Receiver` `'conclude'` event.
	*
	* @param {Number} code The status code
	* @param {Buffer} reason The reason for closing
	* @private
	*/
	function receiverOnConclude(code, reason) {
		const websocket = this[kWebSocket$1];
		websocket._closeFrameReceived = true;
		websocket._closeMessage = reason;
		websocket._closeCode = code;
		if (websocket._socket[kWebSocket$1] === void 0) return;
		websocket._socket.removeListener("data", socketOnData);
		process.nextTick(resume, websocket._socket);
		if (code === 1005) websocket.close();
		else websocket.close(code, reason);
	}
	/**
	* The listener of the `Receiver` `'drain'` event.
	*
	* @private
	*/
	function receiverOnDrain() {
		const websocket = this[kWebSocket$1];
		if (!websocket.isPaused) websocket._socket.resume();
	}
	/**
	* The listener of the `Receiver` `'error'` event.
	*
	* @param {(RangeError|Error)} err The emitted error
	* @private
	*/
	function receiverOnError(err) {
		const websocket = this[kWebSocket$1];
		if (websocket._socket[kWebSocket$1] !== void 0) {
			websocket._socket.removeListener("data", socketOnData);
			process.nextTick(resume, websocket._socket);
			websocket.close(err[kStatusCode]);
		}
		if (!websocket._errorEmitted) {
			websocket._errorEmitted = true;
			websocket.emit("error", err);
		}
	}
	/**
	* The listener of the `Receiver` `'finish'` event.
	*
	* @private
	*/
	function receiverOnFinish() {
		this[kWebSocket$1].emitClose();
	}
	/**
	* The listener of the `Receiver` `'message'` event.
	*
	* @param {Buffer|ArrayBuffer|Buffer[])} data The message
	* @param {Boolean} isBinary Specifies whether the message is binary or not
	* @private
	*/
	function receiverOnMessage(data, isBinary) {
		this[kWebSocket$1].emit("message", data, isBinary);
	}
	/**
	* The listener of the `Receiver` `'ping'` event.
	*
	* @param {Buffer} data The data included in the ping frame
	* @private
	*/
	function receiverOnPing(data) {
		const websocket = this[kWebSocket$1];
		if (websocket._autoPong) websocket.pong(data, !this._isServer, NOOP);
		websocket.emit("ping", data);
	}
	/**
	* The listener of the `Receiver` `'pong'` event.
	*
	* @param {Buffer} data The data included in the pong frame
	* @private
	*/
	function receiverOnPong(data) {
		this[kWebSocket$1].emit("pong", data);
	}
	/**
	* Resume a readable stream
	*
	* @param {Readable} stream The readable stream
	* @private
	*/
	function resume(stream) {
		stream.resume();
	}
	/**
	* The `Sender` error event handler.
	*
	* @param {Error} The error
	* @private
	*/
	function senderOnError(err) {
		const websocket = this[kWebSocket$1];
		if (websocket.readyState === WebSocket$2.CLOSED) return;
		if (websocket.readyState === WebSocket$2.OPEN) {
			websocket._readyState = WebSocket$2.CLOSING;
			setCloseTimer(websocket);
		}
		this._socket.end();
		if (!websocket._errorEmitted) {
			websocket._errorEmitted = true;
			websocket.emit("error", err);
		}
	}
	/**
	* Set a timer to destroy the underlying raw socket of a WebSocket.
	*
	* @param {WebSocket} websocket The WebSocket instance
	* @private
	*/
	function setCloseTimer(websocket) {
		websocket._closeTimer = setTimeout(websocket._socket.destroy.bind(websocket._socket), closeTimeout);
	}
	/**
	* The listener of the socket `'close'` event.
	*
	* @private
	*/
	function socketOnClose() {
		const websocket = this[kWebSocket$1];
		this.removeListener("close", socketOnClose);
		this.removeListener("data", socketOnData);
		this.removeListener("end", socketOnEnd);
		websocket._readyState = WebSocket$2.CLOSING;
		let chunk;
		if (!this._readableState.endEmitted && !websocket._closeFrameReceived && !websocket._receiver._writableState.errorEmitted && (chunk = websocket._socket.read()) !== null) websocket._receiver.write(chunk);
		websocket._receiver.end();
		this[kWebSocket$1] = void 0;
		clearTimeout(websocket._closeTimer);
		if (websocket._receiver._writableState.finished || websocket._receiver._writableState.errorEmitted) websocket.emitClose();
		else {
			websocket._receiver.on("error", receiverOnFinish);
			websocket._receiver.on("finish", receiverOnFinish);
		}
	}
	/**
	* The listener of the socket `'data'` event.
	*
	* @param {Buffer} chunk A chunk of data
	* @private
	*/
	function socketOnData(chunk) {
		if (!this[kWebSocket$1]._receiver.write(chunk)) this.pause();
	}
	/**
	* The listener of the socket `'end'` event.
	*
	* @private
	*/
	function socketOnEnd() {
		const websocket = this[kWebSocket$1];
		websocket._readyState = WebSocket$2.CLOSING;
		websocket._receiver.end();
		this.end();
	}
	/**
	* The listener of the socket `'error'` event.
	*
	* @private
	*/
	function socketOnError$1() {
		const websocket = this[kWebSocket$1];
		this.removeListener("error", socketOnError$1);
		this.on("error", NOOP);
		if (websocket) {
			websocket._readyState = WebSocket$2.CLOSING;
			this.destroy();
		}
	}
}) });

//#endregion
//#region node_modules/ws/lib/stream.js
var require_stream = /* @__PURE__ */ __commonJS({ "node_modules/ws/lib/stream.js": ((exports, module) => {
	require_websocket();
	const { Duplex: Duplex$1 } = __require("stream");
	/**
	* Emits the `'close'` event on a stream.
	*
	* @param {Duplex} stream The stream.
	* @private
	*/
	function emitClose$1(stream) {
		stream.emit("close");
	}
	/**
	* The listener of the `'end'` event.
	*
	* @private
	*/
	function duplexOnEnd() {
		if (!this.destroyed && this._writableState.finished) this.destroy();
	}
	/**
	* The listener of the `'error'` event.
	*
	* @param {Error} err The error
	* @private
	*/
	function duplexOnError(err) {
		this.removeListener("error", duplexOnError);
		this.destroy();
		if (this.listenerCount("error") === 0) this.emit("error", err);
	}
	/**
	* Wraps a `WebSocket` in a duplex stream.
	*
	* @param {WebSocket} ws The `WebSocket` to wrap
	* @param {Object} [options] The options for the `Duplex` constructor
	* @return {Duplex} The duplex stream
	* @public
	*/
	function createWebSocketStream$1(ws, options) {
		let terminateOnDestroy = true;
		const duplex = new Duplex$1({
			...options,
			autoDestroy: false,
			emitClose: false,
			objectMode: false,
			writableObjectMode: false
		});
		ws.on("message", function message(msg, isBinary) {
			const data = !isBinary && duplex._readableState.objectMode ? msg.toString() : msg;
			if (!duplex.push(data)) ws.pause();
		});
		ws.once("error", function error(err) {
			if (duplex.destroyed) return;
			terminateOnDestroy = false;
			duplex.destroy(err);
		});
		ws.once("close", function close() {
			if (duplex.destroyed) return;
			duplex.push(null);
		});
		duplex._destroy = function(err, callback) {
			if (ws.readyState === ws.CLOSED) {
				callback(err);
				process.nextTick(emitClose$1, duplex);
				return;
			}
			let called = false;
			ws.once("error", function error(err$1) {
				called = true;
				callback(err$1);
			});
			ws.once("close", function close() {
				if (!called) callback(err);
				process.nextTick(emitClose$1, duplex);
			});
			if (terminateOnDestroy) ws.terminate();
		};
		duplex._final = function(callback) {
			if (ws.readyState === ws.CONNECTING) {
				ws.once("open", function open() {
					duplex._final(callback);
				});
				return;
			}
			if (ws._socket === null) return;
			if (ws._socket._writableState.finished) {
				callback();
				if (duplex._readableState.endEmitted) duplex.destroy();
			} else {
				ws._socket.once("finish", function finish() {
					callback();
				});
				ws.close();
			}
		};
		duplex._read = function() {
			if (ws.isPaused) ws.resume();
		};
		duplex._write = function(chunk, encoding, callback) {
			if (ws.readyState === ws.CONNECTING) {
				ws.once("open", function open() {
					duplex._write(chunk, encoding, callback);
				});
				return;
			}
			ws.send(chunk, callback);
		};
		duplex.on("end", duplexOnEnd);
		duplex.on("error", duplexOnError);
		return duplex;
	}
	module.exports = createWebSocketStream$1;
}) });

//#endregion
//#region node_modules/ws/lib/subprotocol.js
var require_subprotocol = /* @__PURE__ */ __commonJS({ "node_modules/ws/lib/subprotocol.js": ((exports, module) => {
	const { tokenChars } = require_validation();
	/**
	* Parses the `Sec-WebSocket-Protocol` header into a set of subprotocol names.
	*
	* @param {String} header The field value of the header
	* @return {Set} The subprotocol names
	* @public
	*/
	function parse$1(header) {
		const protocols = /* @__PURE__ */ new Set();
		let start = -1;
		let end = -1;
		let i = 0;
		for (; i < header.length; i++) {
			const code = header.charCodeAt(i);
			if (end === -1 && tokenChars[code] === 1) {
				if (start === -1) start = i;
			} else if (i !== 0 && (code === 32 || code === 9)) {
				if (end === -1 && start !== -1) end = i;
			} else if (code === 44) {
				if (start === -1) throw new SyntaxError(`Unexpected character at index ${i}`);
				if (end === -1) end = i;
				const protocol$1 = header.slice(start, end);
				if (protocols.has(protocol$1)) throw new SyntaxError(`The "${protocol$1}" subprotocol is duplicated`);
				protocols.add(protocol$1);
				start = end = -1;
			} else throw new SyntaxError(`Unexpected character at index ${i}`);
		}
		if (start === -1 || end !== -1) throw new SyntaxError("Unexpected end of input");
		const protocol = header.slice(start, i);
		if (protocols.has(protocol)) throw new SyntaxError(`The "${protocol}" subprotocol is duplicated`);
		protocols.add(protocol);
		return protocols;
	}
	module.exports = { parse: parse$1 };
}) });

//#endregion
//#region node_modules/ws/lib/websocket-server.js
var require_websocket_server = /* @__PURE__ */ __commonJS({ "node_modules/ws/lib/websocket-server.js": ((exports, module) => {
	const EventEmitter$1 = __require("events");
	const http = __require("http");
	const { Duplex } = __require("stream");
	const { createHash } = __require("crypto");
	const extension = require_extension();
	const PerMessageDeflate = require_permessage_deflate();
	const subprotocol = require_subprotocol();
	const WebSocket$1 = require_websocket();
	const { GUID, kWebSocket } = require_constants();
	const keyRegex = /^[+/0-9A-Za-z]{22}==$/;
	const RUNNING = 0;
	const CLOSING = 1;
	const CLOSED = 2;
	/**
	* Class representing a WebSocket server.
	*
	* @extends EventEmitter
	*/
	var WebSocketServer$1 = class extends EventEmitter$1 {
		/**
		* Create a `WebSocketServer` instance.
		*
		* @param {Object} options Configuration options
		* @param {Boolean} [options.allowSynchronousEvents=true] Specifies whether
		*     any of the `'message'`, `'ping'`, and `'pong'` events can be emitted
		*     multiple times in the same tick
		* @param {Boolean} [options.autoPong=true] Specifies whether or not to
		*     automatically send a pong in response to a ping
		* @param {Number} [options.backlog=511] The maximum length of the queue of
		*     pending connections
		* @param {Boolean} [options.clientTracking=true] Specifies whether or not to
		*     track clients
		* @param {Function} [options.handleProtocols] A hook to handle protocols
		* @param {String} [options.host] The hostname where to bind the server
		* @param {Number} [options.maxPayload=104857600] The maximum allowed message
		*     size
		* @param {Boolean} [options.noServer=false] Enable no server mode
		* @param {String} [options.path] Accept only connections matching this path
		* @param {(Boolean|Object)} [options.perMessageDeflate=false] Enable/disable
		*     permessage-deflate
		* @param {Number} [options.port] The port where to bind the server
		* @param {(http.Server|https.Server)} [options.server] A pre-created HTTP/S
		*     server to use
		* @param {Boolean} [options.skipUTF8Validation=false] Specifies whether or
		*     not to skip UTF-8 validation for text and close messages
		* @param {Function} [options.verifyClient] A hook to reject connections
		* @param {Function} [options.WebSocket=WebSocket] Specifies the `WebSocket`
		*     class to use. It must be the `WebSocket` class or class that extends it
		* @param {Function} [callback] A listener for the `listening` event
		*/
		constructor(options, callback) {
			super();
			options = {
				allowSynchronousEvents: true,
				autoPong: true,
				maxPayload: 100 * 1024 * 1024,
				skipUTF8Validation: false,
				perMessageDeflate: false,
				handleProtocols: null,
				clientTracking: true,
				verifyClient: null,
				noServer: false,
				backlog: null,
				server: null,
				host: null,
				path: null,
				port: null,
				WebSocket: WebSocket$1,
				...options
			};
			if (options.port == null && !options.server && !options.noServer || options.port != null && (options.server || options.noServer) || options.server && options.noServer) throw new TypeError("One and only one of the \"port\", \"server\", or \"noServer\" options must be specified");
			if (options.port != null) {
				this._server = http.createServer((req, res) => {
					const body = http.STATUS_CODES[426];
					res.writeHead(426, {
						"Content-Length": body.length,
						"Content-Type": "text/plain"
					});
					res.end(body);
				});
				this._server.listen(options.port, options.host, options.backlog, callback);
			} else if (options.server) this._server = options.server;
			if (this._server) {
				const emitConnection = this.emit.bind(this, "connection");
				this._removeListeners = addListeners(this._server, {
					listening: this.emit.bind(this, "listening"),
					error: this.emit.bind(this, "error"),
					upgrade: (req, socket, head) => {
						this.handleUpgrade(req, socket, head, emitConnection);
					}
				});
			}
			if (options.perMessageDeflate === true) options.perMessageDeflate = {};
			if (options.clientTracking) {
				this.clients = /* @__PURE__ */ new Set();
				this._shouldEmitClose = false;
			}
			this.options = options;
			this._state = RUNNING;
		}
		/**
		* Returns the bound address, the address family name, and port of the server
		* as reported by the operating system if listening on an IP socket.
		* If the server is listening on a pipe or UNIX domain socket, the name is
		* returned as a string.
		*
		* @return {(Object|String|null)} The address of the server
		* @public
		*/
		address() {
			if (this.options.noServer) throw new Error("The server is operating in \"noServer\" mode");
			if (!this._server) return null;
			return this._server.address();
		}
		/**
		* Stop the server from accepting new connections and emit the `'close'` event
		* when all existing connections are closed.
		*
		* @param {Function} [cb] A one-time listener for the `'close'` event
		* @public
		*/
		close(cb) {
			if (this._state === CLOSED) {
				if (cb) this.once("close", () => {
					cb(/* @__PURE__ */ new Error("The server is not running"));
				});
				process.nextTick(emitClose, this);
				return;
			}
			if (cb) this.once("close", cb);
			if (this._state === CLOSING) return;
			this._state = CLOSING;
			if (this.options.noServer || this.options.server) {
				if (this._server) {
					this._removeListeners();
					this._removeListeners = this._server = null;
				}
				if (this.clients) if (!this.clients.size) process.nextTick(emitClose, this);
				else this._shouldEmitClose = true;
				else process.nextTick(emitClose, this);
			} else {
				const server = this._server;
				this._removeListeners();
				this._removeListeners = this._server = null;
				server.close(() => {
					emitClose(this);
				});
			}
		}
		/**
		* See if a given request should be handled by this server instance.
		*
		* @param {http.IncomingMessage} req Request object to inspect
		* @return {Boolean} `true` if the request is valid, else `false`
		* @public
		*/
		shouldHandle(req) {
			if (this.options.path) {
				const index = req.url.indexOf("?");
				if ((index !== -1 ? req.url.slice(0, index) : req.url) !== this.options.path) return false;
			}
			return true;
		}
		/**
		* Handle a HTTP Upgrade request.
		*
		* @param {http.IncomingMessage} req The request object
		* @param {Duplex} socket The network socket between the server and client
		* @param {Buffer} head The first packet of the upgraded stream
		* @param {Function} cb Callback
		* @public
		*/
		handleUpgrade(req, socket, head, cb) {
			socket.on("error", socketOnError);
			const key = req.headers["sec-websocket-key"];
			const upgrade = req.headers.upgrade;
			const version = +req.headers["sec-websocket-version"];
			if (req.method !== "GET") {
				abortHandshakeOrEmitwsClientError(this, req, socket, 405, "Invalid HTTP method");
				return;
			}
			if (upgrade === void 0 || upgrade.toLowerCase() !== "websocket") {
				abortHandshakeOrEmitwsClientError(this, req, socket, 400, "Invalid Upgrade header");
				return;
			}
			if (key === void 0 || !keyRegex.test(key)) {
				abortHandshakeOrEmitwsClientError(this, req, socket, 400, "Missing or invalid Sec-WebSocket-Key header");
				return;
			}
			if (version !== 13 && version !== 8) {
				abortHandshakeOrEmitwsClientError(this, req, socket, 400, "Missing or invalid Sec-WebSocket-Version header", { "Sec-WebSocket-Version": "13, 8" });
				return;
			}
			if (!this.shouldHandle(req)) {
				abortHandshake(socket, 400);
				return;
			}
			const secWebSocketProtocol = req.headers["sec-websocket-protocol"];
			let protocols = /* @__PURE__ */ new Set();
			if (secWebSocketProtocol !== void 0) try {
				protocols = subprotocol.parse(secWebSocketProtocol);
			} catch (err) {
				abortHandshakeOrEmitwsClientError(this, req, socket, 400, "Invalid Sec-WebSocket-Protocol header");
				return;
			}
			const secWebSocketExtensions = req.headers["sec-websocket-extensions"];
			const extensions = {};
			if (this.options.perMessageDeflate && secWebSocketExtensions !== void 0) {
				const perMessageDeflate = new PerMessageDeflate(this.options.perMessageDeflate, true, this.options.maxPayload);
				try {
					const offers = extension.parse(secWebSocketExtensions);
					if (offers[PerMessageDeflate.extensionName]) {
						perMessageDeflate.accept(offers[PerMessageDeflate.extensionName]);
						extensions[PerMessageDeflate.extensionName] = perMessageDeflate;
					}
				} catch (err) {
					abortHandshakeOrEmitwsClientError(this, req, socket, 400, "Invalid or unacceptable Sec-WebSocket-Extensions header");
					return;
				}
			}
			if (this.options.verifyClient) {
				const info = {
					origin: req.headers[`${version === 8 ? "sec-websocket-origin" : "origin"}`],
					secure: !!(req.socket.authorized || req.socket.encrypted),
					req
				};
				if (this.options.verifyClient.length === 2) {
					this.options.verifyClient(info, (verified, code, message, headers) => {
						if (!verified) return abortHandshake(socket, code || 401, message, headers);
						this.completeUpgrade(extensions, key, protocols, req, socket, head, cb);
					});
					return;
				}
				if (!this.options.verifyClient(info)) return abortHandshake(socket, 401);
			}
			this.completeUpgrade(extensions, key, protocols, req, socket, head, cb);
		}
		/**
		* Upgrade the connection to WebSocket.
		*
		* @param {Object} extensions The accepted extensions
		* @param {String} key The value of the `Sec-WebSocket-Key` header
		* @param {Set} protocols The subprotocols
		* @param {http.IncomingMessage} req The request object
		* @param {Duplex} socket The network socket between the server and client
		* @param {Buffer} head The first packet of the upgraded stream
		* @param {Function} cb Callback
		* @throws {Error} If called more than once with the same socket
		* @private
		*/
		completeUpgrade(extensions, key, protocols, req, socket, head, cb) {
			if (!socket.readable || !socket.writable) return socket.destroy();
			if (socket[kWebSocket]) throw new Error("server.handleUpgrade() was called more than once with the same socket, possibly due to a misconfiguration");
			if (this._state > RUNNING) return abortHandshake(socket, 503);
			const headers = [
				"HTTP/1.1 101 Switching Protocols",
				"Upgrade: websocket",
				"Connection: Upgrade",
				`Sec-WebSocket-Accept: ${createHash("sha1").update(key + GUID).digest("base64")}`
			];
			const ws = new this.options.WebSocket(null, void 0, this.options);
			if (protocols.size) {
				const protocol = this.options.handleProtocols ? this.options.handleProtocols(protocols, req) : protocols.values().next().value;
				if (protocol) {
					headers.push(`Sec-WebSocket-Protocol: ${protocol}`);
					ws._protocol = protocol;
				}
			}
			if (extensions[PerMessageDeflate.extensionName]) {
				const params = extensions[PerMessageDeflate.extensionName].params;
				const value = extension.format({ [PerMessageDeflate.extensionName]: [params] });
				headers.push(`Sec-WebSocket-Extensions: ${value}`);
				ws._extensions = extensions;
			}
			this.emit("headers", headers, req);
			socket.write(headers.concat("\r\n").join("\r\n"));
			socket.removeListener("error", socketOnError);
			ws.setSocket(socket, head, {
				allowSynchronousEvents: this.options.allowSynchronousEvents,
				maxPayload: this.options.maxPayload,
				skipUTF8Validation: this.options.skipUTF8Validation
			});
			if (this.clients) {
				this.clients.add(ws);
				ws.on("close", () => {
					this.clients.delete(ws);
					if (this._shouldEmitClose && !this.clients.size) process.nextTick(emitClose, this);
				});
			}
			cb(ws, req);
		}
	};
	module.exports = WebSocketServer$1;
	/**
	* Add event listeners on an `EventEmitter` using a map of <event, listener>
	* pairs.
	*
	* @param {EventEmitter} server The event emitter
	* @param {Object.<String, Function>} map The listeners to add
	* @return {Function} A function that will remove the added listeners when
	*     called
	* @private
	*/
	function addListeners(server, map) {
		for (const event of Object.keys(map)) server.on(event, map[event]);
		return function removeListeners() {
			for (const event of Object.keys(map)) server.removeListener(event, map[event]);
		};
	}
	/**
	* Emit a `'close'` event on an `EventEmitter`.
	*
	* @param {EventEmitter} server The event emitter
	* @private
	*/
	function emitClose(server) {
		server._state = CLOSED;
		server.emit("close");
	}
	/**
	* Handle socket errors.
	*
	* @private
	*/
	function socketOnError() {
		this.destroy();
	}
	/**
	* Close the connection when preconditions are not fulfilled.
	*
	* @param {Duplex} socket The socket of the upgrade request
	* @param {Number} code The HTTP response status code
	* @param {String} [message] The HTTP response body
	* @param {Object} [headers] Additional HTTP response headers
	* @private
	*/
	function abortHandshake(socket, code, message, headers) {
		message = message || http.STATUS_CODES[code];
		headers = {
			Connection: "close",
			"Content-Type": "text/html",
			"Content-Length": Buffer.byteLength(message),
			...headers
		};
		socket.once("finish", socket.destroy);
		socket.end(`HTTP/1.1 ${code} ${http.STATUS_CODES[code]}\r\n` + Object.keys(headers).map((h) => `${h}: ${headers[h]}`).join("\r\n") + "\r\n\r\n" + message);
	}
	/**
	* Emit a `'wsClientError'` event on a `WebSocketServer` if there is at least
	* one listener for it, otherwise call `abortHandshake()`.
	*
	* @param {WebSocketServer} server The WebSocket server
	* @param {http.IncomingMessage} req The request object
	* @param {Duplex} socket The socket of the upgrade request
	* @param {Number} code The HTTP response status code
	* @param {String} message The HTTP response body
	* @param {Object} [headers] The HTTP response headers
	* @private
	*/
	function abortHandshakeOrEmitwsClientError(server, req, socket, code, message, headers) {
		if (server.listenerCount("wsClientError")) {
			const err = new Error(message);
			Error.captureStackTrace(err, abortHandshakeOrEmitwsClientError);
			server.emit("wsClientError", err, socket, req);
		} else abortHandshake(socket, code, message, headers);
	}
}) });

//#endregion
//#region node_modules/ws/wrapper.mjs
var import_stream, import_receiver, import_sender, import_websocket, import_websocket_server, wrapper_default;
var init_wrapper = __esm({ "node_modules/ws/wrapper.mjs": (() => {
	import_stream = /* @__PURE__ */ __toESM(require_stream(), 1);
	import_receiver = /* @__PURE__ */ __toESM(require_receiver(), 1);
	import_sender = /* @__PURE__ */ __toESM(require_sender(), 1);
	import_websocket = /* @__PURE__ */ __toESM(require_websocket(), 1);
	import_websocket_server = /* @__PURE__ */ __toESM(require_websocket_server(), 1);
	wrapper_default = import_websocket.default;
}) });

//#endregion
//#region node_modules/ink/build/devtools-window-polyfill.js
var customGlobal;
var init_devtools_window_polyfill = __esm({ "node_modules/ink/build/devtools-window-polyfill.js": (() => {
	init_wrapper();
	customGlobal = global;
	customGlobal.WebSocket ||= wrapper_default;
	customGlobal.window ||= global;
	customGlobal.self ||= global;
	customGlobal.window.__REACT_DEVTOOLS_COMPONENT_FILTERS__ = [
		{
			type: 1,
			value: 7,
			isEnabled: true
		},
		{
			type: 2,
			value: "InternalApp",
			isEnabled: true,
			isValid: true
		},
		{
			type: 2,
			value: "InternalAppContext",
			isEnabled: true,
			isValid: true
		},
		{
			type: 2,
			value: "InternalStdoutContext",
			isEnabled: true,
			isValid: true
		},
		{
			type: 2,
			value: "InternalStderrContext",
			isEnabled: true,
			isValid: true
		},
		{
			type: 2,
			value: "InternalStdinContext",
			isEnabled: true,
			isValid: true
		},
		{
			type: 2,
			value: "InternalFocusContext",
			isEnabled: true,
			isValid: true
		}
	];
}) });

//#endregion
//#region src/stubs/react-devtools-core.ts
var initialize, connectToDevTools, react_devtools_core_default;
var init_react_devtools_core = __esm({ "src/stubs/react-devtools-core.ts": (() => {
	initialize = () => {};
	connectToDevTools = () => {};
	react_devtools_core_default = {
		initialize,
		connectToDevTools
	};
}) });

//#endregion
//#region node_modules/ink/build/devtools.js
var devtools_exports = {};
var init_devtools = __esm({ "node_modules/ink/build/devtools.js": (() => {
	init_devtools_window_polyfill();
	init_react_devtools_core();
	react_devtools_core_default.initialize();
	react_devtools_core_default.connectToDevTools();
}) });

//#endregion
//#region node_modules/ink/build/reconciler.js
if (process$1.env["DEV"] === "true") try {
	await Promise.resolve().then(() => (init_devtools(), devtools_exports));
} catch (error) {
	if (error.code === "ERR_MODULE_NOT_FOUND") console.warn(`
The environment variable DEV is set to true, so Ink tried to import \`react-devtools-core\`,
but this failed as it was not installed. Debugging with React Devtools requires it.

To install use this command:

$ npm install --save-dev react-devtools-core
				`.trim() + "\n");
	else throw error;
}
const diff = (before, after) => {
	if (before === after) return;
	if (!before) return after;
	const changed = {};
	let isChanged = false;
	for (const key of Object.keys(before)) if (after ? !Object.hasOwn(after, key) : true) {
		changed[key] = void 0;
		isChanged = true;
	}
	if (after) {
		for (const key of Object.keys(after)) if (after[key] !== before[key]) {
			changed[key] = after[key];
			isChanged = true;
		}
	}
	return isChanged ? changed : void 0;
};
const cleanupYogaNode = (node) => {
	node?.unsetMeasureFunc();
	node?.freeRecursive();
};
let currentUpdatePriority = import_constants$1.NoEventPriority;
let currentRootNode;
var reconciler_default = (0, import_react_reconciler.default)({
	getRootHostContext: () => ({ isInsideText: false }),
	prepareForCommit: () => null,
	preparePortalMount: () => null,
	clearContainer: () => false,
	resetAfterCommit(rootNode) {
		if (typeof rootNode.onComputeLayout === "function") rootNode.onComputeLayout();
		if (rootNode.isStaticDirty) {
			rootNode.isStaticDirty = false;
			if (typeof rootNode.onImmediateRender === "function") rootNode.onImmediateRender();
			return;
		}
		if (typeof rootNode.onRender === "function") rootNode.onRender();
	},
	getChildHostContext(parentHostContext, type) {
		const previousIsInsideText = parentHostContext.isInsideText;
		const isInsideText = type === "ink-text" || type === "ink-virtual-text";
		if (previousIsInsideText === isInsideText) return parentHostContext;
		return { isInsideText };
	},
	shouldSetTextContent: () => false,
	createInstance(originalType, newProps, rootNode, hostContext) {
		if (hostContext.isInsideText && originalType === "ink-box") throw new Error(`<Box> cant be nested inside <Text> component`);
		const node = createNode(originalType === "ink-text" && hostContext.isInsideText ? "ink-virtual-text" : originalType);
		for (const [key, value] of Object.entries(newProps)) {
			if (key === "children") continue;
			if (key === "style") {
				setStyle(node, value);
				if (node.yogaNode) styles_default(node.yogaNode, value);
				continue;
			}
			if (key === "internal_transform") {
				node.internal_transform = value;
				continue;
			}
			if (key === "internal_static") {
				currentRootNode = rootNode;
				node.internal_static = true;
				rootNode.isStaticDirty = true;
				rootNode.staticNode = node;
				continue;
			}
			setAttribute(node, key, value);
		}
		return node;
	},
	createTextInstance(text, _root, hostContext) {
		if (!hostContext.isInsideText) throw new Error(`Text string "${text}" must be rendered inside <Text> component`);
		return createTextNode(text);
	},
	resetTextContent() {},
	hideTextInstance(node) {
		setTextNodeValue(node, "");
	},
	unhideTextInstance(node, text) {
		setTextNodeValue(node, text);
	},
	getPublicInstance: (instance) => instance,
	hideInstance(node) {
		node.yogaNode?.setDisplay(src_default.DISPLAY_NONE);
	},
	unhideInstance(node) {
		node.yogaNode?.setDisplay(src_default.DISPLAY_FLEX);
	},
	appendInitialChild: appendChildNode,
	appendChild: appendChildNode,
	insertBefore: insertBeforeNode,
	finalizeInitialChildren() {
		return false;
	},
	isPrimaryRenderer: true,
	supportsMutation: true,
	supportsPersistence: false,
	supportsHydration: false,
	scheduleTimeout: setTimeout,
	cancelTimeout: clearTimeout,
	noTimeout: -1,
	beforeActiveInstanceBlur() {},
	afterActiveInstanceBlur() {},
	detachDeletedInstance() {},
	getInstanceFromNode: () => null,
	prepareScopeUpdate() {},
	getInstanceFromScope: () => null,
	appendChildToContainer: appendChildNode,
	insertInContainerBefore: insertBeforeNode,
	removeChildFromContainer(node, removeNode) {
		removeChildNode(node, removeNode);
		cleanupYogaNode(removeNode.yogaNode);
	},
	commitUpdate(node, _type, oldProps, newProps) {
		if (currentRootNode && node.internal_static) currentRootNode.isStaticDirty = true;
		const props = diff(oldProps, newProps);
		const style = diff(oldProps["style"], newProps["style"]);
		if (!props && !style) return;
		if (props) for (const [key, value] of Object.entries(props)) {
			if (key === "style") {
				setStyle(node, value);
				continue;
			}
			if (key === "internal_transform") {
				node.internal_transform = value;
				continue;
			}
			if (key === "internal_static") {
				node.internal_static = true;
				continue;
			}
			setAttribute(node, key, value);
		}
		if (style && node.yogaNode) styles_default(node.yogaNode, style);
	},
	commitTextUpdate(node, _oldText, newText) {
		setTextNodeValue(node, newText);
	},
	removeChild(node, removeNode) {
		removeChildNode(node, removeNode);
		cleanupYogaNode(removeNode.yogaNode);
	},
	setCurrentUpdatePriority(newPriority) {
		currentUpdatePriority = newPriority;
	},
	getCurrentUpdatePriority: () => currentUpdatePriority,
	resolveUpdatePriority() {
		if (currentUpdatePriority !== import_constants$1.NoEventPriority) return currentUpdatePriority;
		return import_constants$1.DefaultEventPriority;
	},
	maySuspendCommit() {
		return false;
	},
	NotPendingTransition: void 0,
	HostTransitionContext: (0, import_react.createContext)(null),
	resetFormInstance() {},
	requestPostPaintCallback() {},
	shouldAttemptEagerTransition() {
		return false;
	},
	trackSchedulerEvent() {},
	resolveEventType() {
		return null;
	},
	resolveEventTimeStamp() {
		return -1.1;
	},
	preloadInstance() {
		return true;
	},
	startSuspendingCommit() {},
	suspendInstance() {},
	waitForCommitToBeReady() {
		return null;
	}
});

//#endregion
//#region node_modules/indent-string/index.js
function indentString$1(string, count = 1, options = {}) {
	const { indent = " ", includeEmptyLines = false } = options;
	if (typeof string !== "string") throw new TypeError(`Expected \`input\` to be a \`string\`, got \`${typeof string}\``);
	if (typeof count !== "number") throw new TypeError(`Expected \`count\` to be a \`number\`, got \`${typeof count}\``);
	if (count < 0) throw new RangeError(`Expected \`count\` to be at least 0, got \`${count}\``);
	if (typeof indent !== "string") throw new TypeError(`Expected \`options.indent\` to be a \`string\`, got \`${typeof indent}\``);
	if (count === 0) return string;
	const regex$1 = includeEmptyLines ? /^/gm : /^(?!\s*$)/gm;
	return string.replace(regex$1, indent.repeat(count));
}

//#endregion
//#region node_modules/ink/build/get-max-width.js
const getMaxWidth = (yogaNode) => {
	return yogaNode.getComputedWidth() - yogaNode.getComputedPadding(src_default.EDGE_LEFT) - yogaNode.getComputedPadding(src_default.EDGE_RIGHT) - yogaNode.getComputedBorder(src_default.EDGE_LEFT) - yogaNode.getComputedBorder(src_default.EDGE_RIGHT);
};
var get_max_width_default = getMaxWidth;

//#endregion
//#region node_modules/cli-boxes/boxes.json
var require_boxes = /* @__PURE__ */ __commonJS({ "node_modules/cli-boxes/boxes.json": ((exports, module) => {
	module.exports = {
		"single": {
			"topLeft": "",
			"top": "",
			"topRight": "",
			"right": "",
			"bottomRight": "",
			"bottom": "",
			"bottomLeft": "",
			"left": ""
		},
		"double": {
			"topLeft": "",
			"top": "",
			"topRight": "",
			"right": "",
			"bottomRight": "",
			"bottom": "",
			"bottomLeft": "",
			"left": ""
		},
		"round": {
			"topLeft": "",
			"top": "",
			"topRight": "",
			"right": "",
			"bottomRight": "",
			"bottom": "",
			"bottomLeft": "",
			"left": ""
		},
		"bold": {
			"topLeft": "",
			"top": "",
			"topRight": "",
			"right": "",
			"bottomRight": "",
			"bottom": "",
			"bottomLeft": "",
			"left": ""
		},
		"singleDouble": {
			"topLeft": "",
			"top": "",
			"topRight": "",
			"right": "",
			"bottomRight": "",
			"bottom": "",
			"bottomLeft": "",
			"left": ""
		},
		"doubleSingle": {
			"topLeft": "",
			"top": "",
			"topRight": "",
			"right": "",
			"bottomRight": "",
			"bottom": "",
			"bottomLeft": "",
			"left": ""
		},
		"classic": {
			"topLeft": "+",
			"top": "-",
			"topRight": "+",
			"right": "|",
			"bottomRight": "+",
			"bottom": "-",
			"bottomLeft": "+",
			"left": "|"
		},
		"arrow": {
			"topLeft": "",
			"top": "",
			"topRight": "",
			"right": "",
			"bottomRight": "",
			"bottom": "",
			"bottomLeft": "",
			"left": ""
		}
	};
}) });

//#endregion
//#region node_modules/cli-boxes/index.js
var require_cli_boxes = /* @__PURE__ */ __commonJS({ "node_modules/cli-boxes/index.js": ((exports, module) => {
	const cliBoxes$1 = require_boxes();
	module.exports = cliBoxes$1;
	module.exports.default = cliBoxes$1;
}) });

//#endregion
//#region node_modules/chalk/source/vendor/ansi-styles/index.js
var import_cli_boxes = /* @__PURE__ */ __toESM(require_cli_boxes(), 1);
const ANSI_BACKGROUND_OFFSET = 10;
const wrapAnsi16 = (offset = 0) => (code) => `\u001B[${code + offset}m`;
const wrapAnsi256 = (offset = 0) => (code) => `\u001B[${38 + offset};5;${code}m`;
const wrapAnsi16m = (offset = 0) => (red, green, blue) => `\u001B[${38 + offset};2;${red};${green};${blue}m`;
const styles$1 = {
	modifier: {
		reset: [0, 0],
		bold: [1, 22],
		dim: [2, 22],
		italic: [3, 23],
		underline: [4, 24],
		overline: [53, 55],
		inverse: [7, 27],
		hidden: [8, 28],
		strikethrough: [9, 29]
	},
	color: {
		black: [30, 39],
		red: [31, 39],
		green: [32, 39],
		yellow: [33, 39],
		blue: [34, 39],
		magenta: [35, 39],
		cyan: [36, 39],
		white: [37, 39],
		blackBright: [90, 39],
		gray: [90, 39],
		grey: [90, 39],
		redBright: [91, 39],
		greenBright: [92, 39],
		yellowBright: [93, 39],
		blueBright: [94, 39],
		magentaBright: [95, 39],
		cyanBright: [96, 39],
		whiteBright: [97, 39]
	},
	bgColor: {
		bgBlack: [40, 49],
		bgRed: [41, 49],
		bgGreen: [42, 49],
		bgYellow: [43, 49],
		bgBlue: [44, 49],
		bgMagenta: [45, 49],
		bgCyan: [46, 49],
		bgWhite: [47, 49],
		bgBlackBright: [100, 49],
		bgGray: [100, 49],
		bgGrey: [100, 49],
		bgRedBright: [101, 49],
		bgGreenBright: [102, 49],
		bgYellowBright: [103, 49],
		bgBlueBright: [104, 49],
		bgMagentaBright: [105, 49],
		bgCyanBright: [106, 49],
		bgWhiteBright: [107, 49]
	}
};
const modifierNames = Object.keys(styles$1.modifier);
const foregroundColorNames = Object.keys(styles$1.color);
const backgroundColorNames = Object.keys(styles$1.bgColor);
const colorNames = [...foregroundColorNames, ...backgroundColorNames];
function assembleStyles() {
	const codes = /* @__PURE__ */ new Map();
	for (const [groupName, group] of Object.entries(styles$1)) {
		for (const [styleName, style] of Object.entries(group)) {
			styles$1[styleName] = {
				open: `\u001B[${style[0]}m`,
				close: `\u001B[${style[1]}m`
			};
			group[styleName] = styles$1[styleName];
			codes.set(style[0], style[1]);
		}
		Object.defineProperty(styles$1, groupName, {
			value: group,
			enumerable: false
		});
	}
	Object.defineProperty(styles$1, "codes", {
		value: codes,
		enumerable: false
	});
	styles$1.color.close = "\x1B[39m";
	styles$1.bgColor.close = "\x1B[49m";
	styles$1.color.ansi = wrapAnsi16();
	styles$1.color.ansi256 = wrapAnsi256();
	styles$1.color.ansi16m = wrapAnsi16m();
	styles$1.bgColor.ansi = wrapAnsi16(ANSI_BACKGROUND_OFFSET);
	styles$1.bgColor.ansi256 = wrapAnsi256(ANSI_BACKGROUND_OFFSET);
	styles$1.bgColor.ansi16m = wrapAnsi16m(ANSI_BACKGROUND_OFFSET);
	Object.defineProperties(styles$1, {
		rgbToAnsi256: {
			value(red, green, blue) {
				if (red === green && green === blue) {
					if (red < 8) return 16;
					if (red > 248) return 231;
					return Math.round((red - 8) / 247 * 24) + 232;
				}
				return 16 + 36 * Math.round(red / 255 * 5) + 6 * Math.round(green / 255 * 5) + Math.round(blue / 255 * 5);
			},
			enumerable: false
		},
		hexToRgb: {
			value(hex) {
				const matches = /[a-f\d]{6}|[a-f\d]{3}/i.exec(hex.toString(16));
				if (!matches) return [
					0,
					0,
					0
				];
				let [colorString] = matches;
				if (colorString.length === 3) colorString = [...colorString].map((character) => character + character).join("");
				const integer = Number.parseInt(colorString, 16);
				return [
					integer >> 16 & 255,
					integer >> 8 & 255,
					integer & 255
				];
			},
			enumerable: false
		},
		hexToAnsi256: {
			value: (hex) => styles$1.rgbToAnsi256(...styles$1.hexToRgb(hex)),
			enumerable: false
		},
		ansi256ToAnsi: {
			value(code) {
				if (code < 8) return 30 + code;
				if (code < 16) return 90 + (code - 8);
				let red;
				let green;
				let blue;
				if (code >= 232) {
					red = ((code - 232) * 10 + 8) / 255;
					green = red;
					blue = red;
				} else {
					code -= 16;
					const remainder = code % 36;
					red = Math.floor(code / 36) / 5;
					green = Math.floor(remainder / 6) / 5;
					blue = remainder % 6 / 5;
				}
				const value = Math.max(red, green, blue) * 2;
				if (value === 0) return 30;
				let result = 30 + (Math.round(blue) << 2 | Math.round(green) << 1 | Math.round(red));
				if (value === 2) result += 60;
				return result;
			},
			enumerable: false
		},
		rgbToAnsi: {
			value: (red, green, blue) => styles$1.ansi256ToAnsi(styles$1.rgbToAnsi256(red, green, blue)),
			enumerable: false
		},
		hexToAnsi: {
			value: (hex) => styles$1.ansi256ToAnsi(styles$1.hexToAnsi256(hex)),
			enumerable: false
		}
	});
	return styles$1;
}
const ansiStyles = assembleStyles();
var ansi_styles_default$1 = ansiStyles;

//#endregion
//#region node_modules/chalk/source/vendor/supports-color/index.js
function hasFlag(flag, argv$1 = globalThis.Deno ? globalThis.Deno.args : process$1.argv) {
	const prefix = flag.startsWith("-") ? "" : flag.length === 1 ? "-" : "--";
	const position = argv$1.indexOf(prefix + flag);
	const terminatorPosition = argv$1.indexOf("--");
	return position !== -1 && (terminatorPosition === -1 || position < terminatorPosition);
}
const { env: env$2 } = process$1;
let flagForceColor;
if (hasFlag("no-color") || hasFlag("no-colors") || hasFlag("color=false") || hasFlag("color=never")) flagForceColor = 0;
else if (hasFlag("color") || hasFlag("colors") || hasFlag("color=true") || hasFlag("color=always")) flagForceColor = 1;
function envForceColor() {
	if ("FORCE_COLOR" in env$2) {
		if (env$2.FORCE_COLOR === "true") return 1;
		if (env$2.FORCE_COLOR === "false") return 0;
		return env$2.FORCE_COLOR.length === 0 ? 1 : Math.min(Number.parseInt(env$2.FORCE_COLOR, 10), 3);
	}
}
function translateLevel(level) {
	if (level === 0) return false;
	return {
		level,
		hasBasic: true,
		has256: level >= 2,
		has16m: level >= 3
	};
}
function _supportsColor(haveStream, { streamIsTTY, sniffFlags = true } = {}) {
	const noFlagForceColor = envForceColor();
	if (noFlagForceColor !== void 0) flagForceColor = noFlagForceColor;
	const forceColor = sniffFlags ? flagForceColor : noFlagForceColor;
	if (forceColor === 0) return 0;
	if (sniffFlags) {
		if (hasFlag("color=16m") || hasFlag("color=full") || hasFlag("color=truecolor")) return 3;
		if (hasFlag("color=256")) return 2;
	}
	if ("TF_BUILD" in env$2 && "AGENT_NAME" in env$2) return 1;
	if (haveStream && !streamIsTTY && forceColor === void 0) return 0;
	const min = forceColor || 0;
	if (env$2.TERM === "dumb") return min;
	if (process$1.platform === "win32") {
		const osRelease = os.release().split(".");
		if (Number(osRelease[0]) >= 10 && Number(osRelease[2]) >= 10586) return Number(osRelease[2]) >= 14931 ? 3 : 2;
		return 1;
	}
	if ("CI" in env$2) {
		if ([
			"GITHUB_ACTIONS",
			"GITEA_ACTIONS",
			"CIRCLECI"
		].some((key) => key in env$2)) return 3;
		if ([
			"TRAVIS",
			"APPVEYOR",
			"GITLAB_CI",
			"BUILDKITE",
			"DRONE"
		].some((sign) => sign in env$2) || env$2.CI_NAME === "codeship") return 1;
		return min;
	}
	if ("TEAMCITY_VERSION" in env$2) return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(env$2.TEAMCITY_VERSION) ? 1 : 0;
	if (env$2.COLORTERM === "truecolor") return 3;
	if (env$2.TERM === "xterm-kitty") return 3;
	if (env$2.TERM === "xterm-ghostty") return 3;
	if (env$2.TERM === "wezterm") return 3;
	if ("TERM_PROGRAM" in env$2) {
		const version = Number.parseInt((env$2.TERM_PROGRAM_VERSION || "").split(".")[0], 10);
		switch (env$2.TERM_PROGRAM) {
			case "iTerm.app": return version >= 3 ? 3 : 2;
			case "Apple_Terminal": return 2;
		}
	}
	if (/-256(color)?$/i.test(env$2.TERM)) return 2;
	if (/^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(env$2.TERM)) return 1;
	if ("COLORTERM" in env$2) return 1;
	return min;
}
function createSupportsColor(stream, options = {}) {
	return translateLevel(_supportsColor(stream, {
		streamIsTTY: stream && stream.isTTY,
		...options
	}));
}
const supportsColor = {
	stdout: createSupportsColor({ isTTY: tty.isatty(1) }),
	stderr: createSupportsColor({ isTTY: tty.isatty(2) })
};
var supports_color_default = supportsColor;

//#endregion
//#region node_modules/chalk/source/utilities.js
function stringReplaceAll(string, substring, replacer) {
	let index = string.indexOf(substring);
	if (index === -1) return string;
	const substringLength = substring.length;
	let endIndex = 0;
	let returnValue = "";
	do {
		returnValue += string.slice(endIndex, index) + substring + replacer;
		endIndex = index + substringLength;
		index = string.indexOf(substring, endIndex);
	} while (index !== -1);
	returnValue += string.slice(endIndex);
	return returnValue;
}
function stringEncaseCRLFWithFirstIndex(string, prefix, postfix, index) {
	let endIndex = 0;
	let returnValue = "";
	do {
		const gotCR = string[index - 1] === "\r";
		returnValue += string.slice(endIndex, gotCR ? index - 1 : index) + prefix + (gotCR ? "\r\n" : "\n") + postfix;
		endIndex = index + 1;
		index = string.indexOf("\n", endIndex);
	} while (index !== -1);
	returnValue += string.slice(endIndex);
	return returnValue;
}

//#endregion
//#region node_modules/chalk/source/index.js
const { stdout: stdoutColor, stderr: stderrColor } = supports_color_default;
const GENERATOR = Symbol("GENERATOR");
const STYLER = Symbol("STYLER");
const IS_EMPTY = Symbol("IS_EMPTY");
const levelMapping = [
	"ansi",
	"ansi",
	"ansi256",
	"ansi16m"
];
const styles = Object.create(null);
const applyOptions = (object, options = {}) => {
	if (options.level && !(Number.isInteger(options.level) && options.level >= 0 && options.level <= 3)) throw new Error("The `level` option should be an integer from 0 to 3");
	const colorLevel = stdoutColor ? stdoutColor.level : 0;
	object.level = options.level === void 0 ? colorLevel : options.level;
};
const chalkFactory = (options) => {
	const chalk$1 = (...strings) => strings.join(" ");
	applyOptions(chalk$1, options);
	Object.setPrototypeOf(chalk$1, createChalk.prototype);
	return chalk$1;
};
function createChalk(options) {
	return chalkFactory(options);
}
Object.setPrototypeOf(createChalk.prototype, Function.prototype);
for (const [styleName, style] of Object.entries(ansi_styles_default$1)) styles[styleName] = { get() {
	const builder = createBuilder(this, createStyler(style.open, style.close, this[STYLER]), this[IS_EMPTY]);
	Object.defineProperty(this, styleName, { value: builder });
	return builder;
} };
styles.visible = { get() {
	const builder = createBuilder(this, this[STYLER], true);
	Object.defineProperty(this, "visible", { value: builder });
	return builder;
} };
const getModelAnsi = (model, level, type, ...arguments_) => {
	if (model === "rgb") {
		if (level === "ansi16m") return ansi_styles_default$1[type].ansi16m(...arguments_);
		if (level === "ansi256") return ansi_styles_default$1[type].ansi256(ansi_styles_default$1.rgbToAnsi256(...arguments_));
		return ansi_styles_default$1[type].ansi(ansi_styles_default$1.rgbToAnsi(...arguments_));
	}
	if (model === "hex") return getModelAnsi("rgb", level, type, ...ansi_styles_default$1.hexToRgb(...arguments_));
	return ansi_styles_default$1[type][model](...arguments_);
};
for (const model of [
	"rgb",
	"hex",
	"ansi256"
]) {
	styles[model] = { get() {
		const { level } = this;
		return function(...arguments_) {
			const styler = createStyler(getModelAnsi(model, levelMapping[level], "color", ...arguments_), ansi_styles_default$1.color.close, this[STYLER]);
			return createBuilder(this, styler, this[IS_EMPTY]);
		};
	} };
	const bgModel = "bg" + model[0].toUpperCase() + model.slice(1);
	styles[bgModel] = { get() {
		const { level } = this;
		return function(...arguments_) {
			const styler = createStyler(getModelAnsi(model, levelMapping[level], "bgColor", ...arguments_), ansi_styles_default$1.bgColor.close, this[STYLER]);
			return createBuilder(this, styler, this[IS_EMPTY]);
		};
	} };
}
const proto = Object.defineProperties(() => {}, {
	...styles,
	level: {
		enumerable: true,
		get() {
			return this[GENERATOR].level;
		},
		set(level) {
			this[GENERATOR].level = level;
		}
	}
});
const createStyler = (open, close, parent) => {
	let openAll;
	let closeAll;
	if (parent === void 0) {
		openAll = open;
		closeAll = close;
	} else {
		openAll = parent.openAll + open;
		closeAll = close + parent.closeAll;
	}
	return {
		open,
		close,
		openAll,
		closeAll,
		parent
	};
};
const createBuilder = (self, _styler, _isEmpty) => {
	const builder = (...arguments_) => applyStyle(builder, arguments_.length === 1 ? "" + arguments_[0] : arguments_.join(" "));
	Object.setPrototypeOf(builder, proto);
	builder[GENERATOR] = self;
	builder[STYLER] = _styler;
	builder[IS_EMPTY] = _isEmpty;
	return builder;
};
const applyStyle = (self, string) => {
	if (self.level <= 0 || !string) return self[IS_EMPTY] ? "" : string;
	let styler = self[STYLER];
	if (styler === void 0) return string;
	const { openAll, closeAll } = styler;
	if (string.includes("\x1B")) while (styler !== void 0) {
		string = stringReplaceAll(string, styler.close, styler.open);
		styler = styler.parent;
	}
	const lfIndex = string.indexOf("\n");
	if (lfIndex !== -1) string = stringEncaseCRLFWithFirstIndex(string, closeAll, openAll, lfIndex);
	return openAll + string + closeAll;
};
Object.defineProperties(createChalk.prototype, styles);
const chalk = createChalk();
const chalkStderr = createChalk({ level: stderrColor ? stderrColor.level : 0 });
var source_default = chalk;

//#endregion
//#region node_modules/ink/build/colorize.js
const rgbRegex = /^rgb\(\s?(\d+),\s?(\d+),\s?(\d+)\s?\)$/;
const ansiRegex = /^ansi256\(\s?(\d+)\s?\)$/;
const isNamedColor = (color) => {
	return color in source_default;
};
const colorize = (str, color, type) => {
	if (!color) return str;
	if (isNamedColor(color)) {
		if (type === "foreground") return source_default[color](str);
		return source_default[`bg${color[0].toUpperCase() + color.slice(1)}`](str);
	}
	if (color.startsWith("#")) return type === "foreground" ? source_default.hex(color)(str) : source_default.bgHex(color)(str);
	if (color.startsWith("ansi256")) {
		const matches = ansiRegex.exec(color);
		if (!matches) return str;
		const value = Number(matches[1]);
		return type === "foreground" ? source_default.ansi256(value)(str) : source_default.bgAnsi256(value)(str);
	}
	if (color.startsWith("rgb")) {
		const matches = rgbRegex.exec(color);
		if (!matches) return str;
		const firstValue = Number(matches[1]);
		const secondValue = Number(matches[2]);
		const thirdValue = Number(matches[3]);
		return type === "foreground" ? source_default.rgb(firstValue, secondValue, thirdValue)(str) : source_default.bgRgb(firstValue, secondValue, thirdValue)(str);
	}
	return str;
};
var colorize_default = colorize;

//#endregion
//#region node_modules/ink/build/render-border.js
const renderBorder = (x, y, node, output) => {
	if (node.style.borderStyle) {
		const width = node.yogaNode.getComputedWidth();
		const height = node.yogaNode.getComputedHeight();
		const box = typeof node.style.borderStyle === "string" ? import_cli_boxes.default[node.style.borderStyle] : node.style.borderStyle;
		const topBorderColor = node.style.borderTopColor ?? node.style.borderColor;
		const bottomBorderColor = node.style.borderBottomColor ?? node.style.borderColor;
		const leftBorderColor = node.style.borderLeftColor ?? node.style.borderColor;
		const rightBorderColor = node.style.borderRightColor ?? node.style.borderColor;
		const dimTopBorderColor = node.style.borderTopDimColor ?? node.style.borderDimColor;
		const dimBottomBorderColor = node.style.borderBottomDimColor ?? node.style.borderDimColor;
		const dimLeftBorderColor = node.style.borderLeftDimColor ?? node.style.borderDimColor;
		const dimRightBorderColor = node.style.borderRightDimColor ?? node.style.borderDimColor;
		const showTopBorder = node.style.borderTop !== false;
		const showBottomBorder = node.style.borderBottom !== false;
		const showLeftBorder = node.style.borderLeft !== false;
		const showRightBorder = node.style.borderRight !== false;
		const contentWidth = width - (showLeftBorder ? 1 : 0) - (showRightBorder ? 1 : 0);
		let topBorder = showTopBorder ? colorize_default((showLeftBorder ? box.topLeft : "") + box.top.repeat(contentWidth) + (showRightBorder ? box.topRight : ""), topBorderColor, "foreground") : void 0;
		if (showTopBorder && dimTopBorderColor) topBorder = source_default.dim(topBorder);
		let verticalBorderHeight = height;
		if (showTopBorder) verticalBorderHeight -= 1;
		if (showBottomBorder) verticalBorderHeight -= 1;
		let leftBorder = (colorize_default(box.left, leftBorderColor, "foreground") + "\n").repeat(verticalBorderHeight);
		if (dimLeftBorderColor) leftBorder = source_default.dim(leftBorder);
		let rightBorder = (colorize_default(box.right, rightBorderColor, "foreground") + "\n").repeat(verticalBorderHeight);
		if (dimRightBorderColor) rightBorder = source_default.dim(rightBorder);
		let bottomBorder = showBottomBorder ? colorize_default((showLeftBorder ? box.bottomLeft : "") + box.bottom.repeat(contentWidth) + (showRightBorder ? box.bottomRight : ""), bottomBorderColor, "foreground") : void 0;
		if (showBottomBorder && dimBottomBorderColor) bottomBorder = source_default.dim(bottomBorder);
		const offsetY = showTopBorder ? 1 : 0;
		if (topBorder) output.write(x, y, topBorder, { transformers: [] });
		if (showLeftBorder) output.write(x, y + offsetY, leftBorder, { transformers: [] });
		if (showRightBorder) output.write(x + width - 1, y + offsetY, rightBorder, { transformers: [] });
		if (bottomBorder) output.write(x, y + height - 1, bottomBorder, { transformers: [] });
	}
};
var render_border_default = renderBorder;

//#endregion
//#region node_modules/ink/build/render-background.js
const renderBackground = (x, y, node, output) => {
	if (!node.style.backgroundColor) return;
	const width = node.yogaNode.getComputedWidth();
	const height = node.yogaNode.getComputedHeight();
	const leftBorderWidth = node.style.borderStyle && node.style.borderLeft !== false ? 1 : 0;
	const rightBorderWidth = node.style.borderStyle && node.style.borderRight !== false ? 1 : 0;
	const topBorderHeight = node.style.borderStyle && node.style.borderTop !== false ? 1 : 0;
	const bottomBorderHeight = node.style.borderStyle && node.style.borderBottom !== false ? 1 : 0;
	const contentWidth = width - leftBorderWidth - rightBorderWidth;
	const contentHeight = height - topBorderHeight - bottomBorderHeight;
	if (!(contentWidth > 0 && contentHeight > 0)) return;
	const backgroundLine = colorize_default(" ".repeat(contentWidth), node.style.backgroundColor, "background");
	for (let row = 0; row < contentHeight; row++) output.write(x + leftBorderWidth, y + topBorderHeight + row, backgroundLine, { transformers: [] });
};
var render_background_default = renderBackground;

//#endregion
//#region node_modules/ink/build/render-node-to-output.js
const applyPaddingToText = (node, text) => {
	const yogaNode = node.childNodes[0]?.yogaNode;
	if (yogaNode) {
		const offsetX = yogaNode.getComputedLeft();
		const offsetY = yogaNode.getComputedTop();
		text = "\n".repeat(offsetY) + indentString$1(text, offsetX);
	}
	return text;
};
const renderNodeToScreenReaderOutput = (node, options = {}) => {
	if (options.skipStaticElements && node.internal_static) return "";
	if (node.yogaNode?.getDisplay() === src_default.DISPLAY_NONE) return "";
	let output = "";
	if (node.nodeName === "ink-text") output = squash_text_nodes_default(node);
	else if (node.nodeName === "ink-box" || node.nodeName === "ink-root") {
		const separator = node.style.flexDirection === "row" || node.style.flexDirection === "row-reverse" ? " " : "\n";
		output = (node.style.flexDirection === "row-reverse" || node.style.flexDirection === "column-reverse" ? [...node.childNodes].reverse() : [...node.childNodes]).map((childNode) => {
			return renderNodeToScreenReaderOutput(childNode, {
				parentRole: node.internal_accessibility?.role,
				skipStaticElements: options.skipStaticElements
			});
		}).filter(Boolean).join(separator);
	}
	if (node.internal_accessibility) {
		const { role, state } = node.internal_accessibility;
		if (state) {
			const stateDescription = Object.keys(state).filter((key) => state[key]).join(", ");
			if (stateDescription) output = `(${stateDescription}) ${output}`;
		}
		if (role && role !== options.parentRole) output = `${role}: ${output}`;
	}
	return output;
};
const renderNodeToOutput = (node, output, options) => {
	const { offsetX = 0, offsetY = 0, transformers = [], skipStaticElements } = options;
	if (skipStaticElements && node.internal_static) return;
	const { yogaNode } = node;
	if (yogaNode) {
		if (yogaNode.getDisplay() === src_default.DISPLAY_NONE) return;
		const x = offsetX + yogaNode.getComputedLeft();
		const y = offsetY + yogaNode.getComputedTop();
		let newTransformers = transformers;
		if (typeof node.internal_transform === "function") newTransformers = [node.internal_transform, ...transformers];
		if (node.nodeName === "ink-text") {
			let text = squash_text_nodes_default(node);
			if (text.length > 0) {
				const currentWidth = widestLine(text);
				const maxWidth = get_max_width_default(yogaNode);
				if (currentWidth > maxWidth) {
					const textWrap = node.style.textWrap ?? "wrap";
					text = wrap_text_default(text, maxWidth, textWrap);
				}
				text = applyPaddingToText(node, text);
				output.write(x, y, text, { transformers: newTransformers });
			}
			return;
		}
		let clipped = false;
		if (node.nodeName === "ink-box") {
			render_background_default(x, y, node, output);
			render_border_default(x, y, node, output);
			const clipHorizontally = node.style.overflowX === "hidden" || node.style.overflow === "hidden";
			const clipVertically = node.style.overflowY === "hidden" || node.style.overflow === "hidden";
			if (clipHorizontally || clipVertically) {
				const x1 = clipHorizontally ? x + yogaNode.getComputedBorder(src_default.EDGE_LEFT) : void 0;
				const x2 = clipHorizontally ? x + yogaNode.getComputedWidth() - yogaNode.getComputedBorder(src_default.EDGE_RIGHT) : void 0;
				const y1 = clipVertically ? y + yogaNode.getComputedBorder(src_default.EDGE_TOP) : void 0;
				const y2 = clipVertically ? y + yogaNode.getComputedHeight() - yogaNode.getComputedBorder(src_default.EDGE_BOTTOM) : void 0;
				output.clip({
					x1,
					x2,
					y1,
					y2
				});
				clipped = true;
			}
		}
		if (node.nodeName === "ink-root" || node.nodeName === "ink-box") {
			for (const childNode of node.childNodes) renderNodeToOutput(childNode, output, {
				offsetX: x,
				offsetY: y,
				transformers: newTransformers,
				skipStaticElements
			});
			if (clipped) output.unclip();
		}
	}
};
var render_node_to_output_default = renderNodeToOutput;

//#endregion
//#region node_modules/is-fullwidth-code-point/index.js
function isFullwidthCodePoint(codePoint) {
	if (!Number.isInteger(codePoint)) return false;
	return isFullWidth(codePoint) || isWide(codePoint);
}

//#endregion
//#region node_modules/slice-ansi/index.js
const ESCAPES$1 = new Set([27, 155]);
const CODE_POINT_0 = "0".codePointAt(0);
const CODE_POINT_9 = "9".codePointAt(0);
const MAX_ANSI_SEQUENCE_LENGTH = 19;
const endCodesSet$1 = /* @__PURE__ */ new Set();
const endCodesMap$1 = /* @__PURE__ */ new Map();
for (const [start, end] of ansi_styles_default.codes) {
	endCodesSet$1.add(ansi_styles_default.color.ansi(end));
	endCodesMap$1.set(ansi_styles_default.color.ansi(start), ansi_styles_default.color.ansi(end));
}
function getEndCode$1(code) {
	if (endCodesSet$1.has(code)) return code;
	if (endCodesMap$1.has(code)) return endCodesMap$1.get(code);
	code = code.slice(2);
	if (code.includes(";")) code = code[0] + "0";
	const returnValue = ansi_styles_default.codes.get(Number.parseInt(code, 10));
	if (returnValue) return ansi_styles_default.color.ansi(returnValue);
	return ansi_styles_default.reset.open;
}
function findNumberIndex$1(string) {
	for (let index = 0; index < string.length; index++) {
		const codePoint = string.codePointAt(index);
		if (codePoint >= CODE_POINT_0 && codePoint <= CODE_POINT_9) return index;
	}
	return -1;
}
function parseAnsiCode$1(string, offset) {
	string = string.slice(offset, offset + MAX_ANSI_SEQUENCE_LENGTH);
	const startIndex = findNumberIndex$1(string);
	if (startIndex !== -1) {
		let endIndex = string.indexOf("m", startIndex);
		if (endIndex === -1) endIndex = string.length;
		return string.slice(0, endIndex + 1);
	}
}
function tokenize$1(string, endCharacter = Number.POSITIVE_INFINITY) {
	const returnValue = [];
	let index = 0;
	let visibleCount = 0;
	while (index < string.length) {
		const codePoint = string.codePointAt(index);
		if (ESCAPES$1.has(codePoint)) {
			const code = parseAnsiCode$1(string, index);
			if (code) {
				returnValue.push({
					type: "ansi",
					code,
					endCode: getEndCode$1(code)
				});
				index += code.length;
				continue;
			}
		}
		const isFullWidth$1 = isFullwidthCodePoint(codePoint);
		const character = String.fromCodePoint(codePoint);
		returnValue.push({
			type: "character",
			value: character,
			isFullWidth: isFullWidth$1
		});
		index += character.length;
		visibleCount += isFullWidth$1 ? 2 : character.length;
		if (visibleCount >= endCharacter) break;
	}
	return returnValue;
}
function reduceAnsiCodes$1(codes) {
	let returnValue = [];
	for (const code of codes) if (code.code === ansi_styles_default.reset.open) returnValue = [];
	else if (endCodesSet$1.has(code.code)) returnValue = returnValue.filter((returnValueCode) => returnValueCode.endCode !== code.code);
	else {
		returnValue = returnValue.filter((returnValueCode) => returnValueCode.endCode !== code.endCode);
		returnValue.push(code);
	}
	return returnValue;
}
function undoAnsiCodes$1(codes) {
	return reduceAnsiCodes$1(codes).map(({ endCode }) => endCode).reverse().join("");
}
function sliceAnsi(string, start, end) {
	const tokens = tokenize$1(string, end);
	let activeCodes = [];
	let position = 0;
	let returnValue = "";
	let include = false;
	for (const token of tokens) {
		if (end !== void 0 && position >= end) break;
		if (token.type === "ansi") {
			activeCodes.push(token);
			if (include) returnValue += token.code;
		} else {
			if (!include && position >= start) {
				include = true;
				activeCodes = reduceAnsiCodes$1(activeCodes);
				returnValue = activeCodes.map(({ code }) => code).join("");
			}
			if (include) returnValue += token.value;
			position += token.isFullWidth ? 2 : token.value.length;
		}
	}
	returnValue += undoAnsiCodes$1(activeCodes);
	return returnValue;
}

//#endregion
//#region node_modules/@alcalzone/ansi-tokenize/build/ansiCodes.js
const ESCAPES = new Set([27, 155]);
const endCodesSet = /* @__PURE__ */ new Set();
const endCodesMap = /* @__PURE__ */ new Map();
for (const [start, end] of ansi_styles_default.codes) {
	endCodesSet.add(ansi_styles_default.color.ansi(end));
	endCodesMap.set(ansi_styles_default.color.ansi(start), ansi_styles_default.color.ansi(end));
}
const linkStartCodePrefix = "\x1B]8;;";
const linkStartCodePrefixCharCodes = linkStartCodePrefix.split("").map((char) => char.charCodeAt(0));
const linkCodeSuffix = "\x07";
const linkCodeSuffixCharCode = linkCodeSuffix.charCodeAt(0);
const linkEndCode = `\x1B]8;;${linkCodeSuffix}`;
function getEndCode(code) {
	if (endCodesSet.has(code)) return code;
	if (endCodesMap.has(code)) return endCodesMap.get(code);
	if (code.startsWith(linkStartCodePrefix)) return linkEndCode;
	code = code.slice(2);
	if (code.includes(";")) code = code[0] + "0";
	const ret = ansi_styles_default.codes.get(parseInt(code, 10));
	if (ret) return ansi_styles_default.color.ansi(ret);
	else return ansi_styles_default.reset.open;
}
function ansiCodesToString(codes) {
	return codes.map((code) => code.code).join("");
}

//#endregion
//#region node_modules/@alcalzone/ansi-tokenize/build/reduce.js
/** Reduces the given array of ANSI codes to the minimum necessary to render with the same style */
function reduceAnsiCodes(codes) {
	return reduceAnsiCodesIncremental([], codes);
}
/** Like {@link reduceAnsiCodes}, but assumes that `codes` is already reduced. Further reductions are only done for the items in `newCodes`. */
function reduceAnsiCodesIncremental(codes, newCodes) {
	let ret = [...codes];
	for (const code of newCodes) if (code.code === ansi_styles_default.reset.open) ret = [];
	else if (endCodesSet.has(code.code)) ret = ret.filter((retCode) => retCode.endCode !== code.code);
	else {
		ret = ret.filter((retCode) => retCode.endCode !== code.endCode);
		ret.push(code);
	}
	return ret;
}

//#endregion
//#region node_modules/@alcalzone/ansi-tokenize/build/undo.js
/** Returns the combination of ANSI codes needed to undo the given ANSI codes */
function undoAnsiCodes(codes) {
	return reduceAnsiCodes(codes).reverse().map((code) => ({
		...code,
		code: code.endCode
	}));
}

//#endregion
//#region node_modules/@alcalzone/ansi-tokenize/build/diff.js
/**
* Returns the minimum amount of ANSI codes necessary to get from the compound style `from` to `to`.
* Both `from` and `to` are expected to be reduced.
*/
function diffAnsiCodes(from, to) {
	const endCodesInTo = new Set(to.map((code) => code.endCode));
	const startCodesInFrom = new Set(from.map((code) => code.code));
	return [...undoAnsiCodes(from.filter((code) => !endCodesInTo.has(code.endCode))), ...to.filter((code) => !startCodesInFrom.has(code.code))];
}

//#endregion
//#region node_modules/@alcalzone/ansi-tokenize/build/styledChars.js
function styledCharsFromTokens(tokens) {
	let codes = [];
	const ret = [];
	for (const token of tokens) if (token.type === "ansi") codes = reduceAnsiCodesIncremental(codes, [token]);
	else if (token.type === "char") ret.push({
		...token,
		styles: [...codes]
	});
	return ret;
}
function styledCharsToString(chars) {
	let ret = "";
	for (let i = 0; i < chars.length; i++) {
		const char = chars[i];
		if (i === 0) ret += ansiCodesToString(char.styles);
		else ret += ansiCodesToString(diffAnsiCodes(chars[i - 1].styles, char.styles));
		ret += char.value;
		if (i === chars.length - 1) ret += ansiCodesToString(diffAnsiCodes(char.styles, []));
	}
	return ret;
}

//#endregion
//#region node_modules/@alcalzone/ansi-tokenize/build/tokenize.js
function findNumberIndex(str) {
	for (let index = 0; index < str.length; index++) {
		const charCode = str.charCodeAt(index);
		if (charCode >= 48 && charCode <= 57) return index;
	}
	return -1;
}
function parseLinkCode(string, offset) {
	string = string.slice(offset);
	for (let index = 1; index < linkStartCodePrefixCharCodes.length; index++) if (string.charCodeAt(index) !== linkStartCodePrefixCharCodes[index]) return;
	const endIndex = string.indexOf("\x07", linkStartCodePrefix.length);
	if (endIndex === -1) return void 0;
	return string.slice(0, endIndex + 1);
}
function parseAnsiCode(string, offset) {
	string = string.slice(offset, offset + 19);
	const startIndex = findNumberIndex(string);
	if (startIndex !== -1) {
		let endIndex = string.indexOf("m", startIndex);
		if (endIndex === -1) endIndex = string.length;
		return string.slice(0, endIndex + 1);
	}
}
function tokenize(str, endChar = Number.POSITIVE_INFINITY) {
	const ret = [];
	let index = 0;
	let visible = 0;
	while (index < str.length) {
		const codePoint = str.codePointAt(index);
		if (ESCAPES.has(codePoint)) {
			const code = parseLinkCode(str, index) || parseAnsiCode(str, index);
			if (code) {
				ret.push({
					type: "ansi",
					code,
					endCode: getEndCode(code)
				});
				index += code.length;
				continue;
			}
		}
		const fullWidth = isFullwidthCodePoint(codePoint);
		const character = String.fromCodePoint(codePoint);
		ret.push({
			type: "char",
			value: character,
			fullWidth
		});
		index += character.length;
		visible += fullWidth ? 2 : character.length;
		if (visible >= endChar) break;
	}
	return ret;
}

//#endregion
//#region node_modules/ink/build/output.js
var Output = class {
	width;
	height;
	operations = [];
	constructor(options) {
		const { width, height } = options;
		this.width = width;
		this.height = height;
	}
	write(x, y, text, options) {
		const { transformers } = options;
		if (!text) return;
		this.operations.push({
			type: "write",
			x,
			y,
			text,
			transformers
		});
	}
	clip(clip) {
		this.operations.push({
			type: "clip",
			clip
		});
	}
	unclip() {
		this.operations.push({ type: "unclip" });
	}
	get() {
		const output = [];
		for (let y = 0; y < this.height; y++) {
			const row = [];
			for (let x = 0; x < this.width; x++) row.push({
				type: "char",
				value: " ",
				fullWidth: false,
				styles: []
			});
			output.push(row);
		}
		const clips = [];
		for (const operation of this.operations) {
			if (operation.type === "clip") clips.push(operation.clip);
			if (operation.type === "unclip") clips.pop();
			if (operation.type === "write") {
				const { text, transformers } = operation;
				let { x, y } = operation;
				let lines = text.split("\n");
				const clip = clips.at(-1);
				if (clip) {
					const clipHorizontally = typeof clip?.x1 === "number" && typeof clip?.x2 === "number";
					const clipVertically = typeof clip?.y1 === "number" && typeof clip?.y2 === "number";
					if (clipHorizontally) {
						const width = widestLine(text);
						if (x + width < clip.x1 || x > clip.x2) continue;
					}
					if (clipVertically) {
						const height = lines.length;
						if (y + height < clip.y1 || y > clip.y2) continue;
					}
					if (clipHorizontally) {
						lines = lines.map((line) => {
							const from = x < clip.x1 ? clip.x1 - x : 0;
							const width = stringWidth(line);
							return sliceAnsi(line, from, x + width > clip.x2 ? clip.x2 - x : width);
						});
						if (x < clip.x1) x = clip.x1;
					}
					if (clipVertically) {
						const from = y < clip.y1 ? clip.y1 - y : 0;
						const height = lines.length;
						const to = y + height > clip.y2 ? clip.y2 - y : height;
						lines = lines.slice(from, to);
						if (y < clip.y1) y = clip.y1;
					}
				}
				let offsetY = 0;
				for (let [index, line] of lines.entries()) {
					const currentLine = output[y + offsetY];
					if (!currentLine) continue;
					for (const transformer of transformers) line = transformer(line, index);
					const characters = styledCharsFromTokens(tokenize(line));
					let offsetX = x;
					for (const character of characters) {
						currentLine[offsetX] = character;
						const characterWidth = Math.max(1, stringWidth(character.value));
						if (characterWidth > 1) for (let index$1 = 1; index$1 < characterWidth; index$1++) currentLine[offsetX + index$1] = {
							type: "char",
							value: "",
							fullWidth: false,
							styles: character.styles
						};
						offsetX += characterWidth;
					}
					offsetY++;
				}
			}
		}
		return {
			output: output.map((line) => {
				return styledCharsToString(line.filter((item) => item !== void 0)).trimEnd();
			}).join("\n"),
			height: output.length
		};
	}
};

//#endregion
//#region node_modules/ink/build/renderer.js
const renderer = (node, isScreenReaderEnabled) => {
	if (node.yogaNode) {
		if (isScreenReaderEnabled) {
			const output$1 = renderNodeToScreenReaderOutput(node, { skipStaticElements: true });
			const outputHeight$1 = output$1 === "" ? 0 : output$1.split("\n").length;
			let staticOutput$1 = "";
			if (node.staticNode) staticOutput$1 = renderNodeToScreenReaderOutput(node.staticNode, { skipStaticElements: false });
			return {
				output: output$1,
				outputHeight: outputHeight$1,
				staticOutput: staticOutput$1 ? `${staticOutput$1}\n` : ""
			};
		}
		const output = new Output({
			width: node.yogaNode.getComputedWidth(),
			height: node.yogaNode.getComputedHeight()
		});
		render_node_to_output_default(node, output, { skipStaticElements: true });
		let staticOutput;
		if (node.staticNode?.yogaNode) {
			staticOutput = new Output({
				width: node.staticNode.yogaNode.getComputedWidth(),
				height: node.staticNode.yogaNode.getComputedHeight()
			});
			render_node_to_output_default(node.staticNode, staticOutput, { skipStaticElements: false });
		}
		const { output: generatedOutput, height: outputHeight } = output.get();
		return {
			output: generatedOutput,
			outputHeight,
			staticOutput: staticOutput ? `${staticOutput.get().output}\n` : ""
		};
	}
	return {
		output: "",
		outputHeight: 0,
		staticOutput: ""
	};
};
var renderer_default = renderer;

//#endregion
//#region node_modules/mimic-fn/index.js
var require_mimic_fn = /* @__PURE__ */ __commonJS({ "node_modules/mimic-fn/index.js": ((exports, module) => {
	const mimicFn$1 = (to, from) => {
		for (const prop of Reflect.ownKeys(from)) Object.defineProperty(to, prop, Object.getOwnPropertyDescriptor(from, prop));
		return to;
	};
	module.exports = mimicFn$1;
	module.exports.default = mimicFn$1;
}) });

//#endregion
//#region node_modules/onetime/index.js
var require_onetime = /* @__PURE__ */ __commonJS({ "node_modules/onetime/index.js": ((exports, module) => {
	const mimicFn = require_mimic_fn();
	const calledFunctions = /* @__PURE__ */ new WeakMap();
	const onetime$1 = (function_, options = {}) => {
		if (typeof function_ !== "function") throw new TypeError("Expected a function");
		let returnValue;
		let callCount = 0;
		const functionName = function_.displayName || function_.name || "<anonymous>";
		const onetime$2 = function(...arguments_) {
			calledFunctions.set(onetime$2, ++callCount);
			if (callCount === 1) {
				returnValue = function_.apply(this, arguments_);
				function_ = null;
			} else if (options.throw === true) throw new Error(`Function \`${functionName}\` can only be called once`);
			return returnValue;
		};
		mimicFn(onetime$2, function_);
		calledFunctions.set(onetime$2, callCount);
		return onetime$2;
	};
	module.exports = onetime$1;
	module.exports.default = onetime$1;
	module.exports.callCount = (function_) => {
		if (!calledFunctions.has(function_)) throw new Error(`The given function \`${function_.name}\` is not wrapped by the \`onetime\` package`);
		return calledFunctions.get(function_);
	};
}) });

//#endregion
//#region node_modules/restore-cursor/index.js
var import_onetime = /* @__PURE__ */ __toESM(require_onetime(), 1);
const restoreCursor = (0, import_onetime.default)(() => {
	(0, import_signal_exit$1.default)(() => {
		process$1.stderr.write("\x1B[?25h");
	}, { alwaysLast: true });
});
var restore_cursor_default = restoreCursor;

//#endregion
//#region node_modules/cli-cursor/index.js
let isHidden = false;
const cliCursor = {};
cliCursor.show = (writableStream = process$1.stderr) => {
	if (!writableStream.isTTY) return;
	isHidden = false;
	writableStream.write("\x1B[?25h");
};
cliCursor.hide = (writableStream = process$1.stderr) => {
	if (!writableStream.isTTY) return;
	restore_cursor_default();
	isHidden = true;
	writableStream.write("\x1B[?25l");
};
cliCursor.toggle = (force, writableStream) => {
	if (force !== void 0) isHidden = force;
	if (isHidden) cliCursor.show(writableStream);
	else cliCursor.hide(writableStream);
};
var cli_cursor_default = cliCursor;

//#endregion
//#region node_modules/ink/build/log-update.js
const create = (stream, { showCursor = false } = {}) => {
	let previousLineCount = 0;
	let previousOutput = "";
	let hasHiddenCursor = false;
	const render$1 = (str) => {
		if (!showCursor && !hasHiddenCursor) {
			cli_cursor_default.hide();
			hasHiddenCursor = true;
		}
		const output = str + "\n";
		if (output === previousOutput) return;
		previousOutput = output;
		stream.write(eraseLines(previousLineCount) + output);
		previousLineCount = output.split("\n").length;
	};
	render$1.clear = () => {
		stream.write(eraseLines(previousLineCount));
		previousOutput = "";
		previousLineCount = 0;
	};
	render$1.done = () => {
		previousOutput = "";
		previousLineCount = 0;
		if (!showCursor) {
			cli_cursor_default.show();
			hasHiddenCursor = false;
		}
	};
	render$1.sync = (str) => {
		const output = str + "\n";
		previousOutput = output;
		previousLineCount = output.split("\n").length;
	};
	return render$1;
};
const logUpdate = { create };
var log_update_default = logUpdate;

//#endregion
//#region node_modules/ink/build/instances.js
const instances = /* @__PURE__ */ new WeakMap();
var instances_default = instances;

//#endregion
//#region node_modules/ink/build/components/AppContext.js
/**
`AppContext` is a React context that exposes a method to manually exit the app (unmount).
*/
const AppContext = (0, import_react.createContext)({ exit() {} });
AppContext.displayName = "InternalAppContext";
var AppContext_default = AppContext;

//#endregion
//#region node_modules/ink/build/components/StdinContext.js
/**
`StdinContext` is a React context that exposes the input stream.
*/
const StdinContext = (0, import_react.createContext)({
	stdin: process$1.stdin,
	internal_eventEmitter: new EventEmitter(),
	setRawMode() {},
	isRawModeSupported: false,
	internal_exitOnCtrlC: true
});
StdinContext.displayName = "InternalStdinContext";
var StdinContext_default = StdinContext;

//#endregion
//#region node_modules/ink/build/components/StdoutContext.js
/**
`StdoutContext` is a React context that exposes the stdout stream where Ink renders your app.
*/
const StdoutContext = (0, import_react.createContext)({
	stdout: process$1.stdout,
	write() {}
});
StdoutContext.displayName = "InternalStdoutContext";
var StdoutContext_default = StdoutContext;

//#endregion
//#region node_modules/ink/build/components/StderrContext.js
/**
`StderrContext` is a React context that exposes the stderr stream.
*/
const StderrContext = (0, import_react.createContext)({
	stderr: process$1.stderr,
	write() {}
});
StderrContext.displayName = "InternalStderrContext";
var StderrContext_default = StderrContext;

//#endregion
//#region node_modules/ink/build/components/FocusContext.js
const FocusContext = (0, import_react.createContext)({
	activeId: void 0,
	add() {},
	remove() {},
	activate() {},
	deactivate() {},
	enableFocus() {},
	disableFocus() {},
	focusNext() {},
	focusPrevious() {},
	focus() {}
});
FocusContext.displayName = "InternalFocusContext";
var FocusContext_default = FocusContext;

//#endregion
//#region node_modules/stack-utils/node_modules/escape-string-regexp/index.js
var require_escape_string_regexp = /* @__PURE__ */ __commonJS({ "node_modules/stack-utils/node_modules/escape-string-regexp/index.js": ((exports, module) => {
	const matchOperatorsRegex = /[|\\{}()[\]^$+*?.-]/g;
	module.exports = (string) => {
		if (typeof string !== "string") throw new TypeError("Expected a string");
		return string.replace(matchOperatorsRegex, "\\$&");
	};
}) });

//#endregion
//#region node_modules/stack-utils/index.js
var require_stack_utils = /* @__PURE__ */ __commonJS({ "node_modules/stack-utils/index.js": ((exports, module) => {
	const escapeStringRegexp = require_escape_string_regexp();
	const cwd$1 = typeof process === "object" && process && typeof process.cwd === "function" ? process.cwd() : ".";
	const natives = [].concat(__require("module").builtinModules, "bootstrap_node", "node").map((n) => /* @__PURE__ */ new RegExp(`(?:\\((?:node:)?${n}(?:\\.js)?:\\d+:\\d+\\)$|^\\s*at (?:node:)?${n}(?:\\.js)?:\\d+:\\d+$)`));
	natives.push(/\((?:node:)?internal\/[^:]+:\d+:\d+\)$/, /\s*at (?:node:)?internal\/[^:]+:\d+:\d+$/, /\/\.node-spawn-wrap-\w+-\w+\/node:\d+:\d+\)?$/);
	var StackUtils$1 = class StackUtils$1 {
		constructor(opts) {
			opts = {
				ignoredPackages: [],
				...opts
			};
			if ("internals" in opts === false) opts.internals = StackUtils$1.nodeInternals();
			if ("cwd" in opts === false) opts.cwd = cwd$1;
			this._cwd = opts.cwd.replace(/\\/g, "/");
			this._internals = [].concat(opts.internals, ignoredPackagesRegExp(opts.ignoredPackages));
			this._wrapCallSite = opts.wrapCallSite || false;
		}
		static nodeInternals() {
			return [...natives];
		}
		clean(stack, indent = 0) {
			indent = " ".repeat(indent);
			if (!Array.isArray(stack)) stack = stack.split("\n");
			if (!/^\s*at /.test(stack[0]) && /^\s*at /.test(stack[1])) stack = stack.slice(1);
			let outdent = false;
			let lastNonAtLine = null;
			const result = [];
			stack.forEach((st) => {
				st = st.replace(/\\/g, "/");
				if (this._internals.some((internal) => internal.test(st))) return;
				const isAtLine = /^\s*at /.test(st);
				if (outdent) st = st.trimEnd().replace(/^(\s+)at /, "$1");
				else {
					st = st.trim();
					if (isAtLine) st = st.slice(3);
				}
				st = st.replace(`${this._cwd}/`, "");
				if (st) if (isAtLine) {
					if (lastNonAtLine) {
						result.push(lastNonAtLine);
						lastNonAtLine = null;
					}
					result.push(st);
				} else {
					outdent = true;
					lastNonAtLine = st;
				}
			});
			return result.map((line) => `${indent}${line}\n`).join("");
		}
		captureString(limit, fn = this.captureString) {
			if (typeof limit === "function") {
				fn = limit;
				limit = Infinity;
			}
			const { stackTraceLimit } = Error;
			if (limit) Error.stackTraceLimit = limit;
			const obj = {};
			Error.captureStackTrace(obj, fn);
			const { stack } = obj;
			Error.stackTraceLimit = stackTraceLimit;
			return this.clean(stack);
		}
		capture(limit, fn = this.capture) {
			if (typeof limit === "function") {
				fn = limit;
				limit = Infinity;
			}
			const { prepareStackTrace, stackTraceLimit } = Error;
			Error.prepareStackTrace = (obj$1, site) => {
				if (this._wrapCallSite) return site.map(this._wrapCallSite);
				return site;
			};
			if (limit) Error.stackTraceLimit = limit;
			const obj = {};
			Error.captureStackTrace(obj, fn);
			const { stack } = obj;
			Object.assign(Error, {
				prepareStackTrace,
				stackTraceLimit
			});
			return stack;
		}
		at(fn = this.at) {
			const [site] = this.capture(1, fn);
			if (!site) return {};
			const res = {
				line: site.getLineNumber(),
				column: site.getColumnNumber()
			};
			setFile(res, site.getFileName(), this._cwd);
			if (site.isConstructor()) Object.defineProperty(res, "constructor", {
				value: true,
				configurable: true
			});
			if (site.isEval()) res.evalOrigin = site.getEvalOrigin();
			/* istanbul ignore next */
			if (site.isNative()) res.native = true;
			let typename;
			try {
				typename = site.getTypeName();
			} catch (_) {}
			if (typename && typename !== "Object" && typename !== "[object Object]") res.type = typename;
			const fname = site.getFunctionName();
			if (fname) res.function = fname;
			const meth = site.getMethodName();
			if (meth && fname !== meth) res.method = meth;
			return res;
		}
		parseLine(line) {
			const match = line && line.match(re$1);
			if (!match) return null;
			const ctor = match[1] === "new";
			let fname = match[2];
			const evalOrigin = match[3];
			const evalFile = match[4];
			const evalLine = Number(match[5]);
			const evalCol = Number(match[6]);
			let file = match[7];
			const lnum = match[8];
			const col = match[9];
			const native = match[10] === "native";
			const closeParen = match[11] === ")";
			let method;
			const res = {};
			if (lnum) res.line = Number(lnum);
			if (col) res.column = Number(col);
			if (closeParen && file) {
				let closes = 0;
				for (let i = file.length - 1; i > 0; i--) if (file.charAt(i) === ")") closes++;
				else if (file.charAt(i) === "(" && file.charAt(i - 1) === " ") {
					closes--;
					if (closes === -1 && file.charAt(i - 1) === " ") {
						const before = file.slice(0, i - 1);
						file = file.slice(i + 1);
						fname += ` (${before}`;
						break;
					}
				}
			}
			if (fname) {
				const methodMatch = fname.match(methodRe);
				if (methodMatch) {
					fname = methodMatch[1];
					method = methodMatch[2];
				}
			}
			setFile(res, file, this._cwd);
			if (ctor) Object.defineProperty(res, "constructor", {
				value: true,
				configurable: true
			});
			if (evalOrigin) {
				res.evalOrigin = evalOrigin;
				res.evalLine = evalLine;
				res.evalColumn = evalCol;
				res.evalFile = evalFile && evalFile.replace(/\\/g, "/");
			}
			if (native) res.native = true;
			if (fname) res.function = fname;
			if (method && fname !== method) res.method = method;
			return res;
		}
	};
	function setFile(result, filename, cwd$2) {
		if (filename) {
			filename = filename.replace(/\\/g, "/");
			if (filename.startsWith(`${cwd$2}/`)) filename = filename.slice(cwd$2.length + 1);
			result.file = filename;
		}
	}
	function ignoredPackagesRegExp(ignoredPackages) {
		if (ignoredPackages.length === 0) return [];
		const packages = ignoredPackages.map((mod) => escapeStringRegexp(mod));
		return /* @__PURE__ */ new RegExp(`[\/\\\\]node_modules[\/\\\\](?:${packages.join("|")})[\/\\\\][^:]+:\\d+:\\d+`);
	}
	const re$1 = /* @__PURE__ */ new RegExp("^(?:\\s*at )?(?:(new) )?(?:(.*?) \\()?(?:eval at ([^ ]+) \\((.+?):(\\d+):(\\d+)\\), )?(?:(.+?):(\\d+):(\\d+)|(native))(\\)?)$");
	const methodRe = /^(.*?) \[as (.*?)\]$/;
	module.exports = StackUtils$1;
}) });

//#endregion
//#region node_modules/convert-to-spaces/dist/index.js
var import_stack_utils = /* @__PURE__ */ __toESM(require_stack_utils(), 1);
const convertToSpaces = (input, spaces = 2) => {
	return input.replace(/^\t+/gm, ($1) => " ".repeat($1.length * spaces));
};
var dist_default$2 = convertToSpaces;

//#endregion
//#region node_modules/code-excerpt/dist/index.js
const generateLineNumbers = (line, around) => {
	const lineNumbers = [];
	const min = line - around;
	const max = line + around;
	for (let lineNumber = min; lineNumber <= max; lineNumber++) lineNumbers.push(lineNumber);
	return lineNumbers;
};
const codeExcerpt = (source, line, options = {}) => {
	var _a$1;
	if (typeof source !== "string") throw new TypeError("Source code is missing.");
	if (!line || line < 1) throw new TypeError("Line number must start from `1`.");
	const lines = dist_default$2(source).split(/\r?\n/);
	if (line > lines.length) return;
	return generateLineNumbers(line, (_a$1 = options.around) !== null && _a$1 !== void 0 ? _a$1 : 3).filter((line$1) => lines[line$1 - 1] !== void 0).map((line$1) => ({
		line: line$1,
		value: lines[line$1 - 1]
	}));
};
var dist_default$1 = codeExcerpt;

//#endregion
//#region node_modules/ink/build/components/AccessibilityContext.js
const accessibilityContext = (0, import_react.createContext)({ isScreenReaderEnabled: false });

//#endregion
//#region node_modules/ink/build/components/BackgroundContext.js
const backgroundContext = (0, import_react.createContext)(void 0);

//#endregion
//#region node_modules/ink/build/components/Box.js
/**
`<Box>` is an essential Ink component to build your layout. It's like `<div style="display: flex">` in the browser.
*/
const Box = (0, import_react.forwardRef)(({ children, backgroundColor, "aria-label": ariaLabel, "aria-hidden": ariaHidden, "aria-role": role, "aria-state": ariaState,...style }, ref) => {
	const { isScreenReaderEnabled } = (0, import_react.useContext)(accessibilityContext);
	const label = ariaLabel ? import_react.createElement("ink-text", null, ariaLabel) : void 0;
	if (isScreenReaderEnabled && ariaHidden) return null;
	const boxElement = import_react.createElement("ink-box", {
		ref,
		style: {
			flexWrap: "nowrap",
			flexDirection: "row",
			flexGrow: 0,
			flexShrink: 1,
			...style,
			backgroundColor,
			overflowX: style.overflowX ?? style.overflow ?? "visible",
			overflowY: style.overflowY ?? style.overflow ?? "visible"
		},
		internal_accessibility: {
			role,
			state: ariaState
		}
	}, isScreenReaderEnabled && label ? label : children);
	if (backgroundColor) return import_react.createElement(backgroundContext.Provider, { value: backgroundColor }, boxElement);
	return boxElement;
});
Box.displayName = "Box";
var Box_default = Box;

//#endregion
//#region node_modules/ink/build/components/Text.js
/**
This component can display text and change its style to make it bold, underlined, italic, or strikethrough.
*/
function Text({ color, backgroundColor, dimColor = false, bold = false, italic = false, underline = false, strikethrough = false, inverse = false, wrap = "wrap", children, "aria-label": ariaLabel, "aria-hidden": ariaHidden = false }) {
	const { isScreenReaderEnabled } = (0, import_react.useContext)(accessibilityContext);
	const inheritedBackgroundColor = (0, import_react.useContext)(backgroundContext);
	const childrenOrAriaLabel = isScreenReaderEnabled && ariaLabel ? ariaLabel : children;
	if (childrenOrAriaLabel === void 0 || childrenOrAriaLabel === null) return null;
	const transform$2 = (children$1) => {
		if (dimColor) children$1 = source_default.dim(children$1);
		if (color) children$1 = colorize_default(children$1, color, "foreground");
		const effectiveBackgroundColor = backgroundColor ?? inheritedBackgroundColor;
		if (effectiveBackgroundColor) children$1 = colorize_default(children$1, effectiveBackgroundColor, "background");
		if (bold) children$1 = source_default.bold(children$1);
		if (italic) children$1 = source_default.italic(children$1);
		if (underline) children$1 = source_default.underline(children$1);
		if (strikethrough) children$1 = source_default.strikethrough(children$1);
		if (inverse) children$1 = source_default.inverse(children$1);
		return children$1;
	};
	if (isScreenReaderEnabled && ariaHidden) return null;
	return import_react.createElement("ink-text", {
		style: {
			flexGrow: 0,
			flexShrink: 1,
			flexDirection: "row",
			textWrap: wrap
		},
		internal_transform: transform$2
	}, isScreenReaderEnabled && ariaLabel ? ariaLabel : children);
}

//#endregion
//#region node_modules/ink/build/components/ErrorOverview.js
const cleanupPath = (path$1) => {
	return path$1?.replace(`file://${cwd()}/`, "");
};
const stackUtils = new import_stack_utils.default({
	cwd: cwd(),
	internals: import_stack_utils.default.nodeInternals()
});
function ErrorOverview({ error }) {
	const stack = error.stack ? error.stack.split("\n").slice(1) : void 0;
	const origin = stack ? stackUtils.parseLine(stack[0]) : void 0;
	const filePath = cleanupPath(origin?.file);
	let excerpt;
	let lineWidth = 0;
	if (filePath && origin?.line && fs$1.existsSync(filePath)) {
		excerpt = dist_default$1(fs$1.readFileSync(filePath, "utf8"), origin.line);
		if (excerpt) for (const { line } of excerpt) lineWidth = Math.max(lineWidth, String(line).length);
	}
	return import_react.createElement(Box_default, {
		flexDirection: "column",
		padding: 1
	}, import_react.createElement(Box_default, null, import_react.createElement(Text, {
		backgroundColor: "red",
		color: "white"
	}, " ", "ERROR", " "), import_react.createElement(Text, null, " ", error.message)), origin && filePath && import_react.createElement(Box_default, { marginTop: 1 }, import_react.createElement(Text, { dimColor: true }, filePath, ":", origin.line, ":", origin.column)), origin && excerpt && import_react.createElement(Box_default, {
		marginTop: 1,
		flexDirection: "column"
	}, excerpt.map(({ line, value }) => import_react.createElement(Box_default, { key: line }, import_react.createElement(Box_default, { width: lineWidth + 1 }, import_react.createElement(Text, {
		dimColor: line !== origin.line,
		backgroundColor: line === origin.line ? "red" : void 0,
		color: line === origin.line ? "white" : void 0,
		"aria-label": line === origin.line ? `Line ${line}, error` : `Line ${line}`
	}, String(line).padStart(lineWidth, " "), ":")), import_react.createElement(Text, {
		key: line,
		backgroundColor: line === origin.line ? "red" : void 0,
		color: line === origin.line ? "white" : void 0
	}, " " + value)))), error.stack && import_react.createElement(Box_default, {
		marginTop: 1,
		flexDirection: "column"
	}, error.stack.split("\n").slice(1).map((line) => {
		const parsedLine = stackUtils.parseLine(line);
		if (!parsedLine) return import_react.createElement(Box_default, { key: line }, import_react.createElement(Text, { dimColor: true }, "- "), import_react.createElement(Text, {
			dimColor: true,
			bold: true
		}, line, "\\t", " "));
		return import_react.createElement(Box_default, { key: line }, import_react.createElement(Text, { dimColor: true }, "- "), import_react.createElement(Text, {
			dimColor: true,
			bold: true
		}, parsedLine.function), import_react.createElement(Text, {
			dimColor: true,
			color: "gray",
			"aria-label": `at ${cleanupPath(parsedLine.file) ?? ""} line ${parsedLine.line} column ${parsedLine.column}`
		}, " ", "(", cleanupPath(parsedLine.file) ?? "", ":", parsedLine.line, ":", parsedLine.column, ")"));
	})));
}

//#endregion
//#region node_modules/ink/build/components/App.js
const tab = "	";
const shiftTab = "\x1B[Z";
const escape = "\x1B";
var App$1 = class extends import_react.PureComponent {
	static displayName = "InternalApp";
	static getDerivedStateFromError(error) {
		return { error };
	}
	state = {
		isFocusEnabled: true,
		activeFocusId: void 0,
		focusables: [],
		error: void 0
	};
	rawModeEnabledCount = 0;
	internal_eventEmitter = new EventEmitter();
	isRawModeSupported() {
		return this.props.stdin.isTTY;
	}
	render() {
		return import_react.createElement(AppContext_default.Provider, { value: { exit: this.handleExit } }, import_react.createElement(StdinContext_default.Provider, { value: {
			stdin: this.props.stdin,
			setRawMode: this.handleSetRawMode,
			isRawModeSupported: this.isRawModeSupported(),
			internal_exitOnCtrlC: this.props.exitOnCtrlC,
			internal_eventEmitter: this.internal_eventEmitter
		} }, import_react.createElement(StdoutContext_default.Provider, { value: {
			stdout: this.props.stdout,
			write: this.props.writeToStdout
		} }, import_react.createElement(StderrContext_default.Provider, { value: {
			stderr: this.props.stderr,
			write: this.props.writeToStderr
		} }, import_react.createElement(FocusContext_default.Provider, { value: {
			activeId: this.state.activeFocusId,
			add: this.addFocusable,
			remove: this.removeFocusable,
			activate: this.activateFocusable,
			deactivate: this.deactivateFocusable,
			enableFocus: this.enableFocus,
			disableFocus: this.disableFocus,
			focusNext: this.focusNext,
			focusPrevious: this.focusPrevious,
			focus: this.focus
		} }, this.state.error ? import_react.createElement(ErrorOverview, { error: this.state.error }) : this.props.children)))));
	}
	componentDidMount() {
		cli_cursor_default.hide(this.props.stdout);
	}
	componentWillUnmount() {
		cli_cursor_default.show(this.props.stdout);
		if (this.isRawModeSupported()) this.handleSetRawMode(false);
	}
	componentDidCatch(error) {
		this.handleExit(error);
	}
	handleSetRawMode = (isEnabled) => {
		const { stdin } = this.props;
		if (!this.isRawModeSupported()) if (stdin === process$1.stdin) throw new Error("Raw mode is not supported on the current process.stdin, which Ink uses as input stream by default.\nRead about how to prevent this error on https://github.com/vadimdemedes/ink/#israwmodesupported");
		else throw new Error("Raw mode is not supported on the stdin provided to Ink.\nRead about how to prevent this error on https://github.com/vadimdemedes/ink/#israwmodesupported");
		stdin.setEncoding("utf8");
		if (isEnabled) {
			if (this.rawModeEnabledCount === 0) {
				stdin.ref();
				stdin.setRawMode(true);
				stdin.addListener("readable", this.handleReadable);
			}
			this.rawModeEnabledCount++;
			return;
		}
		if (--this.rawModeEnabledCount === 0) {
			stdin.setRawMode(false);
			stdin.removeListener("readable", this.handleReadable);
			stdin.unref();
		}
	};
	handleReadable = () => {
		let chunk;
		while ((chunk = this.props.stdin.read()) !== null) {
			this.handleInput(chunk);
			this.internal_eventEmitter.emit("input", chunk);
		}
	};
	handleInput = (input) => {
		if (input === "" && this.props.exitOnCtrlC) this.handleExit();
		if (input === escape && this.state.activeFocusId) this.setState({ activeFocusId: void 0 });
		if (this.state.isFocusEnabled && this.state.focusables.length > 0) {
			if (input === tab) this.focusNext();
			if (input === shiftTab) this.focusPrevious();
		}
	};
	handleExit = (error) => {
		if (this.isRawModeSupported()) this.handleSetRawMode(false);
		this.props.onExit(error);
	};
	enableFocus = () => {
		this.setState({ isFocusEnabled: true });
	};
	disableFocus = () => {
		this.setState({ isFocusEnabled: false });
	};
	focus = (id) => {
		this.setState((previousState) => {
			if (!previousState.focusables.some((focusable) => focusable?.id === id)) return previousState;
			return { activeFocusId: id };
		});
	};
	focusNext = () => {
		this.setState((previousState) => {
			const firstFocusableId = previousState.focusables.find((focusable) => focusable.isActive)?.id;
			return { activeFocusId: this.findNextFocusable(previousState) ?? firstFocusableId };
		});
	};
	focusPrevious = () => {
		this.setState((previousState) => {
			const lastFocusableId = previousState.focusables.findLast((focusable) => focusable.isActive)?.id;
			return { activeFocusId: this.findPreviousFocusable(previousState) ?? lastFocusableId };
		});
	};
	addFocusable = (id, { autoFocus }) => {
		this.setState((previousState) => {
			let nextFocusId = previousState.activeFocusId;
			if (!nextFocusId && autoFocus) nextFocusId = id;
			return {
				activeFocusId: nextFocusId,
				focusables: [...previousState.focusables, {
					id,
					isActive: true
				}]
			};
		});
	};
	removeFocusable = (id) => {
		this.setState((previousState) => ({
			activeFocusId: previousState.activeFocusId === id ? void 0 : previousState.activeFocusId,
			focusables: previousState.focusables.filter((focusable) => {
				return focusable.id !== id;
			})
		}));
	};
	activateFocusable = (id) => {
		this.setState((previousState) => ({ focusables: previousState.focusables.map((focusable) => {
			if (focusable.id !== id) return focusable;
			return {
				id,
				isActive: true
			};
		}) }));
	};
	deactivateFocusable = (id) => {
		this.setState((previousState) => ({
			activeFocusId: previousState.activeFocusId === id ? void 0 : previousState.activeFocusId,
			focusables: previousState.focusables.map((focusable) => {
				if (focusable.id !== id) return focusable;
				return {
					id,
					isActive: false
				};
			})
		}));
	};
	findNextFocusable = (state) => {
		const activeIndex = state.focusables.findIndex((focusable) => {
			return focusable.id === state.activeFocusId;
		});
		for (let index = activeIndex + 1; index < state.focusables.length; index++) {
			const focusable = state.focusables[index];
			if (focusable?.isActive) return focusable.id;
		}
	};
	findPreviousFocusable = (state) => {
		const activeIndex = state.focusables.findIndex((focusable) => {
			return focusable.id === state.activeFocusId;
		});
		for (let index = activeIndex - 1; index >= 0; index--) {
			const focusable = state.focusables[index];
			if (focusable?.isActive) return focusable.id;
		}
	};
};

//#endregion
//#region node_modules/ink/build/ink.js
var import_signal_exit = /* @__PURE__ */ __toESM(require_signal_exit(), 1);
var import_constants = /* @__PURE__ */ __toESM(require_constants$1(), 1);
const noop = () => {};
var Ink = class {
	options;
	log;
	throttledLog;
	isScreenReaderEnabled;
	isUnmounted;
	lastOutput;
	lastOutputHeight;
	container;
	rootNode;
	fullStaticOutput;
	exitPromise;
	restoreConsole;
	unsubscribeResize;
	constructor(options) {
		autoBind(this);
		this.options = options;
		this.rootNode = createNode("ink-root");
		this.rootNode.onComputeLayout = this.calculateLayout;
		this.isScreenReaderEnabled = options.isScreenReaderEnabled ?? process$1.env["INK_SCREEN_READER"] === "true";
		const unthrottled = options.debug || this.isScreenReaderEnabled;
		const maxFps = options.maxFps ?? 30;
		const renderThrottleMs = maxFps > 0 ? Math.max(1, Math.ceil(1e3 / maxFps)) : 0;
		this.rootNode.onRender = unthrottled ? this.onRender : throttle(this.onRender, renderThrottleMs, {
			leading: true,
			trailing: true
		});
		this.rootNode.onImmediateRender = this.onRender;
		this.log = log_update_default.create(options.stdout);
		this.throttledLog = unthrottled ? this.log : throttle(this.log, void 0, {
			leading: true,
			trailing: true
		});
		this.isUnmounted = false;
		this.lastOutput = "";
		this.lastOutputHeight = 0;
		this.fullStaticOutput = "";
		this.container = reconciler_default.createContainer(this.rootNode, import_constants.LegacyRoot, null, false, null, "id", () => {}, () => {}, () => {}, () => {}, null);
		this.unsubscribeExit = (0, import_signal_exit.default)(this.unmount, { alwaysLast: false });
		if (process$1.env["DEV"] === "true") reconciler_default.injectIntoDevTools({
			bundleType: 0,
			version: "16.13.1",
			rendererPackageName: "ink"
		});
		if (options.patchConsole) this.patchConsole();
		if (!is_in_ci_default) {
			options.stdout.on("resize", this.resized);
			this.unsubscribeResize = () => {
				options.stdout.off("resize", this.resized);
			};
		}
	}
	resized = () => {
		this.calculateLayout();
		this.onRender();
	};
	resolveExitPromise = () => {};
	rejectExitPromise = () => {};
	unsubscribeExit = () => {};
	calculateLayout = () => {
		const terminalWidth = this.options.stdout.columns || 80;
		this.rootNode.yogaNode.setWidth(terminalWidth);
		this.rootNode.yogaNode.calculateLayout(void 0, void 0, src_default.DIRECTION_LTR);
	};
	onRender = () => {
		if (this.isUnmounted) return;
		const { output, outputHeight, staticOutput } = renderer_default(this.rootNode, this.isScreenReaderEnabled);
		const hasStaticOutput = staticOutput && staticOutput !== "\n";
		if (this.options.debug) {
			if (hasStaticOutput) this.fullStaticOutput += staticOutput;
			this.options.stdout.write(this.fullStaticOutput + output);
			return;
		}
		if (is_in_ci_default) {
			if (hasStaticOutput) this.options.stdout.write(staticOutput);
			this.lastOutput = output;
			this.lastOutputHeight = outputHeight;
			return;
		}
		if (this.isScreenReaderEnabled) {
			if (hasStaticOutput) {
				const erase = this.lastOutputHeight > 0 ? eraseLines(this.lastOutputHeight) : "";
				this.options.stdout.write(erase + staticOutput);
				this.lastOutputHeight = 0;
			}
			if (output === this.lastOutput && !hasStaticOutput) return;
			const wrappedOutput = wrapAnsi(output, this.options.stdout.columns || 80, {
				trim: false,
				hard: true
			});
			if (hasStaticOutput) this.options.stdout.write(wrappedOutput);
			else {
				const erase = this.lastOutputHeight > 0 ? eraseLines(this.lastOutputHeight) : "";
				this.options.stdout.write(erase + wrappedOutput);
			}
			this.lastOutput = output;
			this.lastOutputHeight = wrappedOutput === "" ? 0 : wrappedOutput.split("\n").length;
			return;
		}
		if (hasStaticOutput) this.fullStaticOutput += staticOutput;
		if (this.lastOutputHeight >= this.options.stdout.rows) {
			this.options.stdout.write(clearTerminal + this.fullStaticOutput + output);
			this.lastOutput = output;
			this.lastOutputHeight = outputHeight;
			this.log.sync(output);
			return;
		}
		if (hasStaticOutput) {
			this.log.clear();
			this.options.stdout.write(staticOutput);
			this.log(output);
		}
		if (!hasStaticOutput && output !== this.lastOutput) this.throttledLog(output);
		this.lastOutput = output;
		this.lastOutputHeight = outputHeight;
	};
	render(node) {
		const tree = import_react.createElement(accessibilityContext.Provider, { value: { isScreenReaderEnabled: this.isScreenReaderEnabled } }, import_react.createElement(App$1, {
			stdin: this.options.stdin,
			stdout: this.options.stdout,
			stderr: this.options.stderr,
			writeToStdout: this.writeToStdout,
			writeToStderr: this.writeToStderr,
			exitOnCtrlC: this.options.exitOnCtrlC,
			onExit: this.unmount
		}, node));
		reconciler_default.updateContainerSync(tree, this.container, null, noop);
		reconciler_default.flushSyncWork();
	}
	writeToStdout(data) {
		if (this.isUnmounted) return;
		if (this.options.debug) {
			this.options.stdout.write(data + this.fullStaticOutput + this.lastOutput);
			return;
		}
		if (is_in_ci_default) {
			this.options.stdout.write(data);
			return;
		}
		this.log.clear();
		this.options.stdout.write(data);
		this.log(this.lastOutput);
	}
	writeToStderr(data) {
		if (this.isUnmounted) return;
		if (this.options.debug) {
			this.options.stderr.write(data);
			this.options.stdout.write(this.fullStaticOutput + this.lastOutput);
			return;
		}
		if (is_in_ci_default) {
			this.options.stderr.write(data);
			return;
		}
		this.log.clear();
		this.options.stderr.write(data);
		this.log(this.lastOutput);
	}
	unmount(error) {
		if (this.isUnmounted) return;
		this.calculateLayout();
		this.onRender();
		this.unsubscribeExit();
		if (typeof this.restoreConsole === "function") this.restoreConsole();
		if (typeof this.unsubscribeResize === "function") this.unsubscribeResize();
		if (is_in_ci_default) this.options.stdout.write(this.lastOutput + "\n");
		else if (!this.options.debug) this.log.done();
		this.isUnmounted = true;
		reconciler_default.updateContainerSync(null, this.container, null, noop);
		reconciler_default.flushSyncWork();
		instances_default.delete(this.options.stdout);
		if (error instanceof Error) this.rejectExitPromise(error);
		else this.resolveExitPromise();
	}
	async waitUntilExit() {
		this.exitPromise ||= new Promise((resolve$1, reject) => {
			this.resolveExitPromise = resolve$1;
			this.rejectExitPromise = reject;
		});
		return this.exitPromise;
	}
	clear() {
		if (!is_in_ci_default && !this.options.debug) this.log.clear();
	}
	patchConsole() {
		if (this.options.debug) return;
		this.restoreConsole = dist_default((stream, data) => {
			if (stream === "stdout") this.writeToStdout(data);
			if (stream === "stderr") {
				if (!data.startsWith("The above error occurred")) this.writeToStderr(data);
			}
		});
	}
};

//#endregion
//#region node_modules/ink/build/render.js
/**
Mount a component and render the output.
*/
const render = (node, options) => {
	const inkOptions = {
		stdout: process$1.stdout,
		stdin: process$1.stdin,
		stderr: process$1.stderr,
		debug: false,
		exitOnCtrlC: true,
		patchConsole: true,
		maxFps: 30,
		...getOptions(options)
	};
	const instance = getInstance(inkOptions.stdout, () => new Ink(inkOptions));
	instance.render(node);
	return {
		rerender: instance.render,
		unmount() {
			instance.unmount();
		},
		waitUntilExit: instance.waitUntilExit,
		cleanup: () => instances_default.delete(inkOptions.stdout),
		clear: instance.clear
	};
};
var render_default = render;
const getOptions = (stdout = {}) => {
	if (stdout instanceof Stream) return {
		stdout,
		stdin: process$1.stdin
	};
	return stdout;
};
const getInstance = (stdout, createInstance) => {
	let instance = instances_default.get(stdout);
	if (!instance) {
		instance = createInstance();
		instances_default.set(stdout, instance);
	}
	return instance;
};

//#endregion
//#region node_modules/ink/build/parse-keypress.js
const keyName = {
	OP: "f1",
	OQ: "f2",
	OR: "f3",
	OS: "f4",
	"[11~": "f1",
	"[12~": "f2",
	"[13~": "f3",
	"[14~": "f4",
	"[[A": "f1",
	"[[B": "f2",
	"[[C": "f3",
	"[[D": "f4",
	"[[E": "f5",
	"[15~": "f5",
	"[17~": "f6",
	"[18~": "f7",
	"[19~": "f8",
	"[20~": "f9",
	"[21~": "f10",
	"[23~": "f11",
	"[24~": "f12",
	"[A": "up",
	"[B": "down",
	"[C": "right",
	"[D": "left",
	"[E": "clear",
	"[F": "end",
	"[H": "home",
	OA: "up",
	OB: "down",
	OC: "right",
	OD: "left",
	OE: "clear",
	OF: "end",
	OH: "home",
	"[1~": "home",
	"[2~": "insert",
	"[3~": "delete",
	"[4~": "end",
	"[5~": "pageup",
	"[6~": "pagedown",
	"[[5~": "pageup",
	"[[6~": "pagedown",
	"[7~": "home",
	"[8~": "end",
	"[a": "up",
	"[b": "down",
	"[c": "right",
	"[d": "left",
	"[e": "clear",
	"[2$": "insert",
	"[3$": "delete",
	"[5$": "pageup",
	"[6$": "pagedown",
	"[7$": "home",
	"[8$": "end",
	Oa: "up",
	Ob: "down",
	Oc: "right",
	Od: "left",
	Oe: "clear",
	"[2^": "insert",
	"[3^": "delete",
	"[5^": "pageup",
	"[6^": "pagedown",
	"[7^": "home",
	"[8^": "end",
	"[Z": "tab"
};
const nonAlphanumericKeys = [...Object.values(keyName), "backspace"];

//#endregion
//#region src/shared/constants.ts
/**
* 
*/
const profileRootDir = ".ih-dopen";
/**
* 
*/
const portRange = {
	min: 1024,
	max: 65535,
	defaultStart: 9222
};
/**
* 
*/
const sessionLockFile = "session.lock";
/**
* Chrome
*/
const chromeLaunchTimeoutMs = 3e4;
/**
* 
*/
const profileNameRegex = /^[a-z\d-_]+$/;
/**
* 
*/
const profileNameMaxLength = 64;

//#endregion
//#region src/shared/errors.ts
/**
* CLI
*/
/**
* 
*/
const exitCodes = {
	success: 0,
	generalError: 1,
	configurationError: 2,
	portConflict: 3,
	profileLocked: 4,
	chromeNotFound: 5,
	chromeLaunchFailed: 6
};
/**
* CLI
*/
var CliError = class extends Error {
	constructor(message, exitCode = exitCodes.generalError) {
		super(message);
		this.exitCode = exitCode;
		this.name = this.constructor.name;
		Error.captureStackTrace(this, this.constructor);
	}
};
/**
* 
*/
var ConfigurationError = class extends CliError {
	constructor(message) {
		super(message, exitCodes.configurationError);
	}
};
/**
* 
*/
var ProfileLockedError = class extends CliError {
	constructor(message) {
		super(message, exitCodes.profileLocked);
	}
};
/**
* Chrome
*/
var ChromeNotFoundError = class extends CliError {
	constructor(message) {
		super(message, exitCodes.chromeNotFound);
	}
};
/**
* Chrome
*/
var ChromeLaunchError = class extends CliError {
	constructor(message) {
		super(message, exitCodes.chromeLaunchFailed);
	}
};

//#endregion
//#region src/domain/browserProfile.ts
/**
* 
*
* @param profileName - 
* @returns 
*/
function validateBrowserProfileName(profileName) {
	if (profileName.length === 0) return {
		valid: false,
		reason: ""
	};
	if (profileName.length > profileNameMaxLength) return {
		valid: false,
		reason: `${profileNameMaxLength}`
	};
	if (!profileNameRegex.test(profileName)) return {
		valid: false,
		reason: "(-)(_)"
	};
	return { valid: true };
}
/**
* 
*
* @param profileName - 
* @returns 
* @throws {ConfigurationError} 
*/
function resolveProfilePaths(profileName) {
	const validation = validateBrowserProfileName(profileName);
	if (!validation.valid) throw new ConfigurationError(`: ${validation.reason}`);
	const dataDirectory = join(homedir(), profileRootDir, profileName);
	return {
		dataDirectory,
		lockFilePath: join(dataDirectory, sessionLockFile)
	};
}

//#endregion
//#region src/shared/fs/userDataRoot.ts
/**
* 
*
* @returns ~/.ih-dopen 
*/
function getUserDataRoot() {
	return join(homedir(), profileRootDir);
}
/**
* 
*
* @param dirPath - 
* @returns true
*/
async function isWritable(dirPath) {
	try {
		await access(dirPath, constants$1.W_OK);
		return true;
	} catch {
		return false;
	}
}
/**
* 
*
* 
* 
*
* @returns 
* @throws {ConfigurationError} 
*/
async function ensureUserDataRoot() {
	const rootPath = getUserDataRoot();
	try {
		await mkdir(rootPath, { recursive: true });
	} catch (error) {
		throw new ConfigurationError(`: ${rootPath}\n${error instanceof Error ? error.message : String(error)}`);
	}
	if (!await isWritable(rootPath)) throw new ConfigurationError(`: ${rootPath}`);
	return rootPath;
}

//#endregion
//#region src/infrastructure/storage/profileDirectory.ts
/**
* 
*
* @param profileName - 
* @returns 
* @throws {ConfigurationError} 
*/
async function ensureProfileDirectory(profileName) {
	const { dataDirectory, lockFilePath } = resolveProfilePaths(profileName);
	await ensureUserDataRoot();
	try {
		await mkdir(dataDirectory, { recursive: true });
	} catch (error) {
		throw new ConfigurationError(`: ${dataDirectory}\n${error instanceof Error ? error.message : String(error)}`);
	}
	try {
		if (!(await stat(dataDirectory)).isDirectory()) throw new ConfigurationError(`: ${dataDirectory}`);
	} catch (error) {
		if (error instanceof ConfigurationError) throw error;
		throw new ConfigurationError(`: ${dataDirectory}\n${error instanceof Error ? error.message : String(error)}`);
	}
	try {
		await access(dataDirectory, constants.W_OK);
	} catch (error) {
		throw new ConfigurationError(`: ${dataDirectory}\n${error instanceof Error ? error.message : String(error)}`);
	}
	return {
		dataDirectory,
		lockFilePath,
		locked: await detectLockFile(lockFilePath)
	};
}
/**
* 
*
* @param lockFilePath - 
* @returns true
*/
async function detectLockFile(lockFilePath) {
	try {
		await access(lockFilePath, constants.F_OK);
		return true;
	} catch (error) {
		if (error.code === "ENOENT") return false;
		return true;
	}
}

//#endregion
//#region src/application/services/profileService.ts
const metadataFileName = "profile.json";
/**
* 
*
* @param profileName - 
* @returns 
*/
async function getProfileState(profileName) {
	const directoryState = await ensureProfileDirectory(profileName);
	return createProfileState(profileName, directoryState, await loadOrCreateMetadata(join(directoryState.dataDirectory, metadataFileName), profileName));
}
/**
* 
*
* @param profileName - 
* @returns 
* @throws {ProfileLockedError} 
*/
async function prepareProfile(profileName) {
	const state = await getProfileState(profileName);
	if (state.locked) throw new ProfileLockedError(` "${profileName}" Chrome`);
	return {
		...state,
		locked: false
	};
}
/**
* 
*
* @param profileName - 
* @param launchedAt - 
* @returns 
* @throws {ProfileLockedError} 
*/
async function updateLastLaunchedAt(profileName, launchedAt) {
	const directoryState = await ensureProfileDirectory(profileName);
	if (directoryState.locked) throw new ProfileLockedError(` "${profileName}" Chrome`);
	const metadataPath = join(directoryState.dataDirectory, metadataFileName);
	const updatedMetadata = {
		...await loadOrCreateMetadata(metadataPath, profileName),
		lastLaunchedAt: launchedAt.toISOString()
	};
	await writeMetadata(metadataPath, updatedMetadata);
	return {
		...createProfileState(profileName, directoryState, updatedMetadata, false),
		lastLaunchedAt: new Date(updatedMetadata.lastLaunchedAt)
	};
}
async function loadOrCreateMetadata(path$1, profileName) {
	try {
		const content = await readFile(path$1, "utf8");
		const parsed = JSON.parse(content);
		if (typeof parsed.createdAt === "string" && "lastLaunchedAt" in parsed) return {
			profileName: parsed.profileName ?? profileName,
			createdAt: parsed.createdAt,
			lastLaunchedAt: parsed.lastLaunchedAt ?? null
		};
	} catch (error) {
		if (error.code !== "ENOENT") {}
	}
	const metadata = {
		profileName,
		createdAt: (/* @__PURE__ */ new Date()).toISOString(),
		lastLaunchedAt: null
	};
	await writeMetadata(path$1, metadata);
	return metadata;
}
async function writeMetadata(path$1, metadata) {
	await writeFile(path$1, `${JSON.stringify(metadata, null, 2)}\n`, "utf8");
}
function createProfileState(profileName, directoryState, metadata, lockedOverride) {
	return {
		profileName,
		dataDirectory: directoryState.dataDirectory,
		lockFilePath: directoryState.lockFilePath,
		locked: lockedOverride ?? directoryState.locked,
		createdAt: new Date(metadata.createdAt),
		...metadata.lastLaunchedAt ? { lastLaunchedAt: new Date(metadata.lastLaunchedAt) } : {}
	};
}

//#endregion
//#region src/infrastructure/chrome/detectChromeExecutable.ts
/**
* Chrome
*/
const defaultChromePaths = {
	darwin: [
		"/Applications/Google Chrome.app/Contents/MacOS/Google Chrome",
		"/Applications/Google Chrome Canary.app/Contents/MacOS/Google Chrome Canary",
		"/Applications/Chromium.app/Contents/MacOS/Chromium"
	],
	linux: [
		"/usr/bin/google-chrome-stable",
		"/usr/bin/google-chrome",
		"/usr/bin/chromium-browser",
		"/usr/bin/chromium",
		"/snap/bin/chromium"
	]
};
/**
* 
*
* @param path - 
* @returns true
*/
function isExecutable(path$1) {
	try {
		accessSync(path$1, constants.X_OK);
		return true;
	} catch {
		return false;
	}
}
/**
* WhichChrome
*
* @returns null
*/
function findChromeViaWhich() {
	for (const command of [
		"google-chrome-stable",
		"google-chrome",
		"chromium-browser",
		"chromium"
	]) try {
		const path$1 = execSync(`which ${command}`, {
			encoding: "utf8",
			stdio: [
				"ignore",
				"pipe",
				"ignore"
			]
		}).trim();
		if (path$1 && isExecutable(path$1)) return path$1;
	} catch {
		continue;
	}
}
/**
* Chrome
*
* :
* 1. CHROME_PATH
* 2. 
* 3. which
*
* @returns Chrome
* @throws {ChromeNotFoundError} Chrome
*/
function detectChromeExecutable() {
	const chromePathEnv = process$1.env["CHROME_PATH"];
	if (chromePathEnv) {
		if (isExecutable(chromePathEnv)) return chromePathEnv;
		throw new ChromeNotFoundError(`CHROME_PATH: ${chromePathEnv}`);
	}
	const { platform: platform$1 } = process$1;
	const defaultPaths = defaultChromePaths[platform$1] ?? [];
	for (const path$1 of defaultPaths) if (isExecutable(path$1)) return path$1;
	if (platform$1 === "linux") {
		const whichResult = findChromeViaWhich();
		if (whichResult) return whichResult;
	}
	throw new ChromeNotFoundError("ChromeCHROME_PATH--chrome-path");
}

//#endregion
//#region src/infrastructure/chrome/chromeArguments.ts
/**
* ChromeArgumentsParametersChrome
*
* @param params - Chrome
* @returns Chrome
*/
function buildChromeArguments(parameters) {
	const { port: port$1, userDataDir, url, additionalArgs = [] } = parameters;
	return [
		`--remote-debugging-port=${port$1}`,
		`--user-data-dir=${userDataDir}`,
		"--no-first-run",
		...additionalArgs,
		url
	];
}

//#endregion
//#region src/domain/remoteDebugSession.ts
/**
* 
*
* @param params - 
* @returns 
*/
function buildRemoteDebugSession(parameters) {
	return {
		sessionId: randomUUID(),
		profileName: parameters.profileName,
		targetUrl: parameters.targetUrl,
		port: parameters.port,
		launchedAt: /* @__PURE__ */ new Date(),
		status: parameters.initialStatus ?? "launching"
	};
}

//#endregion
//#region src/infrastructure/chrome/spawnChrome.ts
/**
* ChromeDevTools
*
* @param params - Chrome
* @returns 
*/
async function spawnChrome(parameters) {
	const session = buildRemoteDebugSession({
		profileName: parameters.profileName,
		targetUrl: parameters.targetUrl,
		port: parameters.port,
		initialStatus: "launching"
	});
	return new Promise((resolve$1, reject) => {
		const chromeProcess = spawn(parameters.executablePath, parameters.args, {
			stdio: [
				"ignore",
				"pipe",
				"pipe"
			],
			detached: false
		});
		let wsEndpoint;
		let timeoutId;
		let settled = false;
		let stderrBuffer = "";
		const stderrDecoder = new TextDecoder();
		const stderrDataHandler = (data) => {
			stderrBuffer += stderrDecoder.decode(data, { stream: true });
			const match = /DevTools listening on (ws:\/\/\S+)/.exec(stderrBuffer);
			if (match?.[1]) {
				wsEndpoint = match[1];
				const { pid } = chromeProcess;
				if (pid === void 0) {
					cleanup();
					if (!settled) {
						settled = true;
						reject(new ChromeLaunchError("ChromePID"));
					}
					return;
				}
				cleanup();
				if (!settled) {
					settled = true;
					resolve$1({
						...session,
						wsEndpoint,
						chromeProcessPid: pid,
						status: "ready"
					});
				}
			}
		};
		const errorHandler = (error) => {
			cleanup();
			if (!settled) {
				settled = true;
				reject(new ChromeLaunchError(`Chrome: ${error.message}`));
			}
		};
		const exitHandler = (code, signal) => {
			if (!wsEndpoint) {
				cleanup();
				if (!settled) {
					settled = true;
					reject(new ChromeLaunchError(`Chrome: ${code}, : ${signal}`));
				}
			}
		};
		const timeoutHandler = () => {
			chromeProcess.kill();
			cleanup();
			if (!settled) {
				settled = true;
				reject(new ChromeLaunchError(`Chrome${chromeLaunchTimeoutMs}msDevTools`));
			}
		};
		const cleanup = () => {
			stderrBuffer = "";
			stderrDecoder.decode();
			if (timeoutId) {
				clearTimeout(timeoutId);
				timeoutId = void 0;
			}
			chromeProcess.stderr?.removeListener("data", stderrDataHandler);
			chromeProcess.removeListener("error", errorHandler);
			chromeProcess.removeListener("exit", exitHandler);
		};
		timeoutId = setTimeout(timeoutHandler, chromeLaunchTimeoutMs);
		chromeProcess.stderr?.on("data", stderrDataHandler);
		chromeProcess.on("error", errorHandler);
		chromeProcess.on("exit", exitHandler);
	});
}

//#endregion
//#region src/domain/portAllocation.ts
/**
* 
*
* @param port - 
* @returns 
* @throws {ConfigurationError} 
*/
function validatePortRange(port$1) {
	if (!Number.isInteger(port$1)) throw new ConfigurationError(`: ${port$1}`);
	if (port$1 < portRange.min || port$1 > portRange.max) throw new ConfigurationError(`${portRange.min}${portRange.max}: ${port$1}`);
}

//#endregion
//#region src/infrastructure/ports/checkPortAvailability.ts
/**
* 
*
* net.createServer
* 
*
* @param port - 
* @param requestedByUser - 
* @returns 
*/
async function checkPortAvailability(port$1, requestedByUser) {
	try {
		validatePortRange(port$1);
	} catch (error) {
		return {
			port: port$1,
			requestedByUser,
			validationOutcome: "error",
			errorMessage: error instanceof Error ? error.message : String(error)
		};
	}
	return new Promise((resolve$1) => {
		const server = createServer();
		server.once("error", (error) => {
			if (error.code === "EADDRINUSE") resolve$1({
				port: port$1,
				requestedByUser,
				validationOutcome: "occupied"
			});
			else resolve$1({
				port: port$1,
				requestedByUser,
				validationOutcome: "error",
				errorMessage: error.message
			});
		});
		server.once("listening", () => {
			server.close(() => {
				resolve$1({
					port: port$1,
					requestedByUser,
					validationOutcome: "available"
				});
			});
		});
		server.listen(port$1, "127.0.0.1");
	});
}

//#endregion
//#region src/infrastructure/ports/autoAllocatePort.ts
/**
* 
*
* @param userPort - undefined
* @returns 
*/
async function autoAllocatePort(userPort) {
	if (userPort !== void 0) return checkPortAvailability(userPort, true);
	return new Promise((resolve$1, reject) => {
		const server = createServer();
		server.once("error", (error) => {
			reject(error);
		});
		server.once("listening", () => {
			const address = server.address();
			if (!address || typeof address === "string") {
				server.close();
				reject(/* @__PURE__ */ new Error(""));
				return;
			}
			const allocatedPort = address.port;
			server.close(() => {
				resolve$1({
					port: allocatedPort,
					requestedByUser: false,
					validationOutcome: "available"
				});
			});
		});
		server.listen(0, "127.0.0.1");
	});
}

//#endregion
//#region src/infrastructure/session/sessionRegistry.ts
/**
* ID
*/
const sessionsByIdMap = /* @__PURE__ */ new Map();
/**
* 
*/
const sessionsByProfileMap = /* @__PURE__ */ new Map();
/**
* 
*
* @param session - 
* @throws ID
*/
function registerSession(session) {
	if (sessionsByIdMap.get(session.sessionId)) throw new Error(`sessionId ${session.sessionId} `);
	if (sessionsByProfileMap.get(session.profileName)) throw new Error(` ${session.profileName} `);
	sessionsByIdMap.set(session.sessionId, session);
	sessionsByProfileMap.set(session.profileName, session);
}
/**
* 
*
* @param profileName - 
* @returns undefined
*/
function findSessionByProfile(profileName) {
	return sessionsByProfileMap.get(profileName);
}

//#endregion
//#region src/infrastructure/ports/suggestPorts.ts
/**
* 
*/
/**
* 
*/
const maxPort = 65535;
/**
* 
*/
const maxSuggestions = 3;
/**
* 
*
* @param conflictedPort - 
* @returns 3
*/
function suggestAlternativePorts(conflictedPort) {
	const suggestions = [];
	for (let index = 1; index <= maxSuggestions; index++) {
		const candidatePort = conflictedPort + index;
		if (candidatePort > maxPort) break;
		suggestions.push(candidatePort);
	}
	return suggestions;
}

//#endregion
//#region src/application/services/remoteDebuggingService.ts
/**
* 
*
* @param request - 
* @returns 
*/
async function createSession(request) {
	const startTime$1 = Date.now();
	if (findSessionByProfile(request.profileName)) throw new Error(` ${request.profileName} `);
	const executablePath = request.chromePath ?? detectChromeExecutable();
	const { dataDirectory } = resolveProfilePaths(request.profileName);
	const portResult = await autoAllocatePort(request.port);
	if (portResult.validationOutcome !== "available") {
		const suggestedPorts = suggestAlternativePorts(portResult.port);
		const suggestionMessage = suggestedPorts.length > 0 ? ` : ${suggestedPorts.join(", ")}` : "";
		throw new Error(`${portResult.port}: ${portResult.errorMessage ?? ""}${suggestionMessage}`);
	}
	const session = await spawnChrome({
		executablePath,
		args: buildChromeArguments({
			port: portResult.port,
			userDataDir: dataDirectory,
			url: request.url,
			...request.additionalArgs && { additionalArgs: request.additionalArgs }
		}),
		profileName: request.profileName,
		targetUrl: request.url,
		port: portResult.port
	});
	const endTime = Date.now();
	return {
		sessionId: session.sessionId,
		port: session.port,
		wsEndpoint: session.wsEndpoint ?? "",
		profile: {
			profileName: request.profileName,
			dataDirectory,
			locked: true,
			lastLaunchedAt: session.launchedAt
		},
		launchDurationMs: endTime - startTime$1,
		...session.chromeProcessPid !== void 0 && { chromeProcessPid: session.chromeProcessPid }
	};
}

//#endregion
//#region src/usecase/createRemoteDebugSession.ts
/**
* CLI
*
* @param args - CLI
* @returns 
*/
async function createRemoteDebugSession(args) {
	await prepareProfile(args.profile);
	const session = await createSession({
		url: args.url,
		profileName: args.profile,
		...args.port !== void 0 && { port: args.port },
		...args.chromePath !== void 0 && { chromePath: args.chromePath },
		...args.additionalArgs !== void 0 && { additionalArgs: args.additionalArgs }
	});
	registerSession({
		...buildRemoteDebugSession({
			profileName: args.profile,
			targetUrl: args.url,
			port: session.port,
			initialStatus: "ready"
		}),
		sessionId: session.sessionId,
		wsEndpoint: session.wsEndpoint,
		chromeProcessPid: session.chromeProcessPid,
		launchedAt: session.profile.lastLaunchedAt ?? /* @__PURE__ */ new Date()
	});
	const launchedAt = session.profile.lastLaunchedAt ?? /* @__PURE__ */ new Date();
	const updatedProfile = await updateLastLaunchedAt(args.profile, launchedAt);
	return {
		...session,
		profile: {
			profileName: updatedProfile.profileName,
			dataDirectory: updatedProfile.dataDirectory,
			locked: updatedProfile.locked,
			lastLaunchedAt: updatedProfile.lastLaunchedAt
		}
	};
}

//#endregion
//#region node_modules/react/cjs/react-jsx-runtime.production.js
var require_react_jsx_runtime_production = /* @__PURE__ */ __commonJS({ "node_modules/react/cjs/react-jsx-runtime.production.js": ((exports) => {
	var REACT_ELEMENT_TYPE = Symbol.for("react.transitional.element"), REACT_FRAGMENT_TYPE = Symbol.for("react.fragment");
	function jsxProd(type, config, maybeKey) {
		var key = null;
		void 0 !== maybeKey && (key = "" + maybeKey);
		void 0 !== config.key && (key = "" + config.key);
		if ("key" in config) {
			maybeKey = {};
			for (var propName in config) "key" !== propName && (maybeKey[propName] = config[propName]);
		} else maybeKey = config;
		config = maybeKey.ref;
		return {
			$$typeof: REACT_ELEMENT_TYPE,
			type,
			key,
			ref: void 0 !== config ? config : null,
			props: maybeKey
		};
	}
	exports.Fragment = REACT_FRAGMENT_TYPE;
	exports.jsx = jsxProd;
	exports.jsxs = jsxProd;
}) });

//#endregion
//#region node_modules/react/jsx-runtime.js
var require_jsx_runtime = /* @__PURE__ */ __commonJS({ "node_modules/react/jsx-runtime.js": ((exports, module) => {
	module.exports = require_react_jsx_runtime_production();
}) });

//#endregion
//#region src/ui/components/ProfileSummary.tsx
var import_jsx_runtime = /* @__PURE__ */ __toESM(require_jsx_runtime());
/**
* 
*
* @param props - 
* @returns 
*/
function ProfileSummary({ profile }) {
	const restoreMessage = profile.lastLaunchedAt ? ` ${profile.lastLaunchedAt.toISOString()} ` : "";
	return /* @__PURE__ */ (0, import_jsx_runtime.jsxs)(Box_default, {
		flexDirection: "column",
		children: [/* @__PURE__ */ (0, import_jsx_runtime.jsxs)(Text, { children: [": ", profile.dataDirectory] }), /* @__PURE__ */ (0, import_jsx_runtime.jsxs)(Text, { children: [": ", restoreMessage] })]
	});
}

//#endregion
//#region src/app.tsx
function App({ args }) {
	const [state, setState] = (0, import_react.useState)({ status: "loading" });
	const { url, profile, port: port$1, chromePath, additionalArgs } = args;
	const normalizedArgs = (0, import_react.useMemo)(() => {
		return {
			url,
			profile,
			...port$1 !== void 0 && { port: port$1 },
			...chromePath !== void 0 && { chromePath },
			...additionalArgs !== void 0 && { additionalArgs }
		};
	}, [
		url,
		profile,
		port$1,
		chromePath,
		additionalArgs
	]);
	(0, import_react.useEffect)(() => {
		let mounted = true;
		const run = async () => {
			try {
				const response$1 = await createRemoteDebugSession(normalizedArgs);
				if (mounted) setState({
					status: "success",
					response: response$1
				});
			} catch (error) {
				if (mounted) setState({
					status: "error",
					error: error instanceof Error ? error : /* @__PURE__ */ new Error("")
				});
			}
		};
		run();
		return () => {
			mounted = false;
		};
	}, [normalizedArgs]);
	if (state.status === "loading") return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Box_default, {
		flexDirection: "column",
		children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Text, { children: "Chrome..." })
	});
	if (state.status === "error") return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Box_default, {
		flexDirection: "column",
		children: state.error instanceof ConfigurationError ? /* @__PURE__ */ (0, import_jsx_runtime.jsxs)(import_jsx_runtime.Fragment, { children: [/* @__PURE__ */ (0, import_jsx_runtime.jsx)(Text, {
			color: "red",
			children: ""
		}), /* @__PURE__ */ (0, import_jsx_runtime.jsxs)(Text, {
			color: "red",
			children: [": ", state.error.message]
		})] }) : /* @__PURE__ */ (0, import_jsx_runtime.jsxs)(Text, {
			color: "red",
			children: [": ", state.error.message]
		})
	});
	const { response } = state;
	return /* @__PURE__ */ (0, import_jsx_runtime.jsxs)(Box_default, {
		flexDirection: "column",
		children: [
			/* @__PURE__ */ (0, import_jsx_runtime.jsx)(Text, {
				color: "green",
				children: " Chrome"
			}),
			/* @__PURE__ */ (0, import_jsx_runtime.jsx)(ProfileSummary, { profile: response.profile }),
			/* @__PURE__ */ (0, import_jsx_runtime.jsxs)(Text, { children: [": ", response.port] }),
			/* @__PURE__ */ (0, import_jsx_runtime.jsxs)(Text, { children: ["DevTools: ", response.wsEndpoint] }),
			response.chromeProcessPid ? /* @__PURE__ */ (0, import_jsx_runtime.jsxs)(Text, { children: ["ID: ", response.chromeProcessPid] }) : null,
			response.launchDurationMs ? /* @__PURE__ */ (0, import_jsx_runtime.jsxs)(Text, { children: [
				": ",
				response.launchDurationMs,
				"ms"
			] }) : null
		]
	});
}

//#endregion
//#region node_modules/meow/build/dependencies.js
function camelCase$1(str) {
	if (!(str !== str.toLowerCase() && str !== str.toUpperCase())) str = str.toLowerCase();
	if (str.indexOf("-") === -1 && str.indexOf("_") === -1) return str;
	else {
		let camelcase = "";
		let nextChrUpper = false;
		const leadingHyphens = str.match(/^-+/);
		for (let i = leadingHyphens ? leadingHyphens[0].length : 0; i < str.length; i++) {
			let chr = str.charAt(i);
			if (nextChrUpper) {
				nextChrUpper = false;
				chr = chr.toUpperCase();
			}
			if (i !== 0 && (chr === "-" || chr === "_")) nextChrUpper = true;
			else if (chr !== "-" && chr !== "_") camelcase += chr;
		}
		return camelcase;
	}
}
function decamelize$1(str, joinString) {
	const lowercase = str.toLowerCase();
	joinString = joinString || "-";
	let notCamelcase = "";
	for (let i = 0; i < str.length; i++) {
		const chrLower = lowercase.charAt(i);
		const chrString = str.charAt(i);
		if (chrLower !== chrString && i > 0) notCamelcase += `${joinString}${lowercase.charAt(i)}`;
		else notCamelcase += chrString;
	}
	return notCamelcase;
}
function looksLikeNumber(x) {
	if (x === null || x === void 0) return false;
	if (typeof x === "number") return true;
	if (/^0x[0-9a-f]+$/i.test(x)) return true;
	if (/^0[^.]/.test(x)) return false;
	return /^[-]?(?:\d+(?:\.\d*)?|\.\d+)(e[-+]?\d+)?$/.test(x);
}
function tokenizeArgString(argString) {
	if (Array.isArray(argString)) return argString.map((e) => typeof e !== "string" ? e + "" : e);
	argString = argString.trim();
	let i = 0;
	let prevC = null;
	let c = null;
	let opening = null;
	const args = [];
	for (let ii = 0; ii < argString.length; ii++) {
		prevC = c;
		c = argString.charAt(ii);
		if (c === " " && !opening) {
			if (!(prevC === " ")) i++;
			continue;
		}
		if (c === opening) opening = null;
		else if ((c === "'" || c === "\"") && !opening) opening = c;
		if (!args[i]) args[i] = "";
		args[i] += c;
	}
	return args;
}
var DefaultValuesForTypeKey;
(function(DefaultValuesForTypeKey$1) {
	DefaultValuesForTypeKey$1["BOOLEAN"] = "boolean";
	DefaultValuesForTypeKey$1["STRING"] = "string";
	DefaultValuesForTypeKey$1["NUMBER"] = "number";
	DefaultValuesForTypeKey$1["ARRAY"] = "array";
})(DefaultValuesForTypeKey || (DefaultValuesForTypeKey = {}));
let mixin;
var YargsParser = class {
	constructor(_mixin) {
		mixin = _mixin;
	}
	parse(argsInput, options) {
		const opts = Object.assign({
			alias: void 0,
			array: void 0,
			boolean: void 0,
			config: void 0,
			configObjects: void 0,
			configuration: void 0,
			coerce: void 0,
			count: void 0,
			default: void 0,
			envPrefix: void 0,
			narg: void 0,
			normalize: void 0,
			string: void 0,
			number: void 0,
			__: void 0,
			key: void 0
		}, options);
		const args = tokenizeArgString(argsInput);
		const inputIsString = typeof argsInput === "string";
		const aliases = combineAliases(Object.assign(Object.create(null), opts.alias));
		const configuration = Object.assign({
			"boolean-negation": true,
			"camel-case-expansion": true,
			"combine-arrays": false,
			"dot-notation": true,
			"duplicate-arguments-array": true,
			"flatten-duplicate-arrays": true,
			"greedy-arrays": true,
			"halt-at-non-option": false,
			"nargs-eats-options": false,
			"negation-prefix": "no-",
			"parse-numbers": true,
			"parse-positional-numbers": true,
			"populate--": false,
			"set-placeholder-key": false,
			"short-option-groups": true,
			"strip-aliased": false,
			"strip-dashed": false,
			"unknown-options-as-args": false
		}, opts.configuration);
		const defaults = Object.assign(Object.create(null), opts.default);
		const configObjects = opts.configObjects || [];
		const envPrefix = opts.envPrefix;
		const notFlagsOption = configuration["populate--"];
		const notFlagsArgv = notFlagsOption ? "--" : "_";
		const newAliases = Object.create(null);
		const defaulted = Object.create(null);
		const __ = opts.__ || mixin.format;
		const flags = {
			aliases: Object.create(null),
			arrays: Object.create(null),
			bools: Object.create(null),
			strings: Object.create(null),
			numbers: Object.create(null),
			counts: Object.create(null),
			normalize: Object.create(null),
			configs: Object.create(null),
			nargs: Object.create(null),
			coercions: Object.create(null),
			keys: []
		};
		const negative = /^-([0-9]+(\.[0-9]+)?|\.[0-9]+)$/;
		const negatedBoolean = /* @__PURE__ */ new RegExp("^--" + configuration["negation-prefix"] + "(.+)");
		[].concat(opts.array || []).filter(Boolean).forEach(function(opt) {
			const key = typeof opt === "object" ? opt.key : opt;
			const assignment = Object.keys(opt).map(function(key$1) {
				return {
					boolean: "bools",
					string: "strings",
					number: "numbers"
				}[key$1];
			}).filter(Boolean).pop();
			if (assignment) flags[assignment][key] = true;
			flags.arrays[key] = true;
			flags.keys.push(key);
		});
		[].concat(opts.boolean || []).filter(Boolean).forEach(function(key) {
			flags.bools[key] = true;
			flags.keys.push(key);
		});
		[].concat(opts.string || []).filter(Boolean).forEach(function(key) {
			flags.strings[key] = true;
			flags.keys.push(key);
		});
		[].concat(opts.number || []).filter(Boolean).forEach(function(key) {
			flags.numbers[key] = true;
			flags.keys.push(key);
		});
		[].concat(opts.count || []).filter(Boolean).forEach(function(key) {
			flags.counts[key] = true;
			flags.keys.push(key);
		});
		[].concat(opts.normalize || []).filter(Boolean).forEach(function(key) {
			flags.normalize[key] = true;
			flags.keys.push(key);
		});
		if (typeof opts.narg === "object") Object.entries(opts.narg).forEach(([key, value]) => {
			if (typeof value === "number") {
				flags.nargs[key] = value;
				flags.keys.push(key);
			}
		});
		if (typeof opts.coerce === "object") Object.entries(opts.coerce).forEach(([key, value]) => {
			if (typeof value === "function") {
				flags.coercions[key] = value;
				flags.keys.push(key);
			}
		});
		if (typeof opts.config !== "undefined") {
			if (Array.isArray(opts.config) || typeof opts.config === "string") [].concat(opts.config).filter(Boolean).forEach(function(key) {
				flags.configs[key] = true;
			});
			else if (typeof opts.config === "object") Object.entries(opts.config).forEach(([key, value]) => {
				if (typeof value === "boolean" || typeof value === "function") flags.configs[key] = value;
			});
		}
		extendAliases(opts.key, aliases, opts.default, flags.arrays);
		Object.keys(defaults).forEach(function(key) {
			(flags.aliases[key] || []).forEach(function(alias) {
				defaults[alias] = defaults[key];
			});
		});
		let error = null;
		checkConfiguration();
		let notFlags = [];
		const argv$1 = Object.assign(Object.create(null), { _: [] });
		const argvReturn = {};
		for (let i = 0; i < args.length; i++) {
			const arg = args[i];
			const truncatedArg = arg.replace(/^-{3,}/, "---");
			let broken;
			let key;
			let letters;
			let m;
			let next;
			let value;
			if (arg !== "--" && /^-/.test(arg) && isUnknownOptionAsArg(arg)) pushPositional(arg);
			else if (truncatedArg.match(/^---+(=|$)/)) {
				pushPositional(arg);
				continue;
			} else if (arg.match(/^--.+=/) || !configuration["short-option-groups"] && arg.match(/^-.+=/)) {
				m = arg.match(/^--?([^=]+)=([\s\S]*)$/);
				if (m !== null && Array.isArray(m) && m.length >= 3) if (checkAllAliases(m[1], flags.arrays)) i = eatArray(i, m[1], args, m[2]);
				else if (checkAllAliases(m[1], flags.nargs) !== false) i = eatNargs(i, m[1], args, m[2]);
				else setArg(m[1], m[2], true);
			} else if (arg.match(negatedBoolean) && configuration["boolean-negation"]) {
				m = arg.match(negatedBoolean);
				if (m !== null && Array.isArray(m) && m.length >= 2) {
					key = m[1];
					setArg(key, checkAllAliases(key, flags.arrays) ? [false] : false);
				}
			} else if (arg.match(/^--.+/) || !configuration["short-option-groups"] && arg.match(/^-[^-]+/)) {
				m = arg.match(/^--?(.+)/);
				if (m !== null && Array.isArray(m) && m.length >= 2) {
					key = m[1];
					if (checkAllAliases(key, flags.arrays)) i = eatArray(i, key, args);
					else if (checkAllAliases(key, flags.nargs) !== false) i = eatNargs(i, key, args);
					else {
						next = args[i + 1];
						if (next !== void 0 && (!next.match(/^-/) || next.match(negative)) && !checkAllAliases(key, flags.bools) && !checkAllAliases(key, flags.counts)) {
							setArg(key, next);
							i++;
						} else if (/^(true|false)$/.test(next)) {
							setArg(key, next);
							i++;
						} else setArg(key, defaultValue(key));
					}
				}
			} else if (arg.match(/^-.\..+=/)) {
				m = arg.match(/^-([^=]+)=([\s\S]*)$/);
				if (m !== null && Array.isArray(m) && m.length >= 3) setArg(m[1], m[2]);
			} else if (arg.match(/^-.\..+/) && !arg.match(negative)) {
				next = args[i + 1];
				m = arg.match(/^-(.\..+)/);
				if (m !== null && Array.isArray(m) && m.length >= 2) {
					key = m[1];
					if (next !== void 0 && !next.match(/^-/) && !checkAllAliases(key, flags.bools) && !checkAllAliases(key, flags.counts)) {
						setArg(key, next);
						i++;
					} else setArg(key, defaultValue(key));
				}
			} else if (arg.match(/^-[^-]+/) && !arg.match(negative)) {
				letters = arg.slice(1, -1).split("");
				broken = false;
				for (let j = 0; j < letters.length; j++) {
					next = arg.slice(j + 2);
					if (letters[j + 1] && letters[j + 1] === "=") {
						value = arg.slice(j + 3);
						key = letters[j];
						if (checkAllAliases(key, flags.arrays)) i = eatArray(i, key, args, value);
						else if (checkAllAliases(key, flags.nargs) !== false) i = eatNargs(i, key, args, value);
						else setArg(key, value);
						broken = true;
						break;
					}
					if (next === "-") {
						setArg(letters[j], next);
						continue;
					}
					if (/[A-Za-z]/.test(letters[j]) && /^-?\d+(\.\d*)?(e-?\d+)?$/.test(next) && checkAllAliases(next, flags.bools) === false) {
						setArg(letters[j], next);
						broken = true;
						break;
					}
					if (letters[j + 1] && letters[j + 1].match(/\W/)) {
						setArg(letters[j], next);
						broken = true;
						break;
					} else setArg(letters[j], defaultValue(letters[j]));
				}
				key = arg.slice(-1)[0];
				if (!broken && key !== "-") if (checkAllAliases(key, flags.arrays)) i = eatArray(i, key, args);
				else if (checkAllAliases(key, flags.nargs) !== false) i = eatNargs(i, key, args);
				else {
					next = args[i + 1];
					if (next !== void 0 && (!/^(-|--)[^-]/.test(next) || next.match(negative)) && !checkAllAliases(key, flags.bools) && !checkAllAliases(key, flags.counts)) {
						setArg(key, next);
						i++;
					} else if (/^(true|false)$/.test(next)) {
						setArg(key, next);
						i++;
					} else setArg(key, defaultValue(key));
				}
			} else if (arg.match(/^-[0-9]$/) && arg.match(negative) && checkAllAliases(arg.slice(1), flags.bools)) {
				key = arg.slice(1);
				setArg(key, defaultValue(key));
			} else if (arg === "--") {
				notFlags = args.slice(i + 1);
				break;
			} else if (configuration["halt-at-non-option"]) {
				notFlags = args.slice(i);
				break;
			} else pushPositional(arg);
		}
		applyEnvVars(argv$1, true);
		applyEnvVars(argv$1, false);
		setConfig(argv$1);
		setConfigObjects();
		applyDefaultsAndAliases(argv$1, flags.aliases, defaults, true);
		applyCoercions(argv$1);
		if (configuration["set-placeholder-key"]) setPlaceholderKeys(argv$1);
		Object.keys(flags.counts).forEach(function(key) {
			if (!hasKey(argv$1, key.split("."))) setArg(key, 0);
		});
		if (notFlagsOption && notFlags.length) argv$1[notFlagsArgv] = [];
		notFlags.forEach(function(key) {
			argv$1[notFlagsArgv].push(key);
		});
		if (configuration["camel-case-expansion"] && configuration["strip-dashed"]) Object.keys(argv$1).filter((key) => key !== "--" && key.includes("-")).forEach((key) => {
			delete argv$1[key];
		});
		if (configuration["strip-aliased"]) [].concat(...Object.keys(aliases).map((k) => aliases[k])).forEach((alias) => {
			if (configuration["camel-case-expansion"] && alias.includes("-")) delete argv$1[alias.split(".").map((prop) => camelCase$1(prop)).join(".")];
			delete argv$1[alias];
		});
		function pushPositional(arg) {
			const maybeCoercedNumber = maybeCoerceNumber("_", arg);
			if (typeof maybeCoercedNumber === "string" || typeof maybeCoercedNumber === "number") argv$1._.push(maybeCoercedNumber);
		}
		function eatNargs(i, key, args$1, argAfterEqualSign) {
			let ii;
			let toEat = checkAllAliases(key, flags.nargs);
			toEat = typeof toEat !== "number" || isNaN(toEat) ? 1 : toEat;
			if (toEat === 0) {
				if (!isUndefined(argAfterEqualSign)) error = Error(__("Argument unexpected for: %s", key));
				setArg(key, defaultValue(key));
				return i;
			}
			let available = isUndefined(argAfterEqualSign) ? 0 : 1;
			if (configuration["nargs-eats-options"]) {
				if (args$1.length - (i + 1) + available < toEat) error = Error(__("Not enough arguments following: %s", key));
				available = toEat;
			} else {
				for (ii = i + 1; ii < args$1.length; ii++) if (!args$1[ii].match(/^-[^0-9]/) || args$1[ii].match(negative) || isUnknownOptionAsArg(args$1[ii])) available++;
				else break;
				if (available < toEat) error = Error(__("Not enough arguments following: %s", key));
			}
			let consumed = Math.min(available, toEat);
			if (!isUndefined(argAfterEqualSign) && consumed > 0) {
				setArg(key, argAfterEqualSign);
				consumed--;
			}
			for (ii = i + 1; ii < consumed + i + 1; ii++) setArg(key, args$1[ii]);
			return i + consumed;
		}
		function eatArray(i, key, args$1, argAfterEqualSign) {
			let argsToSet = [];
			let next = argAfterEqualSign || args$1[i + 1];
			const nargsCount = checkAllAliases(key, flags.nargs);
			if (checkAllAliases(key, flags.bools) && !/^(true|false)$/.test(next)) argsToSet.push(true);
			else if (isUndefined(next) || isUndefined(argAfterEqualSign) && /^-/.test(next) && !negative.test(next) && !isUnknownOptionAsArg(next)) {
				if (defaults[key] !== void 0) {
					const defVal = defaults[key];
					argsToSet = Array.isArray(defVal) ? defVal : [defVal];
				}
			} else {
				if (!isUndefined(argAfterEqualSign)) argsToSet.push(processValue(key, argAfterEqualSign, true));
				for (let ii = i + 1; ii < args$1.length; ii++) {
					if (!configuration["greedy-arrays"] && argsToSet.length > 0 || nargsCount && typeof nargsCount === "number" && argsToSet.length >= nargsCount) break;
					next = args$1[ii];
					if (/^-/.test(next) && !negative.test(next) && !isUnknownOptionAsArg(next)) break;
					i = ii;
					argsToSet.push(processValue(key, next, inputIsString));
				}
			}
			if (typeof nargsCount === "number" && (nargsCount && argsToSet.length < nargsCount || isNaN(nargsCount) && argsToSet.length === 0)) error = Error(__("Not enough arguments following: %s", key));
			setArg(key, argsToSet);
			return i;
		}
		function setArg(key, val, shouldStripQuotes = inputIsString) {
			if (/-/.test(key) && configuration["camel-case-expansion"]) addNewAlias(key, key.split(".").map(function(prop) {
				return camelCase$1(prop);
			}).join("."));
			const value = processValue(key, val, shouldStripQuotes);
			const splitKey = key.split(".");
			setKey(argv$1, splitKey, value);
			if (flags.aliases[key]) flags.aliases[key].forEach(function(x) {
				setKey(argv$1, x.split("."), value);
			});
			if (splitKey.length > 1 && configuration["dot-notation"]) (flags.aliases[splitKey[0]] || []).forEach(function(x) {
				let keyProperties = x.split(".");
				const a = [].concat(splitKey);
				a.shift();
				keyProperties = keyProperties.concat(a);
				if (!(flags.aliases[key] || []).includes(keyProperties.join("."))) setKey(argv$1, keyProperties, value);
			});
			if (checkAllAliases(key, flags.normalize) && !checkAllAliases(key, flags.arrays)) [key].concat(flags.aliases[key] || []).forEach(function(key$1) {
				Object.defineProperty(argvReturn, key$1, {
					enumerable: true,
					get() {
						return val;
					},
					set(value$1) {
						val = typeof value$1 === "string" ? mixin.normalize(value$1) : value$1;
					}
				});
			});
		}
		function addNewAlias(key, alias) {
			if (!(flags.aliases[key] && flags.aliases[key].length)) {
				flags.aliases[key] = [alias];
				newAliases[alias] = true;
			}
			if (!(flags.aliases[alias] && flags.aliases[alias].length)) addNewAlias(alias, key);
		}
		function processValue(key, val, shouldStripQuotes) {
			if (shouldStripQuotes) val = stripQuotes(val);
			if (checkAllAliases(key, flags.bools) || checkAllAliases(key, flags.counts)) {
				if (typeof val === "string") val = val === "true";
			}
			let value = Array.isArray(val) ? val.map(function(v) {
				return maybeCoerceNumber(key, v);
			}) : maybeCoerceNumber(key, val);
			if (checkAllAliases(key, flags.counts) && (isUndefined(value) || typeof value === "boolean")) value = increment();
			if (checkAllAliases(key, flags.normalize) && checkAllAliases(key, flags.arrays)) if (Array.isArray(val)) value = val.map((val$1) => {
				return mixin.normalize(val$1);
			});
			else value = mixin.normalize(val);
			return value;
		}
		function maybeCoerceNumber(key, value) {
			if (!configuration["parse-positional-numbers"] && key === "_") return value;
			if (!checkAllAliases(key, flags.strings) && !checkAllAliases(key, flags.bools) && !Array.isArray(value)) {
				if (looksLikeNumber(value) && configuration["parse-numbers"] && Number.isSafeInteger(Math.floor(parseFloat(`${value}`))) || !isUndefined(value) && checkAllAliases(key, flags.numbers)) value = Number(value);
			}
			return value;
		}
		function setConfig(argv$2) {
			const configLookup = Object.create(null);
			applyDefaultsAndAliases(configLookup, flags.aliases, defaults);
			Object.keys(flags.configs).forEach(function(configKey) {
				const configPath = argv$2[configKey] || configLookup[configKey];
				if (configPath) try {
					let config = null;
					const resolvedConfigPath = mixin.resolve(mixin.cwd(), configPath);
					const resolveConfig = flags.configs[configKey];
					if (typeof resolveConfig === "function") {
						try {
							config = resolveConfig(resolvedConfigPath);
						} catch (e) {
							config = e;
						}
						if (config instanceof Error) {
							error = config;
							return;
						}
					} else config = mixin.require(resolvedConfigPath);
					setConfigObject(config);
				} catch (ex) {
					if (ex.name === "PermissionDenied") error = ex;
					else if (argv$2[configKey]) error = Error(__("Invalid JSON config file: %s", configPath));
				}
			});
		}
		function setConfigObject(config, prev) {
			Object.keys(config).forEach(function(key) {
				const value = config[key];
				const fullKey = prev ? prev + "." + key : key;
				if (typeof value === "object" && value !== null && !Array.isArray(value) && configuration["dot-notation"]) setConfigObject(value, fullKey);
				else if (!hasKey(argv$1, fullKey.split(".")) || checkAllAliases(fullKey, flags.arrays) && configuration["combine-arrays"]) setArg(fullKey, value);
			});
		}
		function setConfigObjects() {
			if (typeof configObjects !== "undefined") configObjects.forEach(function(configObject) {
				setConfigObject(configObject);
			});
		}
		function applyEnvVars(argv$2, configOnly) {
			if (typeof envPrefix === "undefined") return;
			const prefix = typeof envPrefix === "string" ? envPrefix : "";
			const env$3 = mixin.env();
			Object.keys(env$3).forEach(function(envVar) {
				if (prefix === "" || envVar.lastIndexOf(prefix, 0) === 0) {
					const keys = envVar.split("__").map(function(key, i) {
						if (i === 0) key = key.substring(prefix.length);
						return camelCase$1(key);
					});
					if ((configOnly && flags.configs[keys.join(".")] || !configOnly) && !hasKey(argv$2, keys)) setArg(keys.join("."), env$3[envVar]);
				}
			});
		}
		function applyCoercions(argv$2) {
			let coerce;
			const applied = /* @__PURE__ */ new Set();
			Object.keys(argv$2).forEach(function(key) {
				if (!applied.has(key)) {
					coerce = checkAllAliases(key, flags.coercions);
					if (typeof coerce === "function") try {
						const value = maybeCoerceNumber(key, coerce(argv$2[key]));
						[].concat(flags.aliases[key] || [], key).forEach((ali) => {
							applied.add(ali);
							argv$2[ali] = value;
						});
					} catch (err) {
						error = err;
					}
				}
			});
		}
		function setPlaceholderKeys(argv$2) {
			flags.keys.forEach((key) => {
				if (~key.indexOf(".")) return;
				if (typeof argv$2[key] === "undefined") argv$2[key] = void 0;
			});
			return argv$2;
		}
		function applyDefaultsAndAliases(obj, aliases$1, defaults$1, canLog = false) {
			Object.keys(defaults$1).forEach(function(key) {
				if (!hasKey(obj, key.split("."))) {
					setKey(obj, key.split("."), defaults$1[key]);
					if (canLog) defaulted[key] = true;
					(aliases$1[key] || []).forEach(function(x) {
						if (hasKey(obj, x.split("."))) return;
						setKey(obj, x.split("."), defaults$1[key]);
					});
				}
			});
		}
		function hasKey(obj, keys) {
			let o = obj;
			if (!configuration["dot-notation"]) keys = [keys.join(".")];
			keys.slice(0, -1).forEach(function(key$1) {
				o = o[key$1] || {};
			});
			const key = keys[keys.length - 1];
			if (typeof o !== "object") return false;
			else return key in o;
		}
		function setKey(obj, keys, value) {
			let o = obj;
			if (!configuration["dot-notation"]) keys = [keys.join(".")];
			keys.slice(0, -1).forEach(function(key$1) {
				key$1 = sanitizeKey(key$1);
				if (typeof o === "object" && o[key$1] === void 0) o[key$1] = {};
				if (typeof o[key$1] !== "object" || Array.isArray(o[key$1])) {
					if (Array.isArray(o[key$1])) o[key$1].push({});
					else o[key$1] = [o[key$1], {}];
					o = o[key$1][o[key$1].length - 1];
				} else o = o[key$1];
			});
			const key = sanitizeKey(keys[keys.length - 1]);
			const isTypeArray = checkAllAliases(keys.join("."), flags.arrays);
			const isValueArray = Array.isArray(value);
			let duplicate = configuration["duplicate-arguments-array"];
			if (!duplicate && checkAllAliases(key, flags.nargs)) {
				duplicate = true;
				if (!isUndefined(o[key]) && flags.nargs[key] === 1 || Array.isArray(o[key]) && o[key].length === flags.nargs[key]) o[key] = void 0;
			}
			if (value === increment()) o[key] = increment(o[key]);
			else if (Array.isArray(o[key])) if (duplicate && isTypeArray && isValueArray) o[key] = configuration["flatten-duplicate-arrays"] ? o[key].concat(value) : (Array.isArray(o[key][0]) ? o[key] : [o[key]]).concat([value]);
			else if (!duplicate && Boolean(isTypeArray) === Boolean(isValueArray)) o[key] = value;
			else o[key] = o[key].concat([value]);
			else if (o[key] === void 0 && isTypeArray) o[key] = isValueArray ? value : [value];
			else if (duplicate && !(o[key] === void 0 || checkAllAliases(key, flags.counts) || checkAllAliases(key, flags.bools))) o[key] = [o[key], value];
			else o[key] = value;
		}
		function extendAliases(...args$1) {
			args$1.forEach(function(obj) {
				Object.keys(obj || {}).forEach(function(key) {
					if (flags.aliases[key]) return;
					flags.aliases[key] = [].concat(aliases[key] || []);
					flags.aliases[key].concat(key).forEach(function(x) {
						if (/-/.test(x) && configuration["camel-case-expansion"]) {
							const c = camelCase$1(x);
							if (c !== key && flags.aliases[key].indexOf(c) === -1) {
								flags.aliases[key].push(c);
								newAliases[c] = true;
							}
						}
					});
					flags.aliases[key].concat(key).forEach(function(x) {
						if (x.length > 1 && /[A-Z]/.test(x) && configuration["camel-case-expansion"]) {
							const c = decamelize$1(x, "-");
							if (c !== key && flags.aliases[key].indexOf(c) === -1) {
								flags.aliases[key].push(c);
								newAliases[c] = true;
							}
						}
					});
					flags.aliases[key].forEach(function(x) {
						flags.aliases[x] = [key].concat(flags.aliases[key].filter(function(y) {
							return x !== y;
						}));
					});
				});
			});
		}
		function checkAllAliases(key, flag) {
			const toCheck = [].concat(flags.aliases[key] || [], key);
			const keys = Object.keys(flag);
			const setAlias = toCheck.find((key$1) => keys.includes(key$1));
			return setAlias ? flag[setAlias] : false;
		}
		function hasAnyFlag(key) {
			const flagsKeys = Object.keys(flags);
			return [].concat(flagsKeys.map((k) => flags[k])).some(function(flag) {
				return Array.isArray(flag) ? flag.includes(key) : flag[key];
			});
		}
		function hasFlagsMatching(arg, ...patterns) {
			return [].concat(...patterns).some(function(pattern) {
				const match = arg.match(pattern);
				return match && hasAnyFlag(match[1]);
			});
		}
		function hasAllShortFlags(arg) {
			if (arg.match(negative) || !arg.match(/^-[^-]+/)) return false;
			let hasAllFlags = true;
			let next;
			const letters = arg.slice(1).split("");
			for (let j = 0; j < letters.length; j++) {
				next = arg.slice(j + 2);
				if (!hasAnyFlag(letters[j])) {
					hasAllFlags = false;
					break;
				}
				if (letters[j + 1] && letters[j + 1] === "=" || next === "-" || /[A-Za-z]/.test(letters[j]) && /^-?\d+(\.\d*)?(e-?\d+)?$/.test(next) || letters[j + 1] && letters[j + 1].match(/\W/)) break;
			}
			return hasAllFlags;
		}
		function isUnknownOptionAsArg(arg) {
			return configuration["unknown-options-as-args"] && isUnknownOption(arg);
		}
		function isUnknownOption(arg) {
			arg = arg.replace(/^-{3,}/, "--");
			if (arg.match(negative)) return false;
			if (hasAllShortFlags(arg)) return false;
			return !hasFlagsMatching(arg, /^-+([^=]+?)=[\s\S]*$/, negatedBoolean, /^-+([^=]+?)$/, /^-+([^=]+?)-$/, /^-+([^=]+?\d+)$/, /^-+([^=]+?)\W+.*$/);
		}
		function defaultValue(key) {
			if (!checkAllAliases(key, flags.bools) && !checkAllAliases(key, flags.counts) && `${key}` in defaults) return defaults[key];
			else return defaultForType(guessType(key));
		}
		function defaultForType(type) {
			return {
				[DefaultValuesForTypeKey.BOOLEAN]: true,
				[DefaultValuesForTypeKey.STRING]: "",
				[DefaultValuesForTypeKey.NUMBER]: void 0,
				[DefaultValuesForTypeKey.ARRAY]: []
			}[type];
		}
		function guessType(key) {
			let type = DefaultValuesForTypeKey.BOOLEAN;
			if (checkAllAliases(key, flags.strings)) type = DefaultValuesForTypeKey.STRING;
			else if (checkAllAliases(key, flags.numbers)) type = DefaultValuesForTypeKey.NUMBER;
			else if (checkAllAliases(key, flags.bools)) type = DefaultValuesForTypeKey.BOOLEAN;
			else if (checkAllAliases(key, flags.arrays)) type = DefaultValuesForTypeKey.ARRAY;
			return type;
		}
		function isUndefined(num) {
			return num === void 0;
		}
		function checkConfiguration() {
			Object.keys(flags.counts).find((key) => {
				if (checkAllAliases(key, flags.arrays)) {
					error = Error(__("Invalid configuration: %s, opts.count excludes opts.array.", key));
					return true;
				} else if (checkAllAliases(key, flags.nargs)) {
					error = Error(__("Invalid configuration: %s, opts.count excludes opts.narg.", key));
					return true;
				}
				return false;
			});
		}
		return {
			aliases: Object.assign({}, flags.aliases),
			argv: Object.assign(argvReturn, argv$1),
			configuration,
			defaulted: Object.assign({}, defaulted),
			error,
			newAliases: Object.assign({}, newAliases)
		};
	}
};
function combineAliases(aliases) {
	const aliasArrays = [];
	const combined = Object.create(null);
	let change = true;
	Object.keys(aliases).forEach(function(key) {
		aliasArrays.push([].concat(aliases[key], key));
	});
	while (change) {
		change = false;
		for (let i = 0; i < aliasArrays.length; i++) for (let ii = i + 1; ii < aliasArrays.length; ii++) if (aliasArrays[i].filter(function(v) {
			return aliasArrays[ii].indexOf(v) !== -1;
		}).length) {
			aliasArrays[i] = aliasArrays[i].concat(aliasArrays[ii]);
			aliasArrays.splice(ii, 1);
			change = true;
			break;
		}
	}
	aliasArrays.forEach(function(aliasArray) {
		aliasArray = aliasArray.filter(function(v, i, self) {
			return self.indexOf(v) === i;
		});
		const lastAlias = aliasArray.pop();
		if (lastAlias !== void 0 && typeof lastAlias === "string") combined[lastAlias] = aliasArray;
	});
	return combined;
}
function increment(orig) {
	return orig !== void 0 ? orig + 1 : 1;
}
function sanitizeKey(key) {
	if (key === "__proto__") return "___proto___";
	return key;
}
function stripQuotes(val) {
	return typeof val === "string" && (val[0] === "'" || val[0] === "\"") && val[val.length - 1] === val[0] ? val.substring(1, val.length - 1) : val;
}
var _a, _b, _c;
const minNodeVersion = process && process.env && process.env.YARGS_MIN_NODE_VERSION ? Number(process.env.YARGS_MIN_NODE_VERSION) : 20;
const nodeVersion = (_b = (_a = process === null || process === void 0 ? void 0 : process.versions) === null || _a === void 0 ? void 0 : _a.node) !== null && _b !== void 0 ? _b : (_c = process === null || process === void 0 ? void 0 : process.version) === null || _c === void 0 ? void 0 : _c.slice(1);
if (nodeVersion) {
	if (Number(nodeVersion.match(/^([^.]+)/)[1]) < minNodeVersion) throw Error(`yargs parser supports a minimum Node.js version of ${minNodeVersion}. Read our version support policy: https://github.com/yargs/yargs-parser#supported-nodejs-versions`);
}
const env$1 = process ? process.env : {};
const require$1 = createRequire ? createRequire(import.meta.url) : void 0;
const parser = new YargsParser({
	cwd: process.cwd,
	env: () => {
		return env$1;
	},
	format,
	normalize,
	resolve,
	require: (path$1) => {
		if (typeof require$1 !== "undefined") return require$1(path$1);
		else if (path$1.match(/\.json$/)) return JSON.parse(readFileSync(path$1, "utf8"));
		else throw Error("only .json config files are supported in ESM");
	}
});
const yargsParser = function Parser(args, opts) {
	return parser.parse(args.slice(), opts).argv;
};
yargsParser.detailed = function(args, opts) {
	return parser.parse(args.slice(), opts);
};
yargsParser.camelCase = camelCase$1;
yargsParser.decamelize = decamelize$1;
yargsParser.looksLikeNumber = looksLikeNumber;
const isObject$2 = (value) => typeof value === "object" && value !== null;
const isObjectCustom = (value) => isObject$2(value) && !(value instanceof RegExp) && !(value instanceof Error) && !(value instanceof Date) && !(globalThis.Blob && value instanceof globalThis.Blob);
const mapObjectSkip = Symbol("mapObjectSkip");
const _mapObject = (object, mapper, options, isSeen = /* @__PURE__ */ new WeakMap()) => {
	options = {
		deep: false,
		target: {},
		...options
	};
	if (isSeen.has(object)) return isSeen.get(object);
	isSeen.set(object, options.target);
	const { target } = options;
	delete options.target;
	const mapArray = (array) => array.map((element) => isObjectCustom(element) ? _mapObject(element, mapper, options, isSeen) : element);
	if (Array.isArray(object)) return mapArray(object);
	for (const [key, value] of Object.entries(object)) {
		const mapResult = mapper(key, value, object);
		if (mapResult === mapObjectSkip) continue;
		let [newKey, newValue, { shouldRecurse = true } = {}] = mapResult;
		if (newKey === "__proto__") continue;
		if (options.deep && shouldRecurse && isObjectCustom(newValue)) newValue = Array.isArray(newValue) ? mapArray(newValue) : _mapObject(newValue, mapper, options, isSeen);
		target[newKey] = newValue;
	}
	return target;
};
function mapObject$1(object, mapper, options) {
	if (!isObject$2(object)) throw new TypeError(`Expected an object, got \`${object}\` (${typeof object})`);
	if (Array.isArray(object)) throw new TypeError("Expected an object, got an array");
	return _mapObject(object, mapper, options);
}
const UPPERCASE = /[\p{Lu}]/u;
const LOWERCASE = /[\p{Ll}]/u;
const LEADING_CAPITAL = /^[\p{Lu}](?![\p{Lu}])/gu;
const IDENTIFIER = /([\p{Alpha}\p{N}_]|$)/u;
const SEPARATORS = /[_.\- ]+/;
const LEADING_SEPARATORS = /* @__PURE__ */ new RegExp("^" + SEPARATORS.source);
const SEPARATORS_AND_IDENTIFIER = new RegExp(SEPARATORS.source + IDENTIFIER.source, "gu");
const NUMBERS_AND_IDENTIFIER = new RegExp("\\d+" + IDENTIFIER.source, "gu");
const preserveCamelCase = (string, toLowerCase, toUpperCase, preserveConsecutiveUppercase$1) => {
	let isLastCharLower = false;
	let isLastCharUpper = false;
	let isLastLastCharUpper = false;
	let isLastLastCharPreserved = false;
	for (let index = 0; index < string.length; index++) {
		const character = string[index];
		isLastLastCharPreserved = index > 2 ? string[index - 3] === "-" : true;
		if (isLastCharLower && UPPERCASE.test(character)) {
			string = string.slice(0, index) + "-" + string.slice(index);
			isLastCharLower = false;
			isLastLastCharUpper = isLastCharUpper;
			isLastCharUpper = true;
			index++;
		} else if (isLastCharUpper && isLastLastCharUpper && LOWERCASE.test(character) && (!isLastLastCharPreserved || preserveConsecutiveUppercase$1)) {
			string = string.slice(0, index - 1) + "-" + string.slice(index - 1);
			isLastLastCharUpper = isLastCharUpper;
			isLastCharUpper = false;
			isLastCharLower = true;
		} else {
			isLastCharLower = toLowerCase(character) === character && toUpperCase(character) !== character;
			isLastLastCharUpper = isLastCharUpper;
			isLastCharUpper = toUpperCase(character) === character && toLowerCase(character) !== character;
		}
	}
	return string;
};
const preserveConsecutiveUppercase = (input, toLowerCase) => {
	LEADING_CAPITAL.lastIndex = 0;
	return input.replaceAll(LEADING_CAPITAL, (match) => toLowerCase(match));
};
const postProcess = (input, toUpperCase) => {
	SEPARATORS_AND_IDENTIFIER.lastIndex = 0;
	NUMBERS_AND_IDENTIFIER.lastIndex = 0;
	return input.replaceAll(NUMBERS_AND_IDENTIFIER, (match, pattern, offset) => ["_", "-"].includes(input.charAt(offset + match.length)) ? match : toUpperCase(match)).replaceAll(SEPARATORS_AND_IDENTIFIER, (_, identifier$1) => toUpperCase(identifier$1));
};
function camelCase(input, options) {
	if (!(typeof input === "string" || Array.isArray(input))) throw new TypeError("Expected the input to be `string | string[]`");
	options = {
		pascalCase: false,
		preserveConsecutiveUppercase: false,
		...options
	};
	if (Array.isArray(input)) input = input.map((x) => x.trim()).filter((x) => x.length).join("-");
	else input = input.trim();
	if (input.length === 0) return "";
	const toLowerCase = options.locale === false ? (string) => string.toLowerCase() : (string) => string.toLocaleLowerCase(options.locale);
	const toUpperCase = options.locale === false ? (string) => string.toUpperCase() : (string) => string.toLocaleUpperCase(options.locale);
	if (input.length === 1) {
		if (SEPARATORS.test(input)) return "";
		return options.pascalCase ? toUpperCase(input) : toLowerCase(input);
	}
	if (input !== toLowerCase(input)) input = preserveCamelCase(input, toLowerCase, toUpperCase, options.preserveConsecutiveUppercase);
	input = input.replace(LEADING_SEPARATORS, "");
	input = options.preserveConsecutiveUppercase ? preserveConsecutiveUppercase(input, toLowerCase) : toLowerCase(input);
	if (options.pascalCase) input = toUpperCase(input.charAt(0)) + input.slice(1);
	return postProcess(input, toUpperCase);
}
let QuickLRU$1 = class QuickLRU$2 extends Map {
	#size = 0;
	#cache = /* @__PURE__ */ new Map();
	#oldCache = /* @__PURE__ */ new Map();
	#maxSize;
	#maxAge;
	#onEviction;
	constructor(options = {}) {
		super();
		if (!(options.maxSize && options.maxSize > 0)) throw new TypeError("`maxSize` must be a number greater than 0");
		if (typeof options.maxAge === "number" && options.maxAge === 0) throw new TypeError("`maxAge` must be a number greater than 0");
		this.#maxSize = options.maxSize;
		this.#maxAge = options.maxAge || Number.POSITIVE_INFINITY;
		this.#onEviction = options.onEviction;
	}
	get __oldCache() {
		return this.#oldCache;
	}
	#emitEvictions(cache$4) {
		if (typeof this.#onEviction !== "function") return;
		for (const [key, item] of cache$4) this.#onEviction(key, item.value);
	}
	#deleteIfExpired(key, item) {
		if (typeof item.expiry === "number" && item.expiry <= Date.now()) {
			if (typeof this.#onEviction === "function") this.#onEviction(key, item.value);
			return this.delete(key);
		}
		return false;
	}
	#getOrDeleteIfExpired(key, item) {
		if (this.#deleteIfExpired(key, item) === false) return item.value;
	}
	#getItemValue(key, item) {
		return item.expiry ? this.#getOrDeleteIfExpired(key, item) : item.value;
	}
	#peek(key, cache$4) {
		const item = cache$4.get(key);
		return this.#getItemValue(key, item);
	}
	#set(key, value) {
		this.#cache.set(key, value);
		this.#size++;
		if (this.#size >= this.#maxSize) {
			this.#size = 0;
			this.#emitEvictions(this.#oldCache);
			this.#oldCache = this.#cache;
			this.#cache = /* @__PURE__ */ new Map();
		}
	}
	#moveToRecent(key, item) {
		this.#oldCache.delete(key);
		this.#set(key, item);
	}
	*#entriesAscending() {
		for (const item of this.#oldCache) {
			const [key, value] = item;
			if (!this.#cache.has(key)) {
				if (this.#deleteIfExpired(key, value) === false) yield item;
			}
		}
		for (const item of this.#cache) {
			const [key, value] = item;
			if (this.#deleteIfExpired(key, value) === false) yield item;
		}
	}
	get(key) {
		if (this.#cache.has(key)) {
			const item = this.#cache.get(key);
			return this.#getItemValue(key, item);
		}
		if (this.#oldCache.has(key)) {
			const item = this.#oldCache.get(key);
			if (this.#deleteIfExpired(key, item) === false) {
				this.#moveToRecent(key, item);
				return item.value;
			}
		}
	}
	set(key, value, { maxAge = this.#maxAge } = {}) {
		const expiry = typeof maxAge === "number" && maxAge !== Number.POSITIVE_INFINITY ? Date.now() + maxAge : void 0;
		if (this.#cache.has(key)) this.#cache.set(key, {
			value,
			expiry
		});
		else this.#set(key, {
			value,
			expiry
		});
		return this;
	}
	has(key) {
		if (this.#cache.has(key)) return !this.#deleteIfExpired(key, this.#cache.get(key));
		if (this.#oldCache.has(key)) return !this.#deleteIfExpired(key, this.#oldCache.get(key));
		return false;
	}
	peek(key) {
		if (this.#cache.has(key)) return this.#peek(key, this.#cache);
		if (this.#oldCache.has(key)) return this.#peek(key, this.#oldCache);
	}
	expiresIn(key) {
		const item = this.#cache.get(key) ?? this.#oldCache.get(key);
		if (item) return item.expiry ? item.expiry - Date.now() : Number.POSITIVE_INFINITY;
	}
	delete(key) {
		const deleted = this.#cache.delete(key);
		if (deleted) this.#size--;
		return this.#oldCache.delete(key) || deleted;
	}
	clear() {
		this.#cache.clear();
		this.#oldCache.clear();
		this.#size = 0;
	}
	resize(newSize) {
		if (!(newSize && newSize > 0)) throw new TypeError("`maxSize` must be a number greater than 0");
		const items = [...this.#entriesAscending()];
		const removeCount = items.length - newSize;
		if (removeCount < 0) {
			this.#cache = new Map(items);
			this.#oldCache = /* @__PURE__ */ new Map();
			this.#size = items.length;
		} else {
			if (removeCount > 0) this.#emitEvictions(items.slice(0, removeCount));
			this.#oldCache = new Map(items.slice(removeCount));
			this.#cache = /* @__PURE__ */ new Map();
			this.#size = 0;
		}
		this.#maxSize = newSize;
	}
	*keys() {
		for (const [key] of this) yield key;
	}
	*values() {
		for (const [, value] of this) yield value;
	}
	*[Symbol.iterator]() {
		for (const item of this.#cache) {
			const [key, value] = item;
			if (this.#deleteIfExpired(key, value) === false) yield [key, value.value];
		}
		for (const item of this.#oldCache) {
			const [key, value] = item;
			if (!this.#cache.has(key)) {
				if (this.#deleteIfExpired(key, value) === false) yield [key, value.value];
			}
		}
	}
	*entriesDescending() {
		let items = [...this.#cache];
		for (let i = items.length - 1; i >= 0; --i) {
			const [key, value] = items[i];
			if (this.#deleteIfExpired(key, value) === false) yield [key, value.value];
		}
		items = [...this.#oldCache];
		for (let i = items.length - 1; i >= 0; --i) {
			const [key, value] = items[i];
			if (!this.#cache.has(key)) {
				if (this.#deleteIfExpired(key, value) === false) yield [key, value.value];
			}
		}
	}
	*entriesAscending() {
		for (const [key, value] of this.#entriesAscending()) yield [key, value.value];
	}
	get size() {
		if (!this.#size) return this.#oldCache.size;
		let oldCacheSize = 0;
		for (const key of this.#oldCache.keys()) if (!this.#cache.has(key)) oldCacheSize++;
		return Math.min(this.#size + oldCacheSize, this.#maxSize);
	}
	get maxSize() {
		return this.#maxSize;
	}
	entries() {
		return this.entriesAscending();
	}
	forEach(callbackFunction, thisArgument = this) {
		for (const [key, value] of this.entriesAscending()) callbackFunction.call(thisArgument, value, key, this);
	}
	get [Symbol.toStringTag]() {
		return "QuickLRU";
	}
	toString() {
		return `QuickLRU(${this.size}/${this.maxSize})`;
	}
	[Symbol.for("nodejs.util.inspect.custom")]() {
		return this.toString();
	}
};
const has$1 = (array, key) => array.some((element) => {
	if (typeof element === "string") return element === key;
	element.lastIndex = 0;
	return element.test(key);
});
const cache$1 = new QuickLRU$1({ maxSize: 1e5 });
const isObject$1 = (value) => typeof value === "object" && value !== null && !(value instanceof RegExp) && !(value instanceof Error) && !(value instanceof Date);
const transform$1 = (input, options = {}, isSeen = /* @__PURE__ */ new WeakMap(), parentPath) => {
	if (!isObject$1(input)) return input;
	if (isSeen.has(input)) return isSeen.get(input);
	const { exclude, pascalCase = false, stopPaths, deep = false, preserveConsecutiveUppercase: preserveConsecutiveUppercase$1 = false } = options;
	const stopPathsSet = new Set(stopPaths);
	if (Array.isArray(input)) {
		const result$1 = [];
		isSeen.set(input, result$1);
		for (const item of input) result$1.push(isObject$1(item) ? transform$1(item, options, isSeen, parentPath) : item);
		return result$1;
	}
	const result = {};
	isSeen.set(input, result);
	const makeMapper = (currentParentPath) => (key, value) => {
		if (deep && isObject$1(value)) {
			const path$1 = currentParentPath === void 0 ? key : `${currentParentPath}.${key}`;
			if (!stopPathsSet.has(path$1)) value = Array.isArray(value) ? value.map((item) => isObject$1(item) ? transform$1(item, options, isSeen, path$1) : item) : transform$1(value, options, isSeen, path$1);
		}
		if (typeof key === "string" && !(exclude && has$1(exclude, key))) {
			const cacheKey = pascalCase ? `${key}_` : key;
			if (cache$1.has(cacheKey)) key = cache$1.get(cacheKey);
			else {
				const returnValue = camelCase(key, {
					pascalCase,
					locale: false,
					preserveConsecutiveUppercase: preserveConsecutiveUppercase$1
				});
				if (key.length < 100) cache$1.set(cacheKey, returnValue);
				key = returnValue;
			}
		}
		return [key, value];
	};
	const mappedResult = mapObject$1(input, makeMapper(parentPath), { deep: false });
	Object.assign(result, mappedResult);
	const symbols = Object.getOwnPropertySymbols(input);
	for (const symbol of symbols) result[symbol] = deep && isObject$1(input[symbol]) ? transform$1(input[symbol], options, isSeen, parentPath) : input[symbol];
	return result;
};
function camelcaseKeys(input, options) {
	const isSeen = /* @__PURE__ */ new WeakMap();
	if (Array.isArray(input)) return input.map((item, index) => isObject$1(item) ? transform$1(item, options, isSeen, String(index)) : item);
	return transform$1(input, options, isSeen);
}
function trimNewlines(string) {
	let start = 0;
	let end = string.length;
	while (start < end && (string[start] === "\r" || string[start] === "\n")) start++;
	while (end > start && (string[end - 1] === "\r" || string[end - 1] === "\n")) end--;
	return start > 0 || end < string.length ? string.slice(start, end) : string;
}
function stripIndent(string) {
	const match = string.match(/^[ \t]*(?=\S)/gm);
	if (!match) return string;
	let minIndent = Number.POSITIVE_INFINITY;
	for (const indent of match) minIndent = Math.min(minIndent, indent.length);
	if (minIndent === 0 || minIndent === Number.POSITIVE_INFINITY) return string;
	return string.replace(new RegExp(`^[ \\t]{${minIndent}}`, "gm"), "");
}
function indentString(string, count = 1, options = {}) {
	const { indent = " ", includeEmptyLines = false } = options;
	if (typeof string !== "string") throw new TypeError(`Expected \`input\` to be a \`string\`, got \`${typeof string}\``);
	if (typeof count !== "number") throw new TypeError(`Expected \`count\` to be a \`number\`, got \`${typeof count}\``);
	if (count < 0) throw new RangeError(`Expected \`count\` to be at least 0, got \`${count}\``);
	if (typeof indent !== "string") throw new TypeError(`Expected \`options.indent\` to be a \`string\`, got \`${typeof indent}\``);
	if (count === 0) return string;
	const regex$1 = includeEmptyLines ? /^/gm : /^(?!\s*$)/gm;
	return string.replace(regex$1, indent.repeat(count));
}
function redent(string, count = 0, options = {}) {
	return indentString(stripIndent(string), count, options);
}
const toPath$1 = (urlOrPath) => urlOrPath instanceof URL ? fileURLToPath(urlOrPath) : urlOrPath;
function findUpSync(name, { cwd: cwd$2 = process$1.cwd(), type = "file", stopAt } = {}) {
	let directory = path.resolve(toPath$1(cwd$2) ?? "");
	const { root } = path.parse(directory);
	stopAt = path.resolve(directory, toPath$1(stopAt) ?? root);
	const isAbsoluteName = path.isAbsolute(name);
	while (directory) {
		const filePath = isAbsoluteName ? name : path.join(directory, name);
		try {
			const stats = fs.statSync(filePath, { throwIfNoEntry: false });
			if (type === "file" && stats?.isFile() || type === "directory" && stats?.isDirectory()) return filePath;
		} catch {}
		if (directory === stopAt || directory === root) break;
		directory = path.dirname(directory);
	}
}
function getDefaultExportFromCjs(x) {
	return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, "default") ? x["default"] : x;
}
var lib$3 = {};
var picocolors = { exports: {} };
var hasRequiredPicocolors;
function requirePicocolors() {
	if (hasRequiredPicocolors) return picocolors.exports;
	hasRequiredPicocolors = 1;
	let p = process || {}, argv$1 = p.argv || [], env$3 = p.env || {};
	let isColorSupported = !(!!env$3.NO_COLOR || argv$1.includes("--no-color")) && (!!env$3.FORCE_COLOR || argv$1.includes("--color") || p.platform === "win32" || (p.stdout || {}).isTTY && env$3.TERM !== "dumb" || !!env$3.CI);
	let formatter = (open, close, replace = open) => (input) => {
		let string = "" + input, index = string.indexOf(close, open.length);
		return ~index ? open + replaceClose(string, close, replace, index) + close : open + string + close;
	};
	let replaceClose = (string, close, replace, index) => {
		let result = "", cursor = 0;
		do {
			result += string.substring(cursor, index) + replace;
			cursor = index + close.length;
			index = string.indexOf(close, cursor);
		} while (~index);
		return result + string.substring(cursor);
	};
	let createColors = (enabled = isColorSupported) => {
		let f = enabled ? formatter : () => String;
		return {
			isColorSupported: enabled,
			reset: f("\x1B[0m", "\x1B[0m"),
			bold: f("\x1B[1m", "\x1B[22m", "\x1B[22m\x1B[1m"),
			dim: f("\x1B[2m", "\x1B[22m", "\x1B[22m\x1B[2m"),
			italic: f("\x1B[3m", "\x1B[23m"),
			underline: f("\x1B[4m", "\x1B[24m"),
			inverse: f("\x1B[7m", "\x1B[27m"),
			hidden: f("\x1B[8m", "\x1B[28m"),
			strikethrough: f("\x1B[9m", "\x1B[29m"),
			black: f("\x1B[30m", "\x1B[39m"),
			red: f("\x1B[31m", "\x1B[39m"),
			green: f("\x1B[32m", "\x1B[39m"),
			yellow: f("\x1B[33m", "\x1B[39m"),
			blue: f("\x1B[34m", "\x1B[39m"),
			magenta: f("\x1B[35m", "\x1B[39m"),
			cyan: f("\x1B[36m", "\x1B[39m"),
			white: f("\x1B[37m", "\x1B[39m"),
			gray: f("\x1B[90m", "\x1B[39m"),
			bgBlack: f("\x1B[40m", "\x1B[49m"),
			bgRed: f("\x1B[41m", "\x1B[49m"),
			bgGreen: f("\x1B[42m", "\x1B[49m"),
			bgYellow: f("\x1B[43m", "\x1B[49m"),
			bgBlue: f("\x1B[44m", "\x1B[49m"),
			bgMagenta: f("\x1B[45m", "\x1B[49m"),
			bgCyan: f("\x1B[46m", "\x1B[49m"),
			bgWhite: f("\x1B[47m", "\x1B[49m"),
			blackBright: f("\x1B[90m", "\x1B[39m"),
			redBright: f("\x1B[91m", "\x1B[39m"),
			greenBright: f("\x1B[92m", "\x1B[39m"),
			yellowBright: f("\x1B[93m", "\x1B[39m"),
			blueBright: f("\x1B[94m", "\x1B[39m"),
			magentaBright: f("\x1B[95m", "\x1B[39m"),
			cyanBright: f("\x1B[96m", "\x1B[39m"),
			whiteBright: f("\x1B[97m", "\x1B[39m"),
			bgBlackBright: f("\x1B[100m", "\x1B[49m"),
			bgRedBright: f("\x1B[101m", "\x1B[49m"),
			bgGreenBright: f("\x1B[102m", "\x1B[49m"),
			bgYellowBright: f("\x1B[103m", "\x1B[49m"),
			bgBlueBright: f("\x1B[104m", "\x1B[49m"),
			bgMagentaBright: f("\x1B[105m", "\x1B[49m"),
			bgCyanBright: f("\x1B[106m", "\x1B[49m"),
			bgWhiteBright: f("\x1B[107m", "\x1B[49m")
		};
	};
	picocolors.exports = createColors();
	picocolors.exports.createColors = createColors;
	return picocolors.exports;
}
var jsTokens = {};
var hasRequiredJsTokens;
function requireJsTokens() {
	if (hasRequiredJsTokens) return jsTokens;
	hasRequiredJsTokens = 1;
	Object.defineProperty(jsTokens, "__esModule", { value: true });
	jsTokens.default = /((['"])(?:(?!\2|\\).|\\(?:\r\n|[\s\S]))*(\2)?|`(?:[^`\\$]|\\[\s\S]|\$(?!\{)|\$\{(?:[^{}]|\{[^}]*\}?)*\}?)*(`)?)|(\/\/.*)|(\/\*(?:[^*]|\*(?!\/))*(\*\/)?)|(\/(?!\*)(?:\[(?:(?![\]\\]).|\\.)*\]|(?![\/\]\\]).|\\.)+\/(?:(?!\s*(?:\b|[\u0080-\uFFFF$\\'"~({]|[+\-!](?!=)|\.?\d))|[gmiyus]{1,6}\b(?![\u0080-\uFFFF$\\]|\s*(?:[+\-*%&|^<>!=?({]|\/(?![\/*])))))|(0[xX][\da-fA-F]+|0[oO][0-7]+|0[bB][01]+|(?:\d*\.\d+|\d+\.?)(?:[eE][+-]?\d+)?)|((?!\d)(?:(?!\s)[$\w\u0080-\uFFFF]|\\u[\da-fA-F]{4}|\\u\{[\da-fA-F]+\})+)|(--|\+\+|&&|\|\||=>|\.{3}|(?:[+\-\/%&|^]|\*{1,2}|<{1,2}|>{1,3}|!=?|={1,2})=?|[?~.,:;[\](){}])|(\s+)|(^$|[\s\S])/g;
	jsTokens.matchToToken = function(match) {
		var token = {
			type: "invalid",
			value: match[0],
			closed: void 0
		};
		if (match[1]) token.type = "string", token.closed = !!(match[3] || match[4]);
		else if (match[5]) token.type = "comment";
		else if (match[6]) token.type = "comment", token.closed = !!match[7];
		else if (match[8]) token.type = "regex";
		else if (match[9]) token.type = "number";
		else if (match[10]) token.type = "name";
		else if (match[11]) token.type = "punctuator";
		else if (match[12]) token.type = "whitespace";
		return token;
	};
	return jsTokens;
}
var lib$2 = {};
var identifier = {};
var hasRequiredIdentifier;
function requireIdentifier() {
	if (hasRequiredIdentifier) return identifier;
	hasRequiredIdentifier = 1;
	Object.defineProperty(identifier, "__esModule", { value: true });
	identifier.isIdentifierChar = isIdentifierChar;
	identifier.isIdentifierName = isIdentifierName;
	identifier.isIdentifierStart = isIdentifierStart;
	let nonASCIIidentifierStartChars = "------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------";
	let nonASCIIidentifierChars = "-----------------------------------------------------------------------------------------------------------------------------------------------------";
	const nonASCIIidentifierStart = /* @__PURE__ */ new RegExp("[" + nonASCIIidentifierStartChars + "]");
	const nonASCIIidentifier = /* @__PURE__ */ new RegExp("[" + nonASCIIidentifierStartChars + nonASCIIidentifierChars + "]");
	nonASCIIidentifierStartChars = nonASCIIidentifierChars = null;
	const astralIdentifierStartCodes = [
		0,
		11,
		2,
		25,
		2,
		18,
		2,
		1,
		2,
		14,
		3,
		13,
		35,
		122,
		70,
		52,
		268,
		28,
		4,
		48,
		48,
		31,
		14,
		29,
		6,
		37,
		11,
		29,
		3,
		35,
		5,
		7,
		2,
		4,
		43,
		157,
		19,
		35,
		5,
		35,
		5,
		39,
		9,
		51,
		13,
		10,
		2,
		14,
		2,
		6,
		2,
		1,
		2,
		10,
		2,
		14,
		2,
		6,
		2,
		1,
		4,
		51,
		13,
		310,
		10,
		21,
		11,
		7,
		25,
		5,
		2,
		41,
		2,
		8,
		70,
		5,
		3,
		0,
		2,
		43,
		2,
		1,
		4,
		0,
		3,
		22,
		11,
		22,
		10,
		30,
		66,
		18,
		2,
		1,
		11,
		21,
		11,
		25,
		71,
		55,
		7,
		1,
		65,
		0,
		16,
		3,
		2,
		2,
		2,
		28,
		43,
		28,
		4,
		28,
		36,
		7,
		2,
		27,
		28,
		53,
		11,
		21,
		11,
		18,
		14,
		17,
		111,
		72,
		56,
		50,
		14,
		50,
		14,
		35,
		39,
		27,
		10,
		22,
		251,
		41,
		7,
		1,
		17,
		2,
		60,
		28,
		11,
		0,
		9,
		21,
		43,
		17,
		47,
		20,
		28,
		22,
		13,
		52,
		58,
		1,
		3,
		0,
		14,
		44,
		33,
		24,
		27,
		35,
		30,
		0,
		3,
		0,
		9,
		34,
		4,
		0,
		13,
		47,
		15,
		3,
		22,
		0,
		2,
		0,
		36,
		17,
		2,
		24,
		20,
		1,
		64,
		6,
		2,
		0,
		2,
		3,
		2,
		14,
		2,
		9,
		8,
		46,
		39,
		7,
		3,
		1,
		3,
		21,
		2,
		6,
		2,
		1,
		2,
		4,
		4,
		0,
		19,
		0,
		13,
		4,
		31,
		9,
		2,
		0,
		3,
		0,
		2,
		37,
		2,
		0,
		26,
		0,
		2,
		0,
		45,
		52,
		19,
		3,
		21,
		2,
		31,
		47,
		21,
		1,
		2,
		0,
		185,
		46,
		42,
		3,
		37,
		47,
		21,
		0,
		60,
		42,
		14,
		0,
		72,
		26,
		38,
		6,
		186,
		43,
		117,
		63,
		32,
		7,
		3,
		0,
		3,
		7,
		2,
		1,
		2,
		23,
		16,
		0,
		2,
		0,
		95,
		7,
		3,
		38,
		17,
		0,
		2,
		0,
		29,
		0,
		11,
		39,
		8,
		0,
		22,
		0,
		12,
		45,
		20,
		0,
		19,
		72,
		200,
		32,
		32,
		8,
		2,
		36,
		18,
		0,
		50,
		29,
		113,
		6,
		2,
		1,
		2,
		37,
		22,
		0,
		26,
		5,
		2,
		1,
		2,
		31,
		15,
		0,
		328,
		18,
		16,
		0,
		2,
		12,
		2,
		33,
		125,
		0,
		80,
		921,
		103,
		110,
		18,
		195,
		2637,
		96,
		16,
		1071,
		18,
		5,
		26,
		3994,
		6,
		582,
		6842,
		29,
		1763,
		568,
		8,
		30,
		18,
		78,
		18,
		29,
		19,
		47,
		17,
		3,
		32,
		20,
		6,
		18,
		433,
		44,
		212,
		63,
		129,
		74,
		6,
		0,
		67,
		12,
		65,
		1,
		2,
		0,
		29,
		6135,
		9,
		1237,
		42,
		9,
		8936,
		3,
		2,
		6,
		2,
		1,
		2,
		290,
		16,
		0,
		30,
		2,
		3,
		0,
		15,
		3,
		9,
		395,
		2309,
		106,
		6,
		12,
		4,
		8,
		8,
		9,
		5991,
		84,
		2,
		70,
		2,
		1,
		3,
		0,
		3,
		1,
		3,
		3,
		2,
		11,
		2,
		0,
		2,
		6,
		2,
		64,
		2,
		3,
		3,
		7,
		2,
		6,
		2,
		27,
		2,
		3,
		2,
		4,
		2,
		0,
		4,
		6,
		2,
		339,
		3,
		24,
		2,
		24,
		2,
		30,
		2,
		24,
		2,
		30,
		2,
		24,
		2,
		30,
		2,
		24,
		2,
		30,
		2,
		24,
		2,
		7,
		1845,
		30,
		7,
		5,
		262,
		61,
		147,
		44,
		11,
		6,
		17,
		0,
		322,
		29,
		19,
		43,
		485,
		27,
		229,
		29,
		3,
		0,
		496,
		6,
		2,
		3,
		2,
		1,
		2,
		14,
		2,
		196,
		60,
		67,
		8,
		0,
		1205,
		3,
		2,
		26,
		2,
		1,
		2,
		0,
		3,
		0,
		2,
		9,
		2,
		3,
		2,
		0,
		2,
		0,
		7,
		0,
		5,
		0,
		2,
		0,
		2,
		0,
		2,
		2,
		2,
		1,
		2,
		0,
		3,
		0,
		2,
		0,
		2,
		0,
		2,
		0,
		2,
		0,
		2,
		1,
		2,
		0,
		3,
		3,
		2,
		6,
		2,
		3,
		2,
		3,
		2,
		0,
		2,
		9,
		2,
		16,
		6,
		2,
		2,
		4,
		2,
		16,
		4421,
		42719,
		33,
		4153,
		7,
		221,
		3,
		5761,
		15,
		7472,
		16,
		621,
		2467,
		541,
		1507,
		4938,
		6,
		4191
	];
	const astralIdentifierCodes = [
		509,
		0,
		227,
		0,
		150,
		4,
		294,
		9,
		1368,
		2,
		2,
		1,
		6,
		3,
		41,
		2,
		5,
		0,
		166,
		1,
		574,
		3,
		9,
		9,
		7,
		9,
		32,
		4,
		318,
		1,
		80,
		3,
		71,
		10,
		50,
		3,
		123,
		2,
		54,
		14,
		32,
		10,
		3,
		1,
		11,
		3,
		46,
		10,
		8,
		0,
		46,
		9,
		7,
		2,
		37,
		13,
		2,
		9,
		6,
		1,
		45,
		0,
		13,
		2,
		49,
		13,
		9,
		3,
		2,
		11,
		83,
		11,
		7,
		0,
		3,
		0,
		158,
		11,
		6,
		9,
		7,
		3,
		56,
		1,
		2,
		6,
		3,
		1,
		3,
		2,
		10,
		0,
		11,
		1,
		3,
		6,
		4,
		4,
		68,
		8,
		2,
		0,
		3,
		0,
		2,
		3,
		2,
		4,
		2,
		0,
		15,
		1,
		83,
		17,
		10,
		9,
		5,
		0,
		82,
		19,
		13,
		9,
		214,
		6,
		3,
		8,
		28,
		1,
		83,
		16,
		16,
		9,
		82,
		12,
		9,
		9,
		7,
		19,
		58,
		14,
		5,
		9,
		243,
		14,
		166,
		9,
		71,
		5,
		2,
		1,
		3,
		3,
		2,
		0,
		2,
		1,
		13,
		9,
		120,
		6,
		3,
		6,
		4,
		0,
		29,
		9,
		41,
		6,
		2,
		3,
		9,
		0,
		10,
		10,
		47,
		15,
		343,
		9,
		54,
		7,
		2,
		7,
		17,
		9,
		57,
		21,
		2,
		13,
		123,
		5,
		4,
		0,
		2,
		1,
		2,
		6,
		2,
		0,
		9,
		9,
		49,
		4,
		2,
		1,
		2,
		4,
		9,
		9,
		330,
		3,
		10,
		1,
		2,
		0,
		49,
		6,
		4,
		4,
		14,
		10,
		5350,
		0,
		7,
		14,
		11465,
		27,
		2343,
		9,
		87,
		9,
		39,
		4,
		60,
		6,
		26,
		9,
		535,
		9,
		470,
		0,
		2,
		54,
		8,
		3,
		82,
		0,
		12,
		1,
		19628,
		1,
		4178,
		9,
		519,
		45,
		3,
		22,
		543,
		4,
		4,
		5,
		9,
		7,
		3,
		6,
		31,
		3,
		149,
		2,
		1418,
		49,
		513,
		54,
		5,
		49,
		9,
		0,
		15,
		0,
		23,
		4,
		2,
		14,
		1361,
		6,
		2,
		16,
		3,
		6,
		2,
		1,
		2,
		4,
		101,
		0,
		161,
		6,
		10,
		9,
		357,
		0,
		62,
		13,
		499,
		13,
		245,
		1,
		2,
		9,
		726,
		6,
		110,
		6,
		6,
		9,
		4759,
		9,
		787719,
		239
	];
	function isInAstralSet(code, set) {
		let pos = 65536;
		for (let i = 0, length = set.length; i < length; i += 2) {
			pos += set[i];
			if (pos > code) return false;
			pos += set[i + 1];
			if (pos >= code) return true;
		}
		return false;
	}
	function isIdentifierStart(code) {
		if (code < 65) return code === 36;
		if (code <= 90) return true;
		if (code < 97) return code === 95;
		if (code <= 122) return true;
		if (code <= 65535) return code >= 170 && nonASCIIidentifierStart.test(String.fromCharCode(code));
		return isInAstralSet(code, astralIdentifierStartCodes);
	}
	function isIdentifierChar(code) {
		if (code < 48) return code === 36;
		if (code < 58) return true;
		if (code < 65) return false;
		if (code <= 90) return true;
		if (code < 97) return code === 95;
		if (code <= 122) return true;
		if (code <= 65535) return code >= 170 && nonASCIIidentifier.test(String.fromCharCode(code));
		return isInAstralSet(code, astralIdentifierStartCodes) || isInAstralSet(code, astralIdentifierCodes);
	}
	function isIdentifierName(name) {
		let isFirst = true;
		for (let i = 0; i < name.length; i++) {
			let cp = name.charCodeAt(i);
			if ((cp & 64512) === 55296 && i + 1 < name.length) {
				const trail = name.charCodeAt(++i);
				if ((trail & 64512) === 56320) cp = 65536 + ((cp & 1023) << 10) + (trail & 1023);
			}
			if (isFirst) {
				isFirst = false;
				if (!isIdentifierStart(cp)) return false;
			} else if (!isIdentifierChar(cp)) return false;
		}
		return !isFirst;
	}
	return identifier;
}
var keyword = {};
var hasRequiredKeyword;
function requireKeyword() {
	if (hasRequiredKeyword) return keyword;
	hasRequiredKeyword = 1;
	Object.defineProperty(keyword, "__esModule", { value: true });
	keyword.isKeyword = isKeyword;
	keyword.isReservedWord = isReservedWord;
	keyword.isStrictBindOnlyReservedWord = isStrictBindOnlyReservedWord;
	keyword.isStrictBindReservedWord = isStrictBindReservedWord;
	keyword.isStrictReservedWord = isStrictReservedWord;
	const reservedWords = {
		keyword: [
			"break",
			"case",
			"catch",
			"continue",
			"debugger",
			"default",
			"do",
			"else",
			"finally",
			"for",
			"function",
			"if",
			"return",
			"switch",
			"throw",
			"try",
			"var",
			"const",
			"while",
			"with",
			"new",
			"this",
			"super",
			"class",
			"extends",
			"export",
			"import",
			"null",
			"true",
			"false",
			"in",
			"instanceof",
			"typeof",
			"void",
			"delete"
		],
		strict: [
			"implements",
			"interface",
			"let",
			"package",
			"private",
			"protected",
			"public",
			"static",
			"yield"
		],
		strictBind: ["eval", "arguments"]
	};
	const keywords = new Set(reservedWords.keyword);
	const reservedWordsStrictSet = new Set(reservedWords.strict);
	const reservedWordsStrictBindSet = new Set(reservedWords.strictBind);
	function isReservedWord(word, inModule) {
		return inModule && word === "await" || word === "enum";
	}
	function isStrictReservedWord(word, inModule) {
		return isReservedWord(word, inModule) || reservedWordsStrictSet.has(word);
	}
	function isStrictBindOnlyReservedWord(word) {
		return reservedWordsStrictBindSet.has(word);
	}
	function isStrictBindReservedWord(word, inModule) {
		return isStrictReservedWord(word, inModule) || isStrictBindOnlyReservedWord(word);
	}
	function isKeyword(word) {
		return keywords.has(word);
	}
	return keyword;
}
var hasRequiredLib$3;
function requireLib$3() {
	if (hasRequiredLib$3) return lib$2;
	hasRequiredLib$3 = 1;
	(function(exports$1) {
		Object.defineProperty(exports$1, "__esModule", { value: true });
		Object.defineProperty(exports$1, "isIdentifierChar", {
			enumerable: true,
			get: function() {
				return _identifier.isIdentifierChar;
			}
		});
		Object.defineProperty(exports$1, "isIdentifierName", {
			enumerable: true,
			get: function() {
				return _identifier.isIdentifierName;
			}
		});
		Object.defineProperty(exports$1, "isIdentifierStart", {
			enumerable: true,
			get: function() {
				return _identifier.isIdentifierStart;
			}
		});
		Object.defineProperty(exports$1, "isKeyword", {
			enumerable: true,
			get: function() {
				return _keyword.isKeyword;
			}
		});
		Object.defineProperty(exports$1, "isReservedWord", {
			enumerable: true,
			get: function() {
				return _keyword.isReservedWord;
			}
		});
		Object.defineProperty(exports$1, "isStrictBindOnlyReservedWord", {
			enumerable: true,
			get: function() {
				return _keyword.isStrictBindOnlyReservedWord;
			}
		});
		Object.defineProperty(exports$1, "isStrictBindReservedWord", {
			enumerable: true,
			get: function() {
				return _keyword.isStrictBindReservedWord;
			}
		});
		Object.defineProperty(exports$1, "isStrictReservedWord", {
			enumerable: true,
			get: function() {
				return _keyword.isStrictReservedWord;
			}
		});
		var _identifier = requireIdentifier();
		var _keyword = requireKeyword();
	})(lib$2);
	return lib$2;
}
var hasRequiredLib$2;
function requireLib$2() {
	if (hasRequiredLib$2) return lib$3;
	hasRequiredLib$2 = 1;
	Object.defineProperty(lib$3, "__esModule", { value: true });
	var picocolors$1 = requirePicocolors();
	var jsTokens$1 = requireJsTokens();
	var helperValidatorIdentifier = requireLib$3();
	function isColorSupported() {
		return typeof process === "object" && (process.env.FORCE_COLOR === "0" || process.env.FORCE_COLOR === "false") ? false : picocolors$1.isColorSupported;
	}
	const compose = (f, g) => (v) => f(g(v));
	function buildDefs(colors) {
		return {
			keyword: colors.cyan,
			capitalized: colors.yellow,
			jsxIdentifier: colors.yellow,
			punctuator: colors.yellow,
			number: colors.magenta,
			string: colors.green,
			regex: colors.magenta,
			comment: colors.gray,
			invalid: compose(compose(colors.white, colors.bgRed), colors.bold),
			gutter: colors.gray,
			marker: compose(colors.red, colors.bold),
			message: compose(colors.red, colors.bold),
			reset: colors.reset
		};
	}
	const defsOn = buildDefs(picocolors$1.createColors(true));
	const defsOff = buildDefs(picocolors$1.createColors(false));
	function getDefs(enabled) {
		return enabled ? defsOn : defsOff;
	}
	const sometimesKeywords = new Set([
		"as",
		"async",
		"from",
		"get",
		"of",
		"set"
	]);
	const NEWLINE$1 = /\r\n|[\n\r\u2028\u2029]/;
	const BRACKET = /^[()[\]{}]$/;
	let tokenize$2;
	{
		const JSX_TAG = /^[a-z][\w-]*$/i;
		const getTokenType = function(token, offset, text) {
			if (token.type === "name") {
				if (helperValidatorIdentifier.isKeyword(token.value) || helperValidatorIdentifier.isStrictReservedWord(token.value, true) || sometimesKeywords.has(token.value)) return "keyword";
				if (JSX_TAG.test(token.value) && (text[offset - 1] === "<" || text.slice(offset - 2, offset) === "</")) return "jsxIdentifier";
				if (token.value[0] !== token.value[0].toLowerCase()) return "capitalized";
			}
			if (token.type === "punctuator" && BRACKET.test(token.value)) return "bracket";
			if (token.type === "invalid" && (token.value === "@" || token.value === "#")) return "punctuator";
			return token.type;
		};
		tokenize$2 = function* (text) {
			let match;
			while (match = jsTokens$1.default.exec(text)) {
				const token = jsTokens$1.matchToToken(match);
				yield {
					type: getTokenType(token, match.index, text),
					value: token.value
				};
			}
		};
	}
	function highlight(text) {
		if (text === "") return "";
		const defs = getDefs(true);
		let highlighted = "";
		for (const { type, value } of tokenize$2(text)) if (type in defs) highlighted += value.split(NEWLINE$1).map((str) => defs[type](str)).join("\n");
		else highlighted += value;
		return highlighted;
	}
	let deprecationWarningShown = false;
	const NEWLINE = /\r\n|[\n\r\u2028\u2029]/;
	function getMarkerLines(loc, source, opts) {
		const startLoc = Object.assign({
			column: 0,
			line: -1
		}, loc.start);
		const endLoc = Object.assign({}, startLoc, loc.end);
		const { linesAbove = 2, linesBelow = 3 } = opts || {};
		const startLine = startLoc.line;
		const startColumn = startLoc.column;
		const endLine = endLoc.line;
		const endColumn = endLoc.column;
		let start = Math.max(startLine - (linesAbove + 1), 0);
		let end = Math.min(source.length, endLine + linesBelow);
		if (startLine === -1) start = 0;
		if (endLine === -1) end = source.length;
		const lineDiff = endLine - startLine;
		const markerLines = {};
		if (lineDiff) for (let i = 0; i <= lineDiff; i++) {
			const lineNumber = i + startLine;
			if (!startColumn) markerLines[lineNumber] = true;
			else if (i === 0) markerLines[lineNumber] = [startColumn, source[lineNumber - 1].length - startColumn + 1];
			else if (i === lineDiff) markerLines[lineNumber] = [0, endColumn];
			else markerLines[lineNumber] = [0, source[lineNumber - i].length];
		}
		else if (startColumn === endColumn) if (startColumn) markerLines[startLine] = [startColumn, 0];
		else markerLines[startLine] = true;
		else markerLines[startLine] = [startColumn, endColumn - startColumn];
		return {
			start,
			end,
			markerLines
		};
	}
	function codeFrameColumns(rawLines, loc, opts = {}) {
		const shouldHighlight = opts.forceColor || isColorSupported() && opts.highlightCode;
		const defs = getDefs(shouldHighlight);
		const { start, end, markerLines } = getMarkerLines(loc, rawLines.split(NEWLINE), opts);
		const hasColumns = loc.start && typeof loc.start.column === "number";
		const numberMaxWidth = String(end).length;
		let frame = (shouldHighlight ? highlight(rawLines) : rawLines).split(NEWLINE, end).slice(start, end).map((line, index$1) => {
			const number = start + 1 + index$1;
			const gutter = ` ${` ${number}`.slice(-numberMaxWidth)} |`;
			const hasMarker = markerLines[number];
			const lastMarkerLine = !markerLines[number + 1];
			if (hasMarker) {
				let markerLine = "";
				if (Array.isArray(hasMarker)) {
					const markerSpacing = line.slice(0, Math.max(hasMarker[0] - 1, 0)).replace(/[^\t]/g, " ");
					const numberOfMarkers = hasMarker[1] || 1;
					markerLine = [
						"\n ",
						defs.gutter(gutter.replace(/\d/g, " ")),
						" ",
						markerSpacing,
						defs.marker("^").repeat(numberOfMarkers)
					].join("");
					if (lastMarkerLine && opts.message) markerLine += " " + defs.message(opts.message);
				}
				return [
					defs.marker(">"),
					defs.gutter(gutter),
					line.length > 0 ? ` ${line}` : "",
					markerLine
				].join("");
			} else return ` ${defs.gutter(gutter)}${line.length > 0 ? ` ${line}` : ""}`;
		}).join("\n");
		if (opts.message && !hasColumns) frame = `${" ".repeat(numberMaxWidth + 1)}${opts.message}\n${frame}`;
		if (shouldHighlight) return defs.reset(frame);
		else return frame;
	}
	function index(rawLines, lineNumber, colNumber, opts = {}) {
		if (!deprecationWarningShown) {
			deprecationWarningShown = true;
			const message = "Passing lineNumber and colNumber is deprecated to @babel/code-frame. Please use `codeFrameColumns`.";
			if (process.emitWarning) process.emitWarning(message, "DeprecationWarning");
			else {
				const deprecationError = new Error(message);
				deprecationError.name = "DeprecationWarning";
				console.warn(new Error(message));
			}
		}
		colNumber = Math.max(colNumber, 0);
		return codeFrameColumns(rawLines, { start: {
			column: colNumber,
			line: lineNumber
		} }, opts);
	}
	lib$3.codeFrameColumns = codeFrameColumns;
	lib$3.default = index;
	lib$3.highlight = highlight;
	return lib$3;
}
var libExports = requireLib$2();
function getPosition(text, textIndex) {
	const lineBreakBefore = textIndex === 0 ? -1 : text.lastIndexOf("\n", textIndex - 1);
	return {
		line: lineBreakBefore === -1 ? 0 : text.slice(0, lineBreakBefore + 1).match(/\n/g).length,
		column: textIndex - lineBreakBefore - 1
	};
}
function indexToPosition(text, textIndex, { oneBased = false } = {}) {
	if (typeof text !== "string") throw new TypeError("Text parameter should be a string");
	if (!Number.isInteger(textIndex)) throw new TypeError("Index parameter should be an integer");
	if (textIndex < 0 || textIndex > text.length) throw new RangeError("Index out of bounds");
	const position = getPosition(text, textIndex);
	return oneBased ? {
		line: position.line + 1,
		column: position.column + 1
	} : position;
}
const getCodePoint = (character) => `\\u{${character.codePointAt(0).toString(16)}}`;
var JSONError = class JSONError extends Error {
	name = "JSONError";
	fileName;
	#input;
	#jsonParseError;
	#message;
	#codeFrame;
	#rawCodeFrame;
	constructor(messageOrOptions) {
		if (typeof messageOrOptions === "string") {
			super();
			this.#message = messageOrOptions;
		} else {
			const { jsonParseError, fileName, input } = messageOrOptions;
			super(void 0, { cause: jsonParseError });
			this.#input = input;
			this.#jsonParseError = jsonParseError;
			this.fileName = fileName;
		}
		Error.captureStackTrace?.(this, JSONError);
	}
	get message() {
		this.#message ??= `${addCodePointToUnexpectedToken(this.#jsonParseError.message)}${this.#input === "" ? " while parsing empty string" : ""}`;
		const { codeFrame } = this;
		return `${this.#message}${this.fileName ? ` in ${this.fileName}` : ""}${codeFrame ? `\n\n${codeFrame}\n` : ""}`;
	}
	set message(message) {
		this.#message = message;
	}
	#getCodeFrame(highlightCode) {
		if (!this.#jsonParseError) return;
		const input = this.#input;
		const location = getErrorLocation(input, this.#jsonParseError.message);
		if (!location) return;
		return libExports.codeFrameColumns(input, { start: location }, { highlightCode });
	}
	get codeFrame() {
		this.#codeFrame ??= this.#getCodeFrame(true);
		return this.#codeFrame;
	}
	get rawCodeFrame() {
		this.#rawCodeFrame ??= this.#getCodeFrame(false);
		return this.#rawCodeFrame;
	}
};
const getErrorLocation = (string, message) => {
	const match = message.match(/in JSON at position (?<index>\d+)(?: \(line (?<line>\d+) column (?<column>\d+)\))?$/);
	if (!match) return;
	const { index, line, column } = match.groups;
	if (line && column) return {
		line: Number(line),
		column: Number(column)
	};
	return indexToPosition(string, Number(index), { oneBased: true });
};
const addCodePointToUnexpectedToken = (message) => message.replace(/(?<=^Unexpected token )(?<quote>')?(.)\k<quote>/, (_, _quote, token) => `"${token}"(${getCodePoint(token)})`);
function parseJson(string, reviver, fileName) {
	try {
		return JSON.parse(string, reviver);
	} catch (error) {
		throw new JSONError({
			jsonParseError: error,
			fileName,
			input: string
		});
	}
}
var debug_1;
var hasRequiredDebug;
function requireDebug() {
	if (hasRequiredDebug) return debug_1;
	hasRequiredDebug = 1;
	debug_1 = typeof process === "object" && process.env && process.env.NODE_DEBUG && /\bsemver\b/i.test(process.env.NODE_DEBUG) ? (...args) => console.error("SEMVER", ...args) : () => {};
	return debug_1;
}
var constants$2;
var hasRequiredConstants;
function requireConstants() {
	if (hasRequiredConstants) return constants$2;
	hasRequiredConstants = 1;
	const SEMVER_SPEC_VERSION = "2.0.0";
	const MAX_LENGTH = 256;
	const MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER || 9007199254740991;
	constants$2 = {
		MAX_LENGTH,
		MAX_SAFE_COMPONENT_LENGTH: 16,
		MAX_SAFE_BUILD_LENGTH: MAX_LENGTH - 6,
		MAX_SAFE_INTEGER,
		RELEASE_TYPES: [
			"major",
			"premajor",
			"minor",
			"preminor",
			"patch",
			"prepatch",
			"prerelease"
		],
		SEMVER_SPEC_VERSION,
		FLAG_INCLUDE_PRERELEASE: 1,
		FLAG_LOOSE: 2
	};
	return constants$2;
}
var re = { exports: {} };
var hasRequiredRe;
function requireRe() {
	if (hasRequiredRe) return re.exports;
	hasRequiredRe = 1;
	(function(module$1, exports$1) {
		const { MAX_SAFE_COMPONENT_LENGTH, MAX_SAFE_BUILD_LENGTH, MAX_LENGTH } = requireConstants();
		const debug = requireDebug();
		exports$1 = module$1.exports = {};
		const re$2 = exports$1.re = [];
		const safeRe = exports$1.safeRe = [];
		const src = exports$1.src = [];
		const safeSrc = exports$1.safeSrc = [];
		const t = exports$1.t = {};
		let R = 0;
		const LETTERDASHNUMBER = "[a-zA-Z0-9-]";
		const safeRegexReplacements = [
			["\\s", 1],
			["\\d", MAX_LENGTH],
			[LETTERDASHNUMBER, MAX_SAFE_BUILD_LENGTH]
		];
		const makeSafeRegex = (value) => {
			for (const [token, max] of safeRegexReplacements) value = value.split(`${token}*`).join(`${token}{0,${max}}`).split(`${token}+`).join(`${token}{1,${max}}`);
			return value;
		};
		const createToken = (name, value, isGlobal) => {
			const safe = makeSafeRegex(value);
			const index = R++;
			debug(name, index, value);
			t[name] = index;
			src[index] = value;
			safeSrc[index] = safe;
			re$2[index] = new RegExp(value, isGlobal ? "g" : void 0);
			safeRe[index] = new RegExp(safe, isGlobal ? "g" : void 0);
		};
		createToken("NUMERICIDENTIFIER", "0|[1-9]\\d*");
		createToken("NUMERICIDENTIFIERLOOSE", "\\d+");
		createToken("NONNUMERICIDENTIFIER", `\\d*[a-zA-Z-]${LETTERDASHNUMBER}*`);
		createToken("MAINVERSION", `(${src[t.NUMERICIDENTIFIER]})\\.(${src[t.NUMERICIDENTIFIER]})\\.(${src[t.NUMERICIDENTIFIER]})`);
		createToken("MAINVERSIONLOOSE", `(${src[t.NUMERICIDENTIFIERLOOSE]})\\.(${src[t.NUMERICIDENTIFIERLOOSE]})\\.(${src[t.NUMERICIDENTIFIERLOOSE]})`);
		createToken("PRERELEASEIDENTIFIER", `(?:${src[t.NONNUMERICIDENTIFIER]}|${src[t.NUMERICIDENTIFIER]})`);
		createToken("PRERELEASEIDENTIFIERLOOSE", `(?:${src[t.NONNUMERICIDENTIFIER]}|${src[t.NUMERICIDENTIFIERLOOSE]})`);
		createToken("PRERELEASE", `(?:-(${src[t.PRERELEASEIDENTIFIER]}(?:\\.${src[t.PRERELEASEIDENTIFIER]})*))`);
		createToken("PRERELEASELOOSE", `(?:-?(${src[t.PRERELEASEIDENTIFIERLOOSE]}(?:\\.${src[t.PRERELEASEIDENTIFIERLOOSE]})*))`);
		createToken("BUILDIDENTIFIER", `${LETTERDASHNUMBER}+`);
		createToken("BUILD", `(?:\\+(${src[t.BUILDIDENTIFIER]}(?:\\.${src[t.BUILDIDENTIFIER]})*))`);
		createToken("FULLPLAIN", `v?${src[t.MAINVERSION]}${src[t.PRERELEASE]}?${src[t.BUILD]}?`);
		createToken("FULL", `^${src[t.FULLPLAIN]}$`);
		createToken("LOOSEPLAIN", `[v=\\s]*${src[t.MAINVERSIONLOOSE]}${src[t.PRERELEASELOOSE]}?${src[t.BUILD]}?`);
		createToken("LOOSE", `^${src[t.LOOSEPLAIN]}$`);
		createToken("GTLT", "((?:<|>)?=?)");
		createToken("XRANGEIDENTIFIERLOOSE", `${src[t.NUMERICIDENTIFIERLOOSE]}|x|X|\\*`);
		createToken("XRANGEIDENTIFIER", `${src[t.NUMERICIDENTIFIER]}|x|X|\\*`);
		createToken("XRANGEPLAIN", `[v=\\s]*(${src[t.XRANGEIDENTIFIER]})(?:\\.(${src[t.XRANGEIDENTIFIER]})(?:\\.(${src[t.XRANGEIDENTIFIER]})(?:${src[t.PRERELEASE]})?${src[t.BUILD]}?)?)?`);
		createToken("XRANGEPLAINLOOSE", `[v=\\s]*(${src[t.XRANGEIDENTIFIERLOOSE]})(?:\\.(${src[t.XRANGEIDENTIFIERLOOSE]})(?:\\.(${src[t.XRANGEIDENTIFIERLOOSE]})(?:${src[t.PRERELEASELOOSE]})?${src[t.BUILD]}?)?)?`);
		createToken("XRANGE", `^${src[t.GTLT]}\\s*${src[t.XRANGEPLAIN]}$`);
		createToken("XRANGELOOSE", `^${src[t.GTLT]}\\s*${src[t.XRANGEPLAINLOOSE]}$`);
		createToken("COERCEPLAIN", `(^|[^\\d])(\\d{1,${MAX_SAFE_COMPONENT_LENGTH}})(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?`);
		createToken("COERCE", `${src[t.COERCEPLAIN]}(?:$|[^\\d])`);
		createToken("COERCEFULL", src[t.COERCEPLAIN] + `(?:${src[t.PRERELEASE]})?(?:${src[t.BUILD]})?(?:$|[^\\d])`);
		createToken("COERCERTL", src[t.COERCE], true);
		createToken("COERCERTLFULL", src[t.COERCEFULL], true);
		createToken("LONETILDE", "(?:~>?)");
		createToken("TILDETRIM", `(\\s*)${src[t.LONETILDE]}\\s+`, true);
		exports$1.tildeTrimReplace = "$1~";
		createToken("TILDE", `^${src[t.LONETILDE]}${src[t.XRANGEPLAIN]}$`);
		createToken("TILDELOOSE", `^${src[t.LONETILDE]}${src[t.XRANGEPLAINLOOSE]}$`);
		createToken("LONECARET", "(?:\\^)");
		createToken("CARETTRIM", `(\\s*)${src[t.LONECARET]}\\s+`, true);
		exports$1.caretTrimReplace = "$1^";
		createToken("CARET", `^${src[t.LONECARET]}${src[t.XRANGEPLAIN]}$`);
		createToken("CARETLOOSE", `^${src[t.LONECARET]}${src[t.XRANGEPLAINLOOSE]}$`);
		createToken("COMPARATORLOOSE", `^${src[t.GTLT]}\\s*(${src[t.LOOSEPLAIN]})$|^$`);
		createToken("COMPARATOR", `^${src[t.GTLT]}\\s*(${src[t.FULLPLAIN]})$|^$`);
		createToken("COMPARATORTRIM", `(\\s*)${src[t.GTLT]}\\s*(${src[t.LOOSEPLAIN]}|${src[t.XRANGEPLAIN]})`, true);
		exports$1.comparatorTrimReplace = "$1$2$3";
		createToken("HYPHENRANGE", `^\\s*(${src[t.XRANGEPLAIN]})\\s+-\\s+(${src[t.XRANGEPLAIN]})\\s*$`);
		createToken("HYPHENRANGELOOSE", `^\\s*(${src[t.XRANGEPLAINLOOSE]})\\s+-\\s+(${src[t.XRANGEPLAINLOOSE]})\\s*$`);
		createToken("STAR", "(<|>)?=?\\s*\\*");
		createToken("GTE0", "^\\s*>=\\s*0\\.0\\.0\\s*$");
		createToken("GTE0PRE", "^\\s*>=\\s*0\\.0\\.0-0\\s*$");
	})(re, re.exports);
	return re.exports;
}
var parseOptions_1;
var hasRequiredParseOptions;
function requireParseOptions() {
	if (hasRequiredParseOptions) return parseOptions_1;
	hasRequiredParseOptions = 1;
	const looseOption = Object.freeze({ loose: true });
	const emptyOpts = Object.freeze({});
	const parseOptions = (options) => {
		if (!options) return emptyOpts;
		if (typeof options !== "object") return looseOption;
		return options;
	};
	parseOptions_1 = parseOptions;
	return parseOptions_1;
}
var identifiers;
var hasRequiredIdentifiers;
function requireIdentifiers() {
	if (hasRequiredIdentifiers) return identifiers;
	hasRequiredIdentifiers = 1;
	const numeric = /^[0-9]+$/;
	const compareIdentifiers = (a, b) => {
		const anum = numeric.test(a);
		const bnum = numeric.test(b);
		if (anum && bnum) {
			a = +a;
			b = +b;
		}
		return a === b ? 0 : anum && !bnum ? -1 : bnum && !anum ? 1 : a < b ? -1 : 1;
	};
	const rcompareIdentifiers = (a, b) => compareIdentifiers(b, a);
	identifiers = {
		compareIdentifiers,
		rcompareIdentifiers
	};
	return identifiers;
}
var semver;
var hasRequiredSemver;
function requireSemver() {
	if (hasRequiredSemver) return semver;
	hasRequiredSemver = 1;
	const debug = requireDebug();
	const { MAX_LENGTH, MAX_SAFE_INTEGER } = requireConstants();
	const { safeRe: re$2, t } = requireRe();
	const parseOptions = requireParseOptions();
	const { compareIdentifiers } = requireIdentifiers();
	class SemVer {
		constructor(version, options) {
			options = parseOptions(options);
			if (version instanceof SemVer) if (version.loose === !!options.loose && version.includePrerelease === !!options.includePrerelease) return version;
			else version = version.version;
			else if (typeof version !== "string") throw new TypeError(`Invalid version. Must be a string. Got type "${typeof version}".`);
			if (version.length > MAX_LENGTH) throw new TypeError(`version is longer than ${MAX_LENGTH} characters`);
			debug("SemVer", version, options);
			this.options = options;
			this.loose = !!options.loose;
			this.includePrerelease = !!options.includePrerelease;
			const m = version.trim().match(options.loose ? re$2[t.LOOSE] : re$2[t.FULL]);
			if (!m) throw new TypeError(`Invalid Version: ${version}`);
			this.raw = version;
			this.major = +m[1];
			this.minor = +m[2];
			this.patch = +m[3];
			if (this.major > MAX_SAFE_INTEGER || this.major < 0) throw new TypeError("Invalid major version");
			if (this.minor > MAX_SAFE_INTEGER || this.minor < 0) throw new TypeError("Invalid minor version");
			if (this.patch > MAX_SAFE_INTEGER || this.patch < 0) throw new TypeError("Invalid patch version");
			if (!m[4]) this.prerelease = [];
			else this.prerelease = m[4].split(".").map((id) => {
				if (/^[0-9]+$/.test(id)) {
					const num = +id;
					if (num >= 0 && num < MAX_SAFE_INTEGER) return num;
				}
				return id;
			});
			this.build = m[5] ? m[5].split(".") : [];
			this.format();
		}
		format() {
			this.version = `${this.major}.${this.minor}.${this.patch}`;
			if (this.prerelease.length) this.version += `-${this.prerelease.join(".")}`;
			return this.version;
		}
		toString() {
			return this.version;
		}
		compare(other) {
			debug("SemVer.compare", this.version, this.options, other);
			if (!(other instanceof SemVer)) {
				if (typeof other === "string" && other === this.version) return 0;
				other = new SemVer(other, this.options);
			}
			if (other.version === this.version) return 0;
			return this.compareMain(other) || this.comparePre(other);
		}
		compareMain(other) {
			if (!(other instanceof SemVer)) other = new SemVer(other, this.options);
			return compareIdentifiers(this.major, other.major) || compareIdentifiers(this.minor, other.minor) || compareIdentifiers(this.patch, other.patch);
		}
		comparePre(other) {
			if (!(other instanceof SemVer)) other = new SemVer(other, this.options);
			if (this.prerelease.length && !other.prerelease.length) return -1;
			else if (!this.prerelease.length && other.prerelease.length) return 1;
			else if (!this.prerelease.length && !other.prerelease.length) return 0;
			let i = 0;
			do {
				const a = this.prerelease[i];
				const b = other.prerelease[i];
				debug("prerelease compare", i, a, b);
				if (a === void 0 && b === void 0) return 0;
				else if (b === void 0) return 1;
				else if (a === void 0) return -1;
				else if (a === b) continue;
				else return compareIdentifiers(a, b);
			} while (++i);
		}
		compareBuild(other) {
			if (!(other instanceof SemVer)) other = new SemVer(other, this.options);
			let i = 0;
			do {
				const a = this.build[i];
				const b = other.build[i];
				debug("build compare", i, a, b);
				if (a === void 0 && b === void 0) return 0;
				else if (b === void 0) return 1;
				else if (a === void 0) return -1;
				else if (a === b) continue;
				else return compareIdentifiers(a, b);
			} while (++i);
		}
		inc(release, identifier$1, identifierBase) {
			if (release.startsWith("pre")) {
				if (!identifier$1 && identifierBase === false) throw new Error("invalid increment argument: identifier is empty");
				if (identifier$1) {
					const match = `-${identifier$1}`.match(this.options.loose ? re$2[t.PRERELEASELOOSE] : re$2[t.PRERELEASE]);
					if (!match || match[1] !== identifier$1) throw new Error(`invalid identifier: ${identifier$1}`);
				}
			}
			switch (release) {
				case "premajor":
					this.prerelease.length = 0;
					this.patch = 0;
					this.minor = 0;
					this.major++;
					this.inc("pre", identifier$1, identifierBase);
					break;
				case "preminor":
					this.prerelease.length = 0;
					this.patch = 0;
					this.minor++;
					this.inc("pre", identifier$1, identifierBase);
					break;
				case "prepatch":
					this.prerelease.length = 0;
					this.inc("patch", identifier$1, identifierBase);
					this.inc("pre", identifier$1, identifierBase);
					break;
				case "prerelease":
					if (this.prerelease.length === 0) this.inc("patch", identifier$1, identifierBase);
					this.inc("pre", identifier$1, identifierBase);
					break;
				case "release":
					if (this.prerelease.length === 0) throw new Error(`version ${this.raw} is not a prerelease`);
					this.prerelease.length = 0;
					break;
				case "major":
					if (this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0) this.major++;
					this.minor = 0;
					this.patch = 0;
					this.prerelease = [];
					break;
				case "minor":
					if (this.patch !== 0 || this.prerelease.length === 0) this.minor++;
					this.patch = 0;
					this.prerelease = [];
					break;
				case "patch":
					if (this.prerelease.length === 0) this.patch++;
					this.prerelease = [];
					break;
				case "pre": {
					const base = Number(identifierBase) ? 1 : 0;
					if (this.prerelease.length === 0) this.prerelease = [base];
					else {
						let i = this.prerelease.length;
						while (--i >= 0) if (typeof this.prerelease[i] === "number") {
							this.prerelease[i]++;
							i = -2;
						}
						if (i === -1) {
							if (identifier$1 === this.prerelease.join(".") && identifierBase === false) throw new Error("invalid increment argument: identifier already exists");
							this.prerelease.push(base);
						}
					}
					if (identifier$1) {
						let prerelease = [identifier$1, base];
						if (identifierBase === false) prerelease = [identifier$1];
						if (compareIdentifiers(this.prerelease[0], identifier$1) === 0) {
							if (isNaN(this.prerelease[1])) this.prerelease = prerelease;
						} else this.prerelease = prerelease;
					}
					break;
				}
				default: throw new Error(`invalid increment argument: ${release}`);
			}
			this.raw = this.format();
			if (this.build.length) this.raw += `+${this.build.join(".")}`;
			return this;
		}
	}
	semver = SemVer;
	return semver;
}
var parse_1;
var hasRequiredParse$1;
function requireParse$1() {
	if (hasRequiredParse$1) return parse_1;
	hasRequiredParse$1 = 1;
	const SemVer = requireSemver();
	const parse$4 = (version, options, throwErrors = false) => {
		if (version instanceof SemVer) return version;
		try {
			return new SemVer(version, options);
		} catch (er) {
			if (!throwErrors) return null;
			throw er;
		}
	};
	parse_1 = parse$4;
	return parse_1;
}
var valid_1;
var hasRequiredValid;
function requireValid() {
	if (hasRequiredValid) return valid_1;
	hasRequiredValid = 1;
	const parse$4 = requireParse$1();
	const valid = (version, options) => {
		const v = parse$4(version, options);
		return v ? v.version : null;
	};
	valid_1 = valid;
	return valid_1;
}
var clean_1;
var hasRequiredClean;
function requireClean() {
	if (hasRequiredClean) return clean_1;
	hasRequiredClean = 1;
	const parse$4 = requireParse$1();
	const clean = (version, options) => {
		const s = parse$4(version.trim().replace(/^[=v]+/, ""), options);
		return s ? s.version : null;
	};
	clean_1 = clean;
	return clean_1;
}
const require$$1$3 = [
	"0BSD",
	"3D-Slicer-1.0",
	"AAL",
	"ADSL",
	"AFL-1.1",
	"AFL-1.2",
	"AFL-2.0",
	"AFL-2.1",
	"AFL-3.0",
	"AGPL-1.0-only",
	"AGPL-1.0-or-later",
	"AGPL-3.0-only",
	"AGPL-3.0-or-later",
	"AMD-newlib",
	"AMDPLPA",
	"AML",
	"AML-glslang",
	"AMPAS",
	"ANTLR-PD",
	"ANTLR-PD-fallback",
	"APAFML",
	"APL-1.0",
	"APSL-1.0",
	"APSL-1.1",
	"APSL-1.2",
	"APSL-2.0",
	"ASWF-Digital-Assets-1.0",
	"ASWF-Digital-Assets-1.1",
	"Abstyles",
	"AdaCore-doc",
	"Adobe-2006",
	"Adobe-Display-PostScript",
	"Adobe-Glyph",
	"Adobe-Utopia",
	"Afmparse",
	"Aladdin",
	"Apache-1.0",
	"Apache-1.1",
	"Apache-2.0",
	"App-s2p",
	"Arphic-1999",
	"Artistic-1.0",
	"Artistic-1.0-Perl",
	"Artistic-1.0-cl8",
	"Artistic-2.0",
	"Artistic-dist",
	"Aspell-RU",
	"BSD-1-Clause",
	"BSD-2-Clause",
	"BSD-2-Clause-Darwin",
	"BSD-2-Clause-Patent",
	"BSD-2-Clause-Views",
	"BSD-2-Clause-first-lines",
	"BSD-2-Clause-pkgconf-disclaimer",
	"BSD-3-Clause",
	"BSD-3-Clause-Attribution",
	"BSD-3-Clause-Clear",
	"BSD-3-Clause-HP",
	"BSD-3-Clause-LBNL",
	"BSD-3-Clause-Modification",
	"BSD-3-Clause-No-Military-License",
	"BSD-3-Clause-No-Nuclear-License",
	"BSD-3-Clause-No-Nuclear-License-2014",
	"BSD-3-Clause-No-Nuclear-Warranty",
	"BSD-3-Clause-Open-MPI",
	"BSD-3-Clause-Sun",
	"BSD-3-Clause-acpica",
	"BSD-3-Clause-flex",
	"BSD-4-Clause",
	"BSD-4-Clause-Shortened",
	"BSD-4-Clause-UC",
	"BSD-4.3RENO",
	"BSD-4.3TAHOE",
	"BSD-Advertising-Acknowledgement",
	"BSD-Attribution-HPND-disclaimer",
	"BSD-Inferno-Nettverk",
	"BSD-Protection",
	"BSD-Source-Code",
	"BSD-Source-beginning-file",
	"BSD-Systemics",
	"BSD-Systemics-W3Works",
	"BSL-1.0",
	"BUSL-1.1",
	"Baekmuk",
	"Bahyph",
	"Barr",
	"Beerware",
	"BitTorrent-1.0",
	"BitTorrent-1.1",
	"Bitstream-Charter",
	"Bitstream-Vera",
	"BlueOak-1.0.0",
	"Boehm-GC",
	"Boehm-GC-without-fee",
	"Borceux",
	"Brian-Gladman-2-Clause",
	"Brian-Gladman-3-Clause",
	"C-UDA-1.0",
	"CAL-1.0",
	"CAL-1.0-Combined-Work-Exception",
	"CATOSL-1.1",
	"CC-BY-1.0",
	"CC-BY-2.0",
	"CC-BY-2.5",
	"CC-BY-2.5-AU",
	"CC-BY-3.0",
	"CC-BY-3.0-AT",
	"CC-BY-3.0-AU",
	"CC-BY-3.0-DE",
	"CC-BY-3.0-IGO",
	"CC-BY-3.0-NL",
	"CC-BY-3.0-US",
	"CC-BY-4.0",
	"CC-BY-NC-1.0",
	"CC-BY-NC-2.0",
	"CC-BY-NC-2.5",
	"CC-BY-NC-3.0",
	"CC-BY-NC-3.0-DE",
	"CC-BY-NC-4.0",
	"CC-BY-NC-ND-1.0",
	"CC-BY-NC-ND-2.0",
	"CC-BY-NC-ND-2.5",
	"CC-BY-NC-ND-3.0",
	"CC-BY-NC-ND-3.0-DE",
	"CC-BY-NC-ND-3.0-IGO",
	"CC-BY-NC-ND-4.0",
	"CC-BY-NC-SA-1.0",
	"CC-BY-NC-SA-2.0",
	"CC-BY-NC-SA-2.0-DE",
	"CC-BY-NC-SA-2.0-FR",
	"CC-BY-NC-SA-2.0-UK",
	"CC-BY-NC-SA-2.5",
	"CC-BY-NC-SA-3.0",
	"CC-BY-NC-SA-3.0-DE",
	"CC-BY-NC-SA-3.0-IGO",
	"CC-BY-NC-SA-4.0",
	"CC-BY-ND-1.0",
	"CC-BY-ND-2.0",
	"CC-BY-ND-2.5",
	"CC-BY-ND-3.0",
	"CC-BY-ND-3.0-DE",
	"CC-BY-ND-4.0",
	"CC-BY-SA-1.0",
	"CC-BY-SA-2.0",
	"CC-BY-SA-2.0-UK",
	"CC-BY-SA-2.1-JP",
	"CC-BY-SA-2.5",
	"CC-BY-SA-3.0",
	"CC-BY-SA-3.0-AT",
	"CC-BY-SA-3.0-DE",
	"CC-BY-SA-3.0-IGO",
	"CC-BY-SA-4.0",
	"CC-PDDC",
	"CC-PDM-1.0",
	"CC-SA-1.0",
	"CC0-1.0",
	"CDDL-1.0",
	"CDDL-1.1",
	"CDL-1.0",
	"CDLA-Permissive-1.0",
	"CDLA-Permissive-2.0",
	"CDLA-Sharing-1.0",
	"CECILL-1.0",
	"CECILL-1.1",
	"CECILL-2.0",
	"CECILL-2.1",
	"CECILL-B",
	"CECILL-C",
	"CERN-OHL-1.1",
	"CERN-OHL-1.2",
	"CERN-OHL-P-2.0",
	"CERN-OHL-S-2.0",
	"CERN-OHL-W-2.0",
	"CFITSIO",
	"CMU-Mach",
	"CMU-Mach-nodoc",
	"CNRI-Jython",
	"CNRI-Python",
	"CNRI-Python-GPL-Compatible",
	"COIL-1.0",
	"CPAL-1.0",
	"CPL-1.0",
	"CPOL-1.02",
	"CUA-OPL-1.0",
	"Caldera",
	"Caldera-no-preamble",
	"Catharon",
	"ClArtistic",
	"Clips",
	"Community-Spec-1.0",
	"Condor-1.1",
	"Cornell-Lossless-JPEG",
	"Cronyx",
	"Crossword",
	"CryptoSwift",
	"CrystalStacker",
	"Cube",
	"D-FSL-1.0",
	"DEC-3-Clause",
	"DL-DE-BY-2.0",
	"DL-DE-ZERO-2.0",
	"DOC",
	"DRL-1.0",
	"DRL-1.1",
	"DSDP",
	"DocBook-DTD",
	"DocBook-Schema",
	"DocBook-Stylesheet",
	"DocBook-XML",
	"Dotseqn",
	"ECL-1.0",
	"ECL-2.0",
	"EFL-1.0",
	"EFL-2.0",
	"EPICS",
	"EPL-1.0",
	"EPL-2.0",
	"EUDatagrid",
	"EUPL-1.0",
	"EUPL-1.1",
	"EUPL-1.2",
	"Elastic-2.0",
	"Entessa",
	"ErlPL-1.1",
	"Eurosym",
	"FBM",
	"FDK-AAC",
	"FSFAP",
	"FSFAP-no-warranty-disclaimer",
	"FSFUL",
	"FSFULLR",
	"FSFULLRSD",
	"FSFULLRWD",
	"FSL-1.1-ALv2",
	"FSL-1.1-MIT",
	"FTL",
	"Fair",
	"Ferguson-Twofish",
	"Frameworx-1.0",
	"FreeBSD-DOC",
	"FreeImage",
	"Furuseth",
	"GCR-docs",
	"GD",
	"GFDL-1.1-invariants-only",
	"GFDL-1.1-invariants-or-later",
	"GFDL-1.1-no-invariants-only",
	"GFDL-1.1-no-invariants-or-later",
	"GFDL-1.1-only",
	"GFDL-1.1-or-later",
	"GFDL-1.2-invariants-only",
	"GFDL-1.2-invariants-or-later",
	"GFDL-1.2-no-invariants-only",
	"GFDL-1.2-no-invariants-or-later",
	"GFDL-1.2-only",
	"GFDL-1.2-or-later",
	"GFDL-1.3-invariants-only",
	"GFDL-1.3-invariants-or-later",
	"GFDL-1.3-no-invariants-only",
	"GFDL-1.3-no-invariants-or-later",
	"GFDL-1.3-only",
	"GFDL-1.3-or-later",
	"GL2PS",
	"GLWTPL",
	"GPL-1.0-only",
	"GPL-1.0-or-later",
	"GPL-2.0-only",
	"GPL-2.0-or-later",
	"GPL-3.0-only",
	"GPL-3.0-or-later",
	"Game-Programming-Gems",
	"Giftware",
	"Glide",
	"Glulxe",
	"Graphics-Gems",
	"Gutmann",
	"HDF5",
	"HIDAPI",
	"HP-1986",
	"HP-1989",
	"HPND",
	"HPND-DEC",
	"HPND-Fenneberg-Livingston",
	"HPND-INRIA-IMAG",
	"HPND-Intel",
	"HPND-Kevlin-Henney",
	"HPND-MIT-disclaimer",
	"HPND-Markus-Kuhn",
	"HPND-Netrek",
	"HPND-Pbmplus",
	"HPND-UC",
	"HPND-UC-export-US",
	"HPND-doc",
	"HPND-doc-sell",
	"HPND-export-US",
	"HPND-export-US-acknowledgement",
	"HPND-export-US-modify",
	"HPND-export2-US",
	"HPND-merchantability-variant",
	"HPND-sell-MIT-disclaimer-xserver",
	"HPND-sell-regexpr",
	"HPND-sell-variant",
	"HPND-sell-variant-MIT-disclaimer",
	"HPND-sell-variant-MIT-disclaimer-rev",
	"HTMLTIDY",
	"HaskellReport",
	"Hippocratic-2.1",
	"IBM-pibs",
	"ICU",
	"IEC-Code-Components-EULA",
	"IJG",
	"IJG-short",
	"IPA",
	"IPL-1.0",
	"ISC",
	"ISC-Veillard",
	"ImageMagick",
	"Imlib2",
	"Info-ZIP",
	"Inner-Net-2.0",
	"InnoSetup",
	"Intel",
	"Intel-ACPI",
	"Interbase-1.0",
	"JPL-image",
	"JPNIC",
	"JSON",
	"Jam",
	"JasPer-2.0",
	"Kastrup",
	"Kazlib",
	"Knuth-CTAN",
	"LAL-1.2",
	"LAL-1.3",
	"LGPL-2.0-only",
	"LGPL-2.0-or-later",
	"LGPL-2.1-only",
	"LGPL-2.1-or-later",
	"LGPL-3.0-only",
	"LGPL-3.0-or-later",
	"LGPLLR",
	"LOOP",
	"LPD-document",
	"LPL-1.0",
	"LPL-1.02",
	"LPPL-1.0",
	"LPPL-1.1",
	"LPPL-1.2",
	"LPPL-1.3a",
	"LPPL-1.3c",
	"LZMA-SDK-9.11-to-9.20",
	"LZMA-SDK-9.22",
	"Latex2e",
	"Latex2e-translated-notice",
	"Leptonica",
	"LiLiQ-P-1.1",
	"LiLiQ-R-1.1",
	"LiLiQ-Rplus-1.1",
	"Libpng",
	"Linux-OpenIB",
	"Linux-man-pages-1-para",
	"Linux-man-pages-copyleft",
	"Linux-man-pages-copyleft-2-para",
	"Linux-man-pages-copyleft-var",
	"Lucida-Bitmap-Fonts",
	"MIPS",
	"MIT",
	"MIT-0",
	"MIT-CMU",
	"MIT-Click",
	"MIT-Festival",
	"MIT-Khronos-old",
	"MIT-Modern-Variant",
	"MIT-Wu",
	"MIT-advertising",
	"MIT-enna",
	"MIT-feh",
	"MIT-open-group",
	"MIT-testregex",
	"MITNFA",
	"MMIXware",
	"MPEG-SSG",
	"MPL-1.0",
	"MPL-1.1",
	"MPL-2.0",
	"MPL-2.0-no-copyleft-exception",
	"MS-LPL",
	"MS-PL",
	"MS-RL",
	"MTLL",
	"Mackerras-3-Clause",
	"Mackerras-3-Clause-acknowledgment",
	"MakeIndex",
	"Martin-Birgmeier",
	"McPhee-slideshow",
	"Minpack",
	"MirOS",
	"Motosoto",
	"MulanPSL-1.0",
	"MulanPSL-2.0",
	"Multics",
	"Mup",
	"NAIST-2003",
	"NASA-1.3",
	"NBPL-1.0",
	"NCBI-PD",
	"NCGL-UK-2.0",
	"NCL",
	"NCSA",
	"NGPL",
	"NICTA-1.0",
	"NIST-PD",
	"NIST-PD-fallback",
	"NIST-Software",
	"NLOD-1.0",
	"NLOD-2.0",
	"NLPL",
	"NOSL",
	"NPL-1.0",
	"NPL-1.1",
	"NPOSL-3.0",
	"NRL",
	"NTIA-PD",
	"NTP",
	"NTP-0",
	"Naumen",
	"NetCDF",
	"Newsletr",
	"Nokia",
	"Noweb",
	"O-UDA-1.0",
	"OAR",
	"OCCT-PL",
	"OCLC-2.0",
	"ODC-By-1.0",
	"ODbL-1.0",
	"OFFIS",
	"OFL-1.0",
	"OFL-1.0-RFN",
	"OFL-1.0-no-RFN",
	"OFL-1.1",
	"OFL-1.1-RFN",
	"OFL-1.1-no-RFN",
	"OGC-1.0",
	"OGDL-Taiwan-1.0",
	"OGL-Canada-2.0",
	"OGL-UK-1.0",
	"OGL-UK-2.0",
	"OGL-UK-3.0",
	"OGTSL",
	"OLDAP-1.1",
	"OLDAP-1.2",
	"OLDAP-1.3",
	"OLDAP-1.4",
	"OLDAP-2.0",
	"OLDAP-2.0.1",
	"OLDAP-2.1",
	"OLDAP-2.2",
	"OLDAP-2.2.1",
	"OLDAP-2.2.2",
	"OLDAP-2.3",
	"OLDAP-2.4",
	"OLDAP-2.5",
	"OLDAP-2.6",
	"OLDAP-2.7",
	"OLDAP-2.8",
	"OLFL-1.3",
	"OML",
	"OPL-1.0",
	"OPL-UK-3.0",
	"OPUBL-1.0",
	"OSET-PL-2.1",
	"OSL-1.0",
	"OSL-1.1",
	"OSL-2.0",
	"OSL-2.1",
	"OSL-3.0",
	"OpenPBS-2.3",
	"OpenSSL",
	"OpenSSL-standalone",
	"OpenVision",
	"PADL",
	"PDDL-1.0",
	"PHP-3.0",
	"PHP-3.01",
	"PPL",
	"PSF-2.0",
	"Parity-6.0.0",
	"Parity-7.0.0",
	"Pixar",
	"Plexus",
	"PolyForm-Noncommercial-1.0.0",
	"PolyForm-Small-Business-1.0.0",
	"PostgreSQL",
	"Python-2.0",
	"Python-2.0.1",
	"QPL-1.0",
	"QPL-1.0-INRIA-2004",
	"Qhull",
	"RHeCos-1.1",
	"RPL-1.1",
	"RPL-1.5",
	"RPSL-1.0",
	"RSA-MD",
	"RSCPL",
	"Rdisc",
	"Ruby",
	"Ruby-pty",
	"SAX-PD",
	"SAX-PD-2.0",
	"SCEA",
	"SGI-B-1.0",
	"SGI-B-1.1",
	"SGI-B-2.0",
	"SGI-OpenGL",
	"SGP4",
	"SHL-0.5",
	"SHL-0.51",
	"SISSL",
	"SISSL-1.2",
	"SL",
	"SMAIL-GPL",
	"SMLNJ",
	"SMPPL",
	"SNIA",
	"SOFA",
	"SPL-1.0",
	"SSH-OpenSSH",
	"SSH-short",
	"SSLeay-standalone",
	"SSPL-1.0",
	"SUL-1.0",
	"SWL",
	"Saxpath",
	"SchemeReport",
	"Sendmail",
	"Sendmail-8.23",
	"Sendmail-Open-Source-1.1",
	"SimPL-2.0",
	"Sleepycat",
	"Soundex",
	"Spencer-86",
	"Spencer-94",
	"Spencer-99",
	"SugarCRM-1.1.3",
	"Sun-PPP",
	"Sun-PPP-2000",
	"SunPro",
	"Symlinks",
	"TAPR-OHL-1.0",
	"TCL",
	"TCP-wrappers",
	"TGPPL-1.0",
	"TMate",
	"TORQUE-1.1",
	"TOSL",
	"TPDL",
	"TPL-1.0",
	"TTWL",
	"TTYP0",
	"TU-Berlin-1.0",
	"TU-Berlin-2.0",
	"TermReadKey",
	"ThirdEye",
	"TrustedQSL",
	"UCAR",
	"UCL-1.0",
	"UMich-Merit",
	"UPL-1.0",
	"URT-RLE",
	"Ubuntu-font-1.0",
	"Unicode-3.0",
	"Unicode-DFS-2015",
	"Unicode-DFS-2016",
	"Unicode-TOU",
	"UnixCrypt",
	"Unlicense",
	"Unlicense-libtelnet",
	"Unlicense-libwhirlpool",
	"VOSTROM",
	"VSL-1.0",
	"Vim",
	"W3C",
	"W3C-19980720",
	"W3C-20150513",
	"WTFPL",
	"Watcom-1.0",
	"Widget-Workshop",
	"Wsuipa",
	"X11",
	"X11-distribute-modifications-variant",
	"X11-swapped",
	"XFree86-1.1",
	"XSkat",
	"Xdebug-1.03",
	"Xerox",
	"Xfig",
	"Xnet",
	"YPL-1.0",
	"YPL-1.1",
	"ZPL-1.1",
	"ZPL-2.0",
	"ZPL-2.1",
	"Zed",
	"Zeeff",
	"Zend-2.0",
	"Zimbra-1.3",
	"Zimbra-1.4",
	"Zlib",
	"any-OSI",
	"any-OSI-perl-modules",
	"bcrypt-Solar-Designer",
	"blessing",
	"bzip2-1.0.6",
	"check-cvs",
	"checkmk",
	"copyleft-next-0.3.0",
	"copyleft-next-0.3.1",
	"curl",
	"cve-tou",
	"diffmark",
	"dtoa",
	"dvipdfm",
	"eGenix",
	"etalab-2.0",
	"fwlw",
	"gSOAP-1.3b",
	"generic-xts",
	"gnuplot",
	"gtkbook",
	"hdparm",
	"iMatix",
	"jove",
	"libpng-1.6.35",
	"libpng-2.0",
	"libselinux-1.0",
	"libtiff",
	"libutil-David-Nugent",
	"lsof",
	"magaz",
	"mailprio",
	"man2html",
	"metamail",
	"mpi-permissive",
	"mpich2",
	"mplus",
	"ngrep",
	"pkgconf",
	"pnmstitch",
	"psfrag",
	"psutils",
	"python-ldap",
	"radvd",
	"snprintf",
	"softSurfer",
	"ssh-keyscan",
	"swrule",
	"threeparttable",
	"ulem",
	"w3m",
	"wwl",
	"xinetd",
	"xkeyboard-config-Zinoviev",
	"xlock",
	"xpp",
	"xzoom",
	"zlib-acknowledgement"
];
const require$$1$2 = [
	"AGPL-1.0",
	"AGPL-3.0",
	"BSD-2-Clause-FreeBSD",
	"BSD-2-Clause-NetBSD",
	"GFDL-1.1",
	"GFDL-1.2",
	"GFDL-1.3",
	"GPL-1.0",
	"GPL-2.0",
	"GPL-2.0-with-GCC-exception",
	"GPL-2.0-with-autoconf-exception",
	"GPL-2.0-with-bison-exception",
	"GPL-2.0-with-classpath-exception",
	"GPL-2.0-with-font-exception",
	"GPL-3.0",
	"GPL-3.0-with-GCC-exception",
	"GPL-3.0-with-autoconf-exception",
	"LGPL-2.0",
	"LGPL-2.1",
	"LGPL-3.0",
	"Net-SNMP",
	"Nunit",
	"StandardML-NJ",
	"bzip2-1.0.5",
	"eCos-2.0",
	"wxWindows"
];
const require$$2 = [
	"389-exception",
	"Asterisk-exception",
	"Autoconf-exception-2.0",
	"Autoconf-exception-3.0",
	"Autoconf-exception-generic",
	"Autoconf-exception-generic-3.0",
	"Autoconf-exception-macro",
	"Bison-exception-1.24",
	"Bison-exception-2.2",
	"Bootloader-exception",
	"Classpath-exception-2.0",
	"CLISP-exception-2.0",
	"cryptsetup-OpenSSL-exception",
	"DigiRule-FOSS-exception",
	"eCos-exception-2.0",
	"Fawkes-Runtime-exception",
	"FLTK-exception",
	"fmt-exception",
	"Font-exception-2.0",
	"freertos-exception-2.0",
	"GCC-exception-2.0",
	"GCC-exception-2.0-note",
	"GCC-exception-3.1",
	"Gmsh-exception",
	"GNAT-exception",
	"GNOME-examples-exception",
	"GNU-compiler-exception",
	"gnu-javamail-exception",
	"GPL-3.0-interface-exception",
	"GPL-3.0-linking-exception",
	"GPL-3.0-linking-source-exception",
	"GPL-CC-1.0",
	"GStreamer-exception-2005",
	"GStreamer-exception-2008",
	"i2p-gpl-java-exception",
	"KiCad-libraries-exception",
	"LGPL-3.0-linking-exception",
	"libpri-OpenH323-exception",
	"Libtool-exception",
	"Linux-syscall-note",
	"LLGPL",
	"LLVM-exception",
	"LZMA-exception",
	"mif-exception",
	"OCaml-LGPL-linking-exception",
	"OCCT-exception-1.0",
	"OpenJDK-assembly-exception-1.0",
	"openvpn-openssl-exception",
	"PS-or-PDF-font-exception-20170817",
	"QPL-1.0-INRIA-2004-exception",
	"Qt-GPL-exception-1.0",
	"Qt-LGPL-exception-1.1",
	"Qwt-exception-1.0",
	"SANE-exception",
	"SHL-2.0",
	"SHL-2.1",
	"stunnel-exception",
	"SWI-exception",
	"Swift-exception",
	"Texinfo-exception",
	"u-boot-exception-2.0",
	"UBDL-exception",
	"Universal-FOSS-exception-1.0",
	"vsftpd-openssl-exception",
	"WxWindows-exception-3.1",
	"x11vnc-openssl-exception"
];
var scan;
var hasRequiredScan;
function requireScan() {
	if (hasRequiredScan) return scan;
	hasRequiredScan = 1;
	var licenses = [].concat(require$$1$3).concat(require$$1$2);
	var exceptions = require$$2;
	scan = function(source) {
		var index = 0;
		function hasMore() {
			return index < source.length;
		}
		function read(value) {
			if (value instanceof RegExp) {
				var match = source.slice(index).match(value);
				if (match) {
					index += match[0].length;
					return match[0];
				}
			} else if (source.indexOf(value, index) === index) {
				index += value.length;
				return value;
			}
		}
		function skipWhitespace() {
			read(/[ ]*/);
		}
		function operator() {
			var string;
			var possibilities = [
				"WITH",
				"AND",
				"OR",
				"(",
				")",
				":",
				"+"
			];
			for (var i = 0; i < possibilities.length; i++) {
				string = read(possibilities[i]);
				if (string) break;
			}
			if (string === "+" && index > 1 && source[index - 2] === " ") throw new Error("Space before `+`");
			return string && {
				type: "OPERATOR",
				string
			};
		}
		function idstring() {
			return read(/[A-Za-z0-9-.]+/);
		}
		function expectIdstring() {
			var string = idstring();
			if (!string) throw new Error("Expected idstring at offset " + index);
			return string;
		}
		function documentRef() {
			if (read("DocumentRef-")) return {
				type: "DOCUMENTREF",
				string: expectIdstring()
			};
		}
		function licenseRef() {
			if (read("LicenseRef-")) return {
				type: "LICENSEREF",
				string: expectIdstring()
			};
		}
		function identifier$1() {
			var begin = index;
			var string = idstring();
			if (licenses.indexOf(string) !== -1) return {
				type: "LICENSE",
				string
			};
			else if (exceptions.indexOf(string) !== -1) return {
				type: "EXCEPTION",
				string
			};
			index = begin;
		}
		function parseToken() {
			return operator() || documentRef() || licenseRef() || identifier$1();
		}
		var tokens = [];
		while (hasMore()) {
			skipWhitespace();
			if (!hasMore()) break;
			var token = parseToken();
			if (!token) throw new Error("Unexpected `" + source[index] + "` at offset " + index);
			tokens.push(token);
		}
		return tokens;
	};
	return scan;
}
var parse;
var hasRequiredParse;
function requireParse() {
	if (hasRequiredParse) return parse;
	hasRequiredParse = 1;
	parse = function(tokens) {
		var index = 0;
		function hasMore() {
			return index < tokens.length;
		}
		function token() {
			return hasMore() ? tokens[index] : null;
		}
		function next() {
			if (!hasMore()) throw new Error();
			index++;
		}
		function parseOperator(operator) {
			var t = token();
			if (t && t.type === "OPERATOR" && operator === t.string) {
				next();
				return t.string;
			}
		}
		function parseWith() {
			if (parseOperator("WITH")) {
				var t = token();
				if (t && t.type === "EXCEPTION") {
					next();
					return t.string;
				}
				throw new Error("Expected exception after `WITH`");
			}
		}
		function parseLicenseRef() {
			var begin = index;
			var string = "";
			var t = token();
			if (t.type === "DOCUMENTREF") {
				next();
				string += "DocumentRef-" + t.string + ":";
				if (!parseOperator(":")) throw new Error("Expected `:` after `DocumentRef-...`");
			}
			t = token();
			if (t.type === "LICENSEREF") {
				next();
				string += "LicenseRef-" + t.string;
				return { license: string };
			}
			index = begin;
		}
		function parseLicense() {
			var t = token();
			if (t && t.type === "LICENSE") {
				next();
				var node$1 = { license: t.string };
				if (parseOperator("+")) node$1.plus = true;
				var exception = parseWith();
				if (exception) node$1.exception = exception;
				return node$1;
			}
		}
		function parseParenthesizedExpression() {
			if (!parseOperator("(")) return;
			var expr = parseExpression();
			if (!parseOperator(")")) throw new Error("Expected `)`");
			return expr;
		}
		function parseAtom() {
			return parseParenthesizedExpression() || parseLicenseRef() || parseLicense();
		}
		function makeBinaryOpParser(operator, nextParser) {
			return function parseBinaryOp() {
				var left = nextParser();
				if (!left) return;
				if (!parseOperator(operator)) return left;
				var right = parseBinaryOp();
				if (!right) throw new Error("Expected expression");
				return {
					left,
					conjunction: operator.toLowerCase(),
					right
				};
			};
		}
		var parseExpression = makeBinaryOpParser("OR", makeBinaryOpParser("AND", parseAtom));
		var node = parseExpression();
		if (!node || hasMore()) throw new Error("Syntax error");
		return node;
	};
	return parse;
}
var spdxExpressionParse;
var hasRequiredSpdxExpressionParse;
function requireSpdxExpressionParse() {
	if (hasRequiredSpdxExpressionParse) return spdxExpressionParse;
	hasRequiredSpdxExpressionParse = 1;
	var scan$1 = requireScan();
	var parse$4 = requireParse();
	spdxExpressionParse = function(source) {
		return parse$4(scan$1(source));
	};
	return spdxExpressionParse;
}
var spdxCorrect;
var hasRequiredSpdxCorrect;
function requireSpdxCorrect() {
	if (hasRequiredSpdxCorrect) return spdxCorrect;
	hasRequiredSpdxCorrect = 1;
	var parse$4 = requireSpdxExpressionParse();
	var spdxLicenseIds = require$$1$3;
	function valid(string) {
		try {
			parse$4(string);
			return true;
		} catch (error) {
			return false;
		}
	}
	function sortTranspositions(a, b) {
		var length = b[0].length - a[0].length;
		if (length !== 0) return length;
		return a[0].toUpperCase().localeCompare(b[0].toUpperCase());
	}
	var transpositions = [
		["APGL", "AGPL"],
		["Gpl", "GPL"],
		["GLP", "GPL"],
		["APL", "Apache"],
		["ISD", "ISC"],
		["GLP", "GPL"],
		["IST", "ISC"],
		["Claude", "Clause"],
		[" or later", "+"],
		[" International", ""],
		["GNU", "GPL"],
		["GUN", "GPL"],
		["+", ""],
		["GNU GPL", "GPL"],
		["GNU LGPL", "LGPL"],
		["GNU/GPL", "GPL"],
		["GNU GLP", "GPL"],
		["GNU LESSER GENERAL PUBLIC LICENSE", "LGPL"],
		["GNU Lesser General Public License", "LGPL"],
		["GNU LESSER GENERAL PUBLIC LICENSE", "LGPL-2.1"],
		["GNU Lesser General Public License", "LGPL-2.1"],
		["LESSER GENERAL PUBLIC LICENSE", "LGPL"],
		["Lesser General Public License", "LGPL"],
		["LESSER GENERAL PUBLIC LICENSE", "LGPL-2.1"],
		["Lesser General Public License", "LGPL-2.1"],
		["GNU General Public License", "GPL"],
		["Gnu public license", "GPL"],
		["GNU Public License", "GPL"],
		["GNU GENERAL PUBLIC LICENSE", "GPL"],
		["MTI", "MIT"],
		["Mozilla Public License", "MPL"],
		["Universal Permissive License", "UPL"],
		["WTH", "WTF"],
		["WTFGPL", "WTFPL"],
		["-License", ""]
	].sort(sortTranspositions);
	var TRANSPOSED = 0;
	var CORRECT = 1;
	var transforms = [
		function(argument) {
			return argument.toUpperCase();
		},
		function(argument) {
			return argument.trim();
		},
		function(argument) {
			return argument.replace(/\./g, "");
		},
		function(argument) {
			return argument.replace(/\s+/g, "");
		},
		function(argument) {
			return argument.replace(/\s+/g, "-");
		},
		function(argument) {
			return argument.replace("v", "-");
		},
		function(argument) {
			return argument.replace(/,?\s*(\d)/, "-$1");
		},
		function(argument) {
			return argument.replace(/,?\s*(\d)/, "-$1.0");
		},
		function(argument) {
			return argument.replace(/,?\s*(V\.|v\.|V|v|Version|version)\s*(\d)/, "-$2");
		},
		function(argument) {
			return argument.replace(/,?\s*(V\.|v\.|V|v|Version|version)\s*(\d)/, "-$2.0");
		},
		function(argument) {
			return argument[0].toUpperCase() + argument.slice(1);
		},
		function(argument) {
			return argument.replace("/", "-");
		},
		function(argument) {
			return argument.replace(/\s*V\s*(\d)/, "-$1").replace(/(\d)$/, "$1.0");
		},
		function(argument) {
			if (argument.indexOf("3.0") !== -1) return argument + "-or-later";
			else return argument + "-only";
		},
		function(argument) {
			return argument + "only";
		},
		function(argument) {
			return argument.replace(/(\d)$/, "-$1.0");
		},
		function(argument) {
			return argument.replace(/(-| )?(\d)$/, "-$2-Clause");
		},
		function(argument) {
			return argument.replace(/(-| )clause(-| )(\d)/, "-$3-Clause");
		},
		function(argument) {
			return argument.replace(/\b(Modified|New|Revised)(-| )?BSD((-| )License)?/i, "BSD-3-Clause");
		},
		function(argument) {
			return argument.replace(/\bSimplified(-| )?BSD((-| )License)?/i, "BSD-2-Clause");
		},
		function(argument) {
			return argument.replace(/\b(Free|Net)(-| )?BSD((-| )License)?/i, "BSD-2-Clause-$1BSD");
		},
		function(argument) {
			return argument.replace(/\bClear(-| )?BSD((-| )License)?/i, "BSD-3-Clause-Clear");
		},
		function(argument) {
			return argument.replace(/\b(Old|Original)(-| )?BSD((-| )License)?/i, "BSD-4-Clause");
		},
		function(argument) {
			return "CC-" + argument;
		},
		function(argument) {
			return "CC-" + argument + "-4.0";
		},
		function(argument) {
			return argument.replace("Attribution", "BY").replace("NonCommercial", "NC").replace("NoDerivatives", "ND").replace(/ (\d)/, "-$1").replace(/ ?International/, "");
		},
		function(argument) {
			return "CC-" + argument.replace("Attribution", "BY").replace("NonCommercial", "NC").replace("NoDerivatives", "ND").replace(/ (\d)/, "-$1").replace(/ ?International/, "") + "-4.0";
		}
	];
	var licensesWithVersions = spdxLicenseIds.map(function(id) {
		var match = /^(.*)-\d+\.\d+$/.exec(id);
		return match ? [match[0], match[1]] : [id, null];
	}).reduce(function(objectMap, item) {
		var key = item[1];
		objectMap[key] = objectMap[key] || [];
		objectMap[key].push(item[0]);
		return objectMap;
	}, {});
	var licensesWithOneVersion = Object.keys(licensesWithVersions).map(function makeEntries(key) {
		return [key, licensesWithVersions[key]];
	}).filter(function identifySoleVersions(item) {
		return item[1].length === 1 && item[0] !== null && item[0] !== "APL";
	}).map(function createLastResorts(item) {
		return [item[0], item[1][0]];
	});
	licensesWithVersions = void 0;
	var lastResorts = [
		["UNLI", "Unlicense"],
		["WTF", "WTFPL"],
		["2 CLAUSE", "BSD-2-Clause"],
		["2-CLAUSE", "BSD-2-Clause"],
		["3 CLAUSE", "BSD-3-Clause"],
		["3-CLAUSE", "BSD-3-Clause"],
		["AFFERO", "AGPL-3.0-or-later"],
		["AGPL", "AGPL-3.0-or-later"],
		["APACHE", "Apache-2.0"],
		["ARTISTIC", "Artistic-2.0"],
		["Affero", "AGPL-3.0-or-later"],
		["BEER", "Beerware"],
		["BOOST", "BSL-1.0"],
		["BSD", "BSD-2-Clause"],
		["CDDL", "CDDL-1.1"],
		["ECLIPSE", "EPL-1.0"],
		["FUCK", "WTFPL"],
		["GNU", "GPL-3.0-or-later"],
		["LGPL", "LGPL-3.0-or-later"],
		["GPLV1", "GPL-1.0-only"],
		["GPL-1", "GPL-1.0-only"],
		["GPLV2", "GPL-2.0-only"],
		["GPL-2", "GPL-2.0-only"],
		["GPL", "GPL-3.0-or-later"],
		["MIT +NO-FALSE-ATTRIBS", "MITNFA"],
		["MIT", "MIT"],
		["MPL", "MPL-2.0"],
		["X11", "X11"],
		["ZLIB", "Zlib"]
	].concat(licensesWithOneVersion).sort(sortTranspositions);
	var SUBSTRING = 0;
	var IDENTIFIER$1 = 1;
	var validTransformation = function(identifier$1) {
		for (var i = 0; i < transforms.length; i++) {
			var transformed = transforms[i](identifier$1).trim();
			if (transformed !== identifier$1 && valid(transformed)) return transformed;
		}
		return null;
	};
	var validLastResort = function(identifier$1) {
		var upperCased = identifier$1.toUpperCase();
		for (var i = 0; i < lastResorts.length; i++) {
			var lastResort = lastResorts[i];
			if (upperCased.indexOf(lastResort[SUBSTRING]) > -1) return lastResort[IDENTIFIER$1];
		}
		return null;
	};
	var anyCorrection = function(identifier$1, check$1) {
		for (var i = 0; i < transpositions.length; i++) {
			var transposition = transpositions[i];
			var transposed = transposition[TRANSPOSED];
			if (identifier$1.indexOf(transposed) > -1) {
				var checked = check$1(identifier$1.replace(transposed, transposition[CORRECT]));
				if (checked !== null) return checked;
			}
		}
		return null;
	};
	spdxCorrect = function(identifier$1, options) {
		options = options || {};
		var upgrade = options.upgrade === void 0 ? true : !!options.upgrade;
		function postprocess(value) {
			return upgrade ? upgradeGPLs(value) : value;
		}
		if (!(typeof identifier$1 === "string" && identifier$1.trim().length !== 0)) throw Error("Invalid argument. Expected non-empty string.");
		identifier$1 = identifier$1.trim();
		if (valid(identifier$1)) return postprocess(identifier$1);
		var noPlus = identifier$1.replace(/\+$/, "").trim();
		if (valid(noPlus)) return postprocess(noPlus);
		var transformed = validTransformation(identifier$1);
		if (transformed !== null) return postprocess(transformed);
		transformed = anyCorrection(identifier$1, function(argument) {
			if (valid(argument)) return argument;
			return validTransformation(argument);
		});
		if (transformed !== null) return postprocess(transformed);
		transformed = validLastResort(identifier$1);
		if (transformed !== null) return postprocess(transformed);
		transformed = anyCorrection(identifier$1, validLastResort);
		if (transformed !== null) return postprocess(transformed);
		return null;
	};
	function upgradeGPLs(value) {
		if ([
			"GPL-1.0",
			"LGPL-1.0",
			"AGPL-1.0",
			"GPL-2.0",
			"LGPL-2.0",
			"AGPL-2.0",
			"LGPL-2.1"
		].indexOf(value) !== -1) return value + "-only";
		else if ([
			"GPL-1.0+",
			"GPL-2.0+",
			"GPL-3.0+",
			"LGPL-2.0+",
			"LGPL-2.1+",
			"LGPL-3.0+",
			"AGPL-1.0+",
			"AGPL-3.0+"
		].indexOf(value) !== -1) return value.replace(/\+$/, "-or-later");
		else if ([
			"GPL-3.0",
			"LGPL-3.0",
			"AGPL-3.0"
		].indexOf(value) !== -1) return value + "-or-later";
		else return value;
	}
	return spdxCorrect;
}
var validateNpmPackageLicense;
var hasRequiredValidateNpmPackageLicense;
function requireValidateNpmPackageLicense() {
	if (hasRequiredValidateNpmPackageLicense) return validateNpmPackageLicense;
	hasRequiredValidateNpmPackageLicense = 1;
	var parse$4 = requireSpdxExpressionParse();
	var correct = requireSpdxCorrect();
	var genericWarning = "license should be a valid SPDX license expression (without \"LicenseRef\"), \"UNLICENSED\", or \"SEE LICENSE IN <filename>\"";
	var fileReferenceRE = /^SEE LICEN[CS]E IN (.+)$/;
	function startsWith(prefix, string) {
		return string.slice(0, prefix.length) === prefix;
	}
	function usesLicenseRef(ast) {
		if (ast.hasOwnProperty("license")) {
			var license = ast.license;
			return startsWith("LicenseRef", license) || startsWith("DocumentRef", license);
		} else return usesLicenseRef(ast.left) || usesLicenseRef(ast.right);
	}
	validateNpmPackageLicense = function(argument) {
		var ast;
		try {
			ast = parse$4(argument);
		} catch (e) {
			var match;
			if (argument === "UNLICENSED" || argument === "UNLICENCED") return {
				validForOldPackages: true,
				validForNewPackages: true,
				unlicensed: true
			};
			else if (match = fileReferenceRE.exec(argument)) return {
				validForOldPackages: true,
				validForNewPackages: true,
				inFile: match[1]
			};
			else {
				var result = {
					validForOldPackages: false,
					validForNewPackages: false,
					warnings: [genericWarning]
				};
				if (argument.trim().length !== 0) {
					var corrected = correct(argument);
					if (corrected) result.warnings.push("license is similar to the valid expression \"" + corrected + "\"");
				}
				return result;
			}
		}
		if (usesLicenseRef(ast)) return {
			validForNewPackages: false,
			validForOldPackages: false,
			spdx: true,
			warnings: [genericWarning]
		};
		else return {
			validForNewPackages: true,
			validForOldPackages: true,
			spdx: true
		};
	};
	return validateNpmPackageLicense;
}
var commonjs$1 = {};
var hasRequiredCommonjs$1;
function requireCommonjs$1() {
	if (hasRequiredCommonjs$1) return commonjs$1;
	hasRequiredCommonjs$1 = 1;
	Object.defineProperty(commonjs$1, "__esModule", { value: true });
	commonjs$1.LRUCache = void 0;
	const perf = typeof performance === "object" && performance && typeof performance.now === "function" ? performance : Date;
	const warned = /* @__PURE__ */ new Set();
	const PROCESS = typeof process === "object" && !!process ? process : {};
	const emitWarning = (msg, type, code, fn) => {
		typeof PROCESS.emitWarning === "function" ? PROCESS.emitWarning(msg, type, code, fn) : console.error(`[${code}] ${type}: ${msg}`);
	};
	let AC = globalThis.AbortController;
	let AS = globalThis.AbortSignal;
	if (typeof AC === "undefined") {
		AS = class AbortSignal {
			onabort;
			_onabort = [];
			reason;
			aborted = false;
			addEventListener(_, fn) {
				this._onabort.push(fn);
			}
		};
		AC = class AbortController$1 {
			constructor() {
				warnACPolyfill();
			}
			signal = new AS();
			abort(reason) {
				if (this.signal.aborted) return;
				this.signal.reason = reason;
				this.signal.aborted = true;
				for (const fn of this.signal._onabort) fn(reason);
				this.signal.onabort?.(reason);
			}
		};
		let printACPolyfillWarning = PROCESS.env?.LRU_CACHE_IGNORE_AC_WARNING !== "1";
		const warnACPolyfill = () => {
			if (!printACPolyfillWarning) return;
			printACPolyfillWarning = false;
			emitWarning("AbortController is not defined. If using lru-cache in node 14, load an AbortController polyfill from the `node-abort-controller` package. A minimal polyfill is provided for use by LRUCache.fetch(), but it should not be relied upon in other contexts (eg, passing it to other APIs that use AbortController/AbortSignal might have undesirable effects). You may disable this with LRU_CACHE_IGNORE_AC_WARNING=1 in the env.", "NO_ABORT_CONTROLLER", "ENOTSUP", warnACPolyfill);
		};
	}
	const shouldWarn = (code) => !warned.has(code);
	const isPosInt = (n) => n && n === Math.floor(n) && n > 0 && isFinite(n);
	const getUintArray = (max) => !isPosInt(max) ? null : max <= Math.pow(2, 8) ? Uint8Array : max <= Math.pow(2, 16) ? Uint16Array : max <= Math.pow(2, 32) ? Uint32Array : max <= Number.MAX_SAFE_INTEGER ? ZeroArray : null;
	class ZeroArray extends Array {
		constructor(size) {
			super(size);
			this.fill(0);
		}
	}
	class Stack {
		heap;
		length;
		static #constructing = false;
		static create(max) {
			const HeapCls = getUintArray(max);
			if (!HeapCls) return [];
			Stack.#constructing = true;
			const s = new Stack(max, HeapCls);
			Stack.#constructing = false;
			return s;
		}
		constructor(max, HeapCls) {
			if (!Stack.#constructing) throw new TypeError("instantiate Stack using Stack.create(n)");
			this.heap = new HeapCls(max);
			this.length = 0;
		}
		push(n) {
			this.heap[this.length++] = n;
		}
		pop() {
			return this.heap[--this.length];
		}
	}
	class LRUCache {
		#max;
		#maxSize;
		#dispose;
		#disposeAfter;
		#fetchMethod;
		#memoMethod;
		ttl;
		ttlResolution;
		ttlAutopurge;
		updateAgeOnGet;
		updateAgeOnHas;
		allowStale;
		noDisposeOnSet;
		noUpdateTTL;
		maxEntrySize;
		sizeCalculation;
		noDeleteOnFetchRejection;
		noDeleteOnStaleGet;
		allowStaleOnFetchAbort;
		allowStaleOnFetchRejection;
		ignoreFetchAbort;
		#size;
		#calculatedSize;
		#keyMap;
		#keyList;
		#valList;
		#next;
		#prev;
		#head;
		#tail;
		#free;
		#disposed;
		#sizes;
		#starts;
		#ttls;
		#hasDispose;
		#hasFetchMethod;
		#hasDisposeAfter;
		static unsafeExposeInternals(c) {
			return {
				starts: c.#starts,
				ttls: c.#ttls,
				sizes: c.#sizes,
				keyMap: c.#keyMap,
				keyList: c.#keyList,
				valList: c.#valList,
				next: c.#next,
				prev: c.#prev,
				get head() {
					return c.#head;
				},
				get tail() {
					return c.#tail;
				},
				free: c.#free,
				isBackgroundFetch: (p) => c.#isBackgroundFetch(p),
				backgroundFetch: (k, index, options, context) => c.#backgroundFetch(k, index, options, context),
				moveToTail: (index) => c.#moveToTail(index),
				indexes: (options) => c.#indexes(options),
				rindexes: (options) => c.#rindexes(options),
				isStale: (index) => c.#isStale(index)
			};
		}
		get max() {
			return this.#max;
		}
		get maxSize() {
			return this.#maxSize;
		}
		get calculatedSize() {
			return this.#calculatedSize;
		}
		get size() {
			return this.#size;
		}
		get fetchMethod() {
			return this.#fetchMethod;
		}
		get memoMethod() {
			return this.#memoMethod;
		}
		get dispose() {
			return this.#dispose;
		}
		get disposeAfter() {
			return this.#disposeAfter;
		}
		constructor(options) {
			const { max = 0, ttl, ttlResolution = 1, ttlAutopurge, updateAgeOnGet, updateAgeOnHas, allowStale, dispose, disposeAfter, noDisposeOnSet, noUpdateTTL, maxSize = 0, maxEntrySize = 0, sizeCalculation, fetchMethod, memoMethod, noDeleteOnFetchRejection, noDeleteOnStaleGet, allowStaleOnFetchRejection, allowStaleOnFetchAbort, ignoreFetchAbort } = options;
			if (max !== 0 && !isPosInt(max)) throw new TypeError("max option must be a nonnegative integer");
			const UintArray = max ? getUintArray(max) : Array;
			if (!UintArray) throw new Error("invalid max value: " + max);
			this.#max = max;
			this.#maxSize = maxSize;
			this.maxEntrySize = maxEntrySize || this.#maxSize;
			this.sizeCalculation = sizeCalculation;
			if (this.sizeCalculation) {
				if (!this.#maxSize && !this.maxEntrySize) throw new TypeError("cannot set sizeCalculation without setting maxSize or maxEntrySize");
				if (typeof this.sizeCalculation !== "function") throw new TypeError("sizeCalculation set to non-function");
			}
			if (memoMethod !== void 0 && typeof memoMethod !== "function") throw new TypeError("memoMethod must be a function if defined");
			this.#memoMethod = memoMethod;
			if (fetchMethod !== void 0 && typeof fetchMethod !== "function") throw new TypeError("fetchMethod must be a function if specified");
			this.#fetchMethod = fetchMethod;
			this.#hasFetchMethod = !!fetchMethod;
			this.#keyMap = /* @__PURE__ */ new Map();
			this.#keyList = new Array(max).fill(void 0);
			this.#valList = new Array(max).fill(void 0);
			this.#next = new UintArray(max);
			this.#prev = new UintArray(max);
			this.#head = 0;
			this.#tail = 0;
			this.#free = Stack.create(max);
			this.#size = 0;
			this.#calculatedSize = 0;
			if (typeof dispose === "function") this.#dispose = dispose;
			if (typeof disposeAfter === "function") {
				this.#disposeAfter = disposeAfter;
				this.#disposed = [];
			} else {
				this.#disposeAfter = void 0;
				this.#disposed = void 0;
			}
			this.#hasDispose = !!this.#dispose;
			this.#hasDisposeAfter = !!this.#disposeAfter;
			this.noDisposeOnSet = !!noDisposeOnSet;
			this.noUpdateTTL = !!noUpdateTTL;
			this.noDeleteOnFetchRejection = !!noDeleteOnFetchRejection;
			this.allowStaleOnFetchRejection = !!allowStaleOnFetchRejection;
			this.allowStaleOnFetchAbort = !!allowStaleOnFetchAbort;
			this.ignoreFetchAbort = !!ignoreFetchAbort;
			if (this.maxEntrySize !== 0) {
				if (this.#maxSize !== 0) {
					if (!isPosInt(this.#maxSize)) throw new TypeError("maxSize must be a positive integer if specified");
				}
				if (!isPosInt(this.maxEntrySize)) throw new TypeError("maxEntrySize must be a positive integer if specified");
				this.#initializeSizeTracking();
			}
			this.allowStale = !!allowStale;
			this.noDeleteOnStaleGet = !!noDeleteOnStaleGet;
			this.updateAgeOnGet = !!updateAgeOnGet;
			this.updateAgeOnHas = !!updateAgeOnHas;
			this.ttlResolution = isPosInt(ttlResolution) || ttlResolution === 0 ? ttlResolution : 1;
			this.ttlAutopurge = !!ttlAutopurge;
			this.ttl = ttl || 0;
			if (this.ttl) {
				if (!isPosInt(this.ttl)) throw new TypeError("ttl must be a positive integer if specified");
				this.#initializeTTLTracking();
			}
			if (this.#max === 0 && this.ttl === 0 && this.#maxSize === 0) throw new TypeError("At least one of max, maxSize, or ttl is required");
			if (!this.ttlAutopurge && !this.#max && !this.#maxSize) {
				const code = "LRU_CACHE_UNBOUNDED";
				if (shouldWarn(code)) {
					warned.add(code);
					emitWarning("TTL caching without ttlAutopurge, max, or maxSize can result in unbounded memory consumption.", "UnboundedCacheWarning", code, LRUCache);
				}
			}
		}
		getRemainingTTL(key) {
			return this.#keyMap.has(key) ? Infinity : 0;
		}
		#initializeTTLTracking() {
			const ttls = new ZeroArray(this.#max);
			const starts = new ZeroArray(this.#max);
			this.#ttls = ttls;
			this.#starts = starts;
			this.#setItemTTL = (index, ttl, start = perf.now()) => {
				starts[index] = ttl !== 0 ? start : 0;
				ttls[index] = ttl;
				if (ttl !== 0 && this.ttlAutopurge) {
					const t = setTimeout(() => {
						if (this.#isStale(index)) this.#delete(this.#keyList[index], "expire");
					}, ttl + 1);
					if (t.unref) t.unref();
				}
			};
			this.#updateItemAge = (index) => {
				starts[index] = ttls[index] !== 0 ? perf.now() : 0;
			};
			this.#statusTTL = (status, index) => {
				if (ttls[index]) {
					const ttl = ttls[index];
					const start = starts[index];
					if (!ttl || !start) return;
					status.ttl = ttl;
					status.start = start;
					status.now = cachedNow || getNow();
					status.remainingTTL = ttl - (status.now - start);
				}
			};
			let cachedNow = 0;
			const getNow = () => {
				const n = perf.now();
				if (this.ttlResolution > 0) {
					cachedNow = n;
					const t = setTimeout(() => cachedNow = 0, this.ttlResolution);
					if (t.unref) t.unref();
				}
				return n;
			};
			this.getRemainingTTL = (key) => {
				const index = this.#keyMap.get(key);
				if (index === void 0) return 0;
				const ttl = ttls[index];
				const start = starts[index];
				if (!ttl || !start) return Infinity;
				return ttl - ((cachedNow || getNow()) - start);
			};
			this.#isStale = (index) => {
				const s = starts[index];
				const t = ttls[index];
				return !!t && !!s && (cachedNow || getNow()) - s > t;
			};
		}
		#updateItemAge = () => {};
		#statusTTL = () => {};
		#setItemTTL = () => {};
		#isStale = () => false;
		#initializeSizeTracking() {
			const sizes = new ZeroArray(this.#max);
			this.#calculatedSize = 0;
			this.#sizes = sizes;
			this.#removeItemSize = (index) => {
				this.#calculatedSize -= sizes[index];
				sizes[index] = 0;
			};
			this.#requireSize = (k, v, size, sizeCalculation) => {
				if (this.#isBackgroundFetch(v)) return 0;
				if (!isPosInt(size)) if (sizeCalculation) {
					if (typeof sizeCalculation !== "function") throw new TypeError("sizeCalculation must be a function");
					size = sizeCalculation(v, k);
					if (!isPosInt(size)) throw new TypeError("sizeCalculation return invalid (expect positive integer)");
				} else throw new TypeError("invalid size value (must be positive integer). When maxSize or maxEntrySize is used, sizeCalculation or size must be set.");
				return size;
			};
			this.#addItemSize = (index, size, status) => {
				sizes[index] = size;
				if (this.#maxSize) {
					const maxSize = this.#maxSize - sizes[index];
					while (this.#calculatedSize > maxSize) this.#evict(true);
				}
				this.#calculatedSize += sizes[index];
				if (status) {
					status.entrySize = size;
					status.totalCalculatedSize = this.#calculatedSize;
				}
			};
		}
		#removeItemSize = (_i) => {};
		#addItemSize = (_i, _s, _st) => {};
		#requireSize = (_k, _v, size, sizeCalculation) => {
			if (size || sizeCalculation) throw new TypeError("cannot set size without setting maxSize or maxEntrySize on cache");
			return 0;
		};
		*#indexes({ allowStale = this.allowStale } = {}) {
			if (this.#size) for (let i = this.#tail;;) {
				if (!this.#isValidIndex(i)) break;
				if (allowStale || !this.#isStale(i)) yield i;
				if (i === this.#head) break;
				else i = this.#prev[i];
			}
		}
		*#rindexes({ allowStale = this.allowStale } = {}) {
			if (this.#size) for (let i = this.#head;;) {
				if (!this.#isValidIndex(i)) break;
				if (allowStale || !this.#isStale(i)) yield i;
				if (i === this.#tail) break;
				else i = this.#next[i];
			}
		}
		#isValidIndex(index) {
			return index !== void 0 && this.#keyMap.get(this.#keyList[index]) === index;
		}
		*entries() {
			for (const i of this.#indexes()) if (this.#valList[i] !== void 0 && this.#keyList[i] !== void 0 && !this.#isBackgroundFetch(this.#valList[i])) yield [this.#keyList[i], this.#valList[i]];
		}
		*rentries() {
			for (const i of this.#rindexes()) if (this.#valList[i] !== void 0 && this.#keyList[i] !== void 0 && !this.#isBackgroundFetch(this.#valList[i])) yield [this.#keyList[i], this.#valList[i]];
		}
		*keys() {
			for (const i of this.#indexes()) {
				const k = this.#keyList[i];
				if (k !== void 0 && !this.#isBackgroundFetch(this.#valList[i])) yield k;
			}
		}
		*rkeys() {
			for (const i of this.#rindexes()) {
				const k = this.#keyList[i];
				if (k !== void 0 && !this.#isBackgroundFetch(this.#valList[i])) yield k;
			}
		}
		*values() {
			for (const i of this.#indexes()) if (this.#valList[i] !== void 0 && !this.#isBackgroundFetch(this.#valList[i])) yield this.#valList[i];
		}
		*rvalues() {
			for (const i of this.#rindexes()) if (this.#valList[i] !== void 0 && !this.#isBackgroundFetch(this.#valList[i])) yield this.#valList[i];
		}
		[Symbol.iterator]() {
			return this.entries();
		}
		[Symbol.toStringTag] = "LRUCache";
		find(fn, getOptions$1 = {}) {
			for (const i of this.#indexes()) {
				const v = this.#valList[i];
				const value = this.#isBackgroundFetch(v) ? v.__staleWhileFetching : v;
				if (value === void 0) continue;
				if (fn(value, this.#keyList[i], this)) return this.get(this.#keyList[i], getOptions$1);
			}
		}
		forEach(fn, thisp = this) {
			for (const i of this.#indexes()) {
				const v = this.#valList[i];
				const value = this.#isBackgroundFetch(v) ? v.__staleWhileFetching : v;
				if (value === void 0) continue;
				fn.call(thisp, value, this.#keyList[i], this);
			}
		}
		rforEach(fn, thisp = this) {
			for (const i of this.#rindexes()) {
				const v = this.#valList[i];
				const value = this.#isBackgroundFetch(v) ? v.__staleWhileFetching : v;
				if (value === void 0) continue;
				fn.call(thisp, value, this.#keyList[i], this);
			}
		}
		purgeStale() {
			let deleted = false;
			for (const i of this.#rindexes({ allowStale: true })) if (this.#isStale(i)) {
				this.#delete(this.#keyList[i], "expire");
				deleted = true;
			}
			return deleted;
		}
		info(key) {
			const i = this.#keyMap.get(key);
			if (i === void 0) return void 0;
			const v = this.#valList[i];
			const value = this.#isBackgroundFetch(v) ? v.__staleWhileFetching : v;
			if (value === void 0) return void 0;
			const entry = { value };
			if (this.#ttls && this.#starts) {
				const ttl = this.#ttls[i];
				const start = this.#starts[i];
				if (ttl && start) {
					entry.ttl = ttl - (perf.now() - start);
					entry.start = Date.now();
				}
			}
			if (this.#sizes) entry.size = this.#sizes[i];
			return entry;
		}
		dump() {
			const arr = [];
			for (const i of this.#indexes({ allowStale: true })) {
				const key = this.#keyList[i];
				const v = this.#valList[i];
				const value = this.#isBackgroundFetch(v) ? v.__staleWhileFetching : v;
				if (value === void 0 || key === void 0) continue;
				const entry = { value };
				if (this.#ttls && this.#starts) {
					entry.ttl = this.#ttls[i];
					const age = perf.now() - this.#starts[i];
					entry.start = Math.floor(Date.now() - age);
				}
				if (this.#sizes) entry.size = this.#sizes[i];
				arr.unshift([key, entry]);
			}
			return arr;
		}
		load(arr) {
			this.clear();
			for (const [key, entry] of arr) {
				if (entry.start) {
					const age = Date.now() - entry.start;
					entry.start = perf.now() - age;
				}
				this.set(key, entry.value, entry);
			}
		}
		set(k, v, setOptions = {}) {
			if (v === void 0) {
				this.delete(k);
				return this;
			}
			const { ttl = this.ttl, start, noDisposeOnSet = this.noDisposeOnSet, sizeCalculation = this.sizeCalculation, status } = setOptions;
			let { noUpdateTTL = this.noUpdateTTL } = setOptions;
			const size = this.#requireSize(k, v, setOptions.size || 0, sizeCalculation);
			if (this.maxEntrySize && size > this.maxEntrySize) {
				if (status) {
					status.set = "miss";
					status.maxEntrySizeExceeded = true;
				}
				this.#delete(k, "set");
				return this;
			}
			let index = this.#size === 0 ? void 0 : this.#keyMap.get(k);
			if (index === void 0) {
				index = this.#size === 0 ? this.#tail : this.#free.length !== 0 ? this.#free.pop() : this.#size === this.#max ? this.#evict(false) : this.#size;
				this.#keyList[index] = k;
				this.#valList[index] = v;
				this.#keyMap.set(k, index);
				this.#next[this.#tail] = index;
				this.#prev[index] = this.#tail;
				this.#tail = index;
				this.#size++;
				this.#addItemSize(index, size, status);
				if (status) status.set = "add";
				noUpdateTTL = false;
			} else {
				this.#moveToTail(index);
				const oldVal = this.#valList[index];
				if (v !== oldVal) {
					if (this.#hasFetchMethod && this.#isBackgroundFetch(oldVal)) {
						oldVal.__abortController.abort(/* @__PURE__ */ new Error("replaced"));
						const { __staleWhileFetching: s } = oldVal;
						if (s !== void 0 && !noDisposeOnSet) {
							if (this.#hasDispose) this.#dispose?.(s, k, "set");
							if (this.#hasDisposeAfter) this.#disposed?.push([
								s,
								k,
								"set"
							]);
						}
					} else if (!noDisposeOnSet) {
						if (this.#hasDispose) this.#dispose?.(oldVal, k, "set");
						if (this.#hasDisposeAfter) this.#disposed?.push([
							oldVal,
							k,
							"set"
						]);
					}
					this.#removeItemSize(index);
					this.#addItemSize(index, size, status);
					this.#valList[index] = v;
					if (status) {
						status.set = "replace";
						const oldValue = oldVal && this.#isBackgroundFetch(oldVal) ? oldVal.__staleWhileFetching : oldVal;
						if (oldValue !== void 0) status.oldValue = oldValue;
					}
				} else if (status) status.set = "update";
			}
			if (ttl !== 0 && !this.#ttls) this.#initializeTTLTracking();
			if (this.#ttls) {
				if (!noUpdateTTL) this.#setItemTTL(index, ttl, start);
				if (status) this.#statusTTL(status, index);
			}
			if (!noDisposeOnSet && this.#hasDisposeAfter && this.#disposed) {
				const dt = this.#disposed;
				let task;
				while (task = dt?.shift()) this.#disposeAfter?.(...task);
			}
			return this;
		}
		pop() {
			try {
				while (this.#size) {
					const val = this.#valList[this.#head];
					this.#evict(true);
					if (this.#isBackgroundFetch(val)) {
						if (val.__staleWhileFetching) return val.__staleWhileFetching;
					} else if (val !== void 0) return val;
				}
			} finally {
				if (this.#hasDisposeAfter && this.#disposed) {
					const dt = this.#disposed;
					let task;
					while (task = dt?.shift()) this.#disposeAfter?.(...task);
				}
			}
		}
		#evict(free) {
			const head = this.#head;
			const k = this.#keyList[head];
			const v = this.#valList[head];
			if (this.#hasFetchMethod && this.#isBackgroundFetch(v)) v.__abortController.abort(/* @__PURE__ */ new Error("evicted"));
			else if (this.#hasDispose || this.#hasDisposeAfter) {
				if (this.#hasDispose) this.#dispose?.(v, k, "evict");
				if (this.#hasDisposeAfter) this.#disposed?.push([
					v,
					k,
					"evict"
				]);
			}
			this.#removeItemSize(head);
			if (free) {
				this.#keyList[head] = void 0;
				this.#valList[head] = void 0;
				this.#free.push(head);
			}
			if (this.#size === 1) {
				this.#head = this.#tail = 0;
				this.#free.length = 0;
			} else this.#head = this.#next[head];
			this.#keyMap.delete(k);
			this.#size--;
			return head;
		}
		has(k, hasOptions = {}) {
			const { updateAgeOnHas = this.updateAgeOnHas, status } = hasOptions;
			const index = this.#keyMap.get(k);
			if (index !== void 0) {
				const v = this.#valList[index];
				if (this.#isBackgroundFetch(v) && v.__staleWhileFetching === void 0) return false;
				if (!this.#isStale(index)) {
					if (updateAgeOnHas) this.#updateItemAge(index);
					if (status) {
						status.has = "hit";
						this.#statusTTL(status, index);
					}
					return true;
				} else if (status) {
					status.has = "stale";
					this.#statusTTL(status, index);
				}
			} else if (status) status.has = "miss";
			return false;
		}
		peek(k, peekOptions = {}) {
			const { allowStale = this.allowStale } = peekOptions;
			const index = this.#keyMap.get(k);
			if (index === void 0 || !allowStale && this.#isStale(index)) return;
			const v = this.#valList[index];
			return this.#isBackgroundFetch(v) ? v.__staleWhileFetching : v;
		}
		#backgroundFetch(k, index, options, context) {
			const v = index === void 0 ? void 0 : this.#valList[index];
			if (this.#isBackgroundFetch(v)) return v;
			const ac = new AC();
			const { signal } = options;
			signal?.addEventListener("abort", () => ac.abort(signal.reason), { signal: ac.signal });
			const fetchOpts = {
				signal: ac.signal,
				options,
				context
			};
			const cb = (v$1, updateCache = false) => {
				const { aborted } = ac.signal;
				const ignoreAbort = options.ignoreFetchAbort && v$1 !== void 0;
				if (options.status) if (aborted && !updateCache) {
					options.status.fetchAborted = true;
					options.status.fetchError = ac.signal.reason;
					if (ignoreAbort) options.status.fetchAbortIgnored = true;
				} else options.status.fetchResolved = true;
				if (aborted && !ignoreAbort && !updateCache) return fetchFail(ac.signal.reason);
				const bf$1 = p;
				if (this.#valList[index] === p) if (v$1 === void 0) if (bf$1.__staleWhileFetching) this.#valList[index] = bf$1.__staleWhileFetching;
				else this.#delete(k, "fetch");
				else {
					if (options.status) options.status.fetchUpdated = true;
					this.set(k, v$1, fetchOpts.options);
				}
				return v$1;
			};
			const eb = (er) => {
				if (options.status) {
					options.status.fetchRejected = true;
					options.status.fetchError = er;
				}
				return fetchFail(er);
			};
			const fetchFail = (er) => {
				const { aborted } = ac.signal;
				const allowStaleAborted = aborted && options.allowStaleOnFetchAbort;
				const allowStale = allowStaleAborted || options.allowStaleOnFetchRejection;
				const noDelete = allowStale || options.noDeleteOnFetchRejection;
				const bf$1 = p;
				if (this.#valList[index] === p) {
					if (!noDelete || bf$1.__staleWhileFetching === void 0) this.#delete(k, "fetch");
					else if (!allowStaleAborted) this.#valList[index] = bf$1.__staleWhileFetching;
				}
				if (allowStale) {
					if (options.status && bf$1.__staleWhileFetching !== void 0) options.status.returnedStale = true;
					return bf$1.__staleWhileFetching;
				} else if (bf$1.__returned === bf$1) throw er;
			};
			const pcall = (res, rej) => {
				const fmp = this.#fetchMethod?.(k, v, fetchOpts);
				if (fmp && fmp instanceof Promise) fmp.then((v$1) => res(v$1 === void 0 ? void 0 : v$1), rej);
				ac.signal.addEventListener("abort", () => {
					if (!options.ignoreFetchAbort || options.allowStaleOnFetchAbort) {
						res(void 0);
						if (options.allowStaleOnFetchAbort) res = (v$1) => cb(v$1, true);
					}
				});
			};
			if (options.status) options.status.fetchDispatched = true;
			const p = new Promise(pcall).then(cb, eb);
			const bf = Object.assign(p, {
				__abortController: ac,
				__staleWhileFetching: v,
				__returned: void 0
			});
			if (index === void 0) {
				this.set(k, bf, {
					...fetchOpts.options,
					status: void 0
				});
				index = this.#keyMap.get(k);
			} else this.#valList[index] = bf;
			return bf;
		}
		#isBackgroundFetch(p) {
			if (!this.#hasFetchMethod) return false;
			const b = p;
			return !!b && b instanceof Promise && b.hasOwnProperty("__staleWhileFetching") && b.__abortController instanceof AC;
		}
		async fetch(k, fetchOptions = {}) {
			const { allowStale = this.allowStale, updateAgeOnGet = this.updateAgeOnGet, noDeleteOnStaleGet = this.noDeleteOnStaleGet, ttl = this.ttl, noDisposeOnSet = this.noDisposeOnSet, size = 0, sizeCalculation = this.sizeCalculation, noUpdateTTL = this.noUpdateTTL, noDeleteOnFetchRejection = this.noDeleteOnFetchRejection, allowStaleOnFetchRejection = this.allowStaleOnFetchRejection, ignoreFetchAbort = this.ignoreFetchAbort, allowStaleOnFetchAbort = this.allowStaleOnFetchAbort, context, forceRefresh = false, status, signal } = fetchOptions;
			if (!this.#hasFetchMethod) {
				if (status) status.fetch = "get";
				return this.get(k, {
					allowStale,
					updateAgeOnGet,
					noDeleteOnStaleGet,
					status
				});
			}
			const options = {
				allowStale,
				updateAgeOnGet,
				noDeleteOnStaleGet,
				ttl,
				noDisposeOnSet,
				size,
				sizeCalculation,
				noUpdateTTL,
				noDeleteOnFetchRejection,
				allowStaleOnFetchRejection,
				allowStaleOnFetchAbort,
				ignoreFetchAbort,
				status,
				signal
			};
			let index = this.#keyMap.get(k);
			if (index === void 0) {
				if (status) status.fetch = "miss";
				const p = this.#backgroundFetch(k, index, options, context);
				return p.__returned = p;
			} else {
				const v = this.#valList[index];
				if (this.#isBackgroundFetch(v)) {
					const stale = allowStale && v.__staleWhileFetching !== void 0;
					if (status) {
						status.fetch = "inflight";
						if (stale) status.returnedStale = true;
					}
					return stale ? v.__staleWhileFetching : v.__returned = v;
				}
				const isStale = this.#isStale(index);
				if (!forceRefresh && !isStale) {
					if (status) status.fetch = "hit";
					this.#moveToTail(index);
					if (updateAgeOnGet) this.#updateItemAge(index);
					if (status) this.#statusTTL(status, index);
					return v;
				}
				const p = this.#backgroundFetch(k, index, options, context);
				const staleVal = p.__staleWhileFetching !== void 0 && allowStale;
				if (status) {
					status.fetch = isStale ? "stale" : "refresh";
					if (staleVal && isStale) status.returnedStale = true;
				}
				return staleVal ? p.__staleWhileFetching : p.__returned = p;
			}
		}
		async forceFetch(k, fetchOptions = {}) {
			const v = await this.fetch(k, fetchOptions);
			if (v === void 0) throw new Error("fetch() returned undefined");
			return v;
		}
		memo(k, memoOptions = {}) {
			const memoMethod = this.#memoMethod;
			if (!memoMethod) throw new Error("no memoMethod provided to constructor");
			const { context, forceRefresh,...options } = memoOptions;
			const v = this.get(k, options);
			if (!forceRefresh && v !== void 0) return v;
			const vv = memoMethod(k, v, {
				options,
				context
			});
			this.set(k, vv, options);
			return vv;
		}
		get(k, getOptions$1 = {}) {
			const { allowStale = this.allowStale, updateAgeOnGet = this.updateAgeOnGet, noDeleteOnStaleGet = this.noDeleteOnStaleGet, status } = getOptions$1;
			const index = this.#keyMap.get(k);
			if (index !== void 0) {
				const value = this.#valList[index];
				const fetching = this.#isBackgroundFetch(value);
				if (status) this.#statusTTL(status, index);
				if (this.#isStale(index)) {
					if (status) status.get = "stale";
					if (!fetching) {
						if (!noDeleteOnStaleGet) this.#delete(k, "expire");
						if (status && allowStale) status.returnedStale = true;
						return allowStale ? value : void 0;
					} else {
						if (status && allowStale && value.__staleWhileFetching !== void 0) status.returnedStale = true;
						return allowStale ? value.__staleWhileFetching : void 0;
					}
				} else {
					if (status) status.get = "hit";
					if (fetching) return value.__staleWhileFetching;
					this.#moveToTail(index);
					if (updateAgeOnGet) this.#updateItemAge(index);
					return value;
				}
			} else if (status) status.get = "miss";
		}
		#connect(p, n) {
			this.#prev[n] = p;
			this.#next[p] = n;
		}
		#moveToTail(index) {
			if (index !== this.#tail) {
				if (index === this.#head) this.#head = this.#next[index];
				else this.#connect(this.#prev[index], this.#next[index]);
				this.#connect(this.#tail, index);
				this.#tail = index;
			}
		}
		delete(k) {
			return this.#delete(k, "delete");
		}
		#delete(k, reason) {
			let deleted = false;
			if (this.#size !== 0) {
				const index = this.#keyMap.get(k);
				if (index !== void 0) {
					deleted = true;
					if (this.#size === 1) this.#clear(reason);
					else {
						this.#removeItemSize(index);
						const v = this.#valList[index];
						if (this.#isBackgroundFetch(v)) v.__abortController.abort(/* @__PURE__ */ new Error("deleted"));
						else if (this.#hasDispose || this.#hasDisposeAfter) {
							if (this.#hasDispose) this.#dispose?.(v, k, reason);
							if (this.#hasDisposeAfter) this.#disposed?.push([
								v,
								k,
								reason
							]);
						}
						this.#keyMap.delete(k);
						this.#keyList[index] = void 0;
						this.#valList[index] = void 0;
						if (index === this.#tail) this.#tail = this.#prev[index];
						else if (index === this.#head) this.#head = this.#next[index];
						else {
							const pi = this.#prev[index];
							this.#next[pi] = this.#next[index];
							const ni = this.#next[index];
							this.#prev[ni] = this.#prev[index];
						}
						this.#size--;
						this.#free.push(index);
					}
				}
			}
			if (this.#hasDisposeAfter && this.#disposed?.length) {
				const dt = this.#disposed;
				let task;
				while (task = dt?.shift()) this.#disposeAfter?.(...task);
			}
			return deleted;
		}
		clear() {
			return this.#clear("delete");
		}
		#clear(reason) {
			for (const index of this.#rindexes({ allowStale: true })) {
				const v = this.#valList[index];
				if (this.#isBackgroundFetch(v)) v.__abortController.abort(/* @__PURE__ */ new Error("deleted"));
				else {
					const k = this.#keyList[index];
					if (this.#hasDispose) this.#dispose?.(v, k, reason);
					if (this.#hasDisposeAfter) this.#disposed?.push([
						v,
						k,
						reason
					]);
				}
			}
			this.#keyMap.clear();
			this.#valList.fill(void 0);
			this.#keyList.fill(void 0);
			if (this.#ttls && this.#starts) {
				this.#ttls.fill(0);
				this.#starts.fill(0);
			}
			if (this.#sizes) this.#sizes.fill(0);
			this.#head = 0;
			this.#tail = 0;
			this.#free.length = 0;
			this.#calculatedSize = 0;
			this.#size = 0;
			if (this.#hasDisposeAfter && this.#disposed) {
				const dt = this.#disposed;
				let task;
				while (task = dt?.shift()) this.#disposeAfter?.(...task);
			}
		}
	}
	commonjs$1.LRUCache = LRUCache;
	return commonjs$1;
}
var hosts_1$1;
var hasRequiredHosts$1;
function requireHosts$1() {
	if (hasRequiredHosts$1) return hosts_1$1;
	hasRequiredHosts$1 = 1;
	const maybeJoin = (...args) => args.every((arg) => arg) ? args.join("") : "";
	const maybeEncode = (arg) => arg ? encodeURIComponent(arg) : "";
	const formatHashFragment = (f) => f.toLowerCase().replace(/^\W+|\/|\W+$/g, "").replace(/\W+/g, "-");
	const defaults = {
		sshtemplate: ({ domain, user, project, committish }) => `git@${domain}:${user}/${project}.git${maybeJoin("#", committish)}`,
		sshurltemplate: ({ domain, user, project, committish }) => `git+ssh://git@${domain}/${user}/${project}.git${maybeJoin("#", committish)}`,
		edittemplate: ({ domain, user, project, committish, editpath, path: path$1 }) => `https://${domain}/${user}/${project}${maybeJoin("/", editpath, "/", maybeEncode(committish || "HEAD"), "/", path$1)}`,
		browsetemplate: ({ domain, user, project, committish, treepath }) => `https://${domain}/${user}/${project}${maybeJoin("/", treepath, "/", maybeEncode(committish))}`,
		browsetreetemplate: ({ domain, user, project, committish, treepath, path: path$1, fragment, hashformat }) => `https://${domain}/${user}/${project}/${treepath}/${maybeEncode(committish || "HEAD")}/${path$1}${maybeJoin("#", hashformat(fragment || ""))}`,
		browseblobtemplate: ({ domain, user, project, committish, blobpath, path: path$1, fragment, hashformat }) => `https://${domain}/${user}/${project}/${blobpath}/${maybeEncode(committish || "HEAD")}/${path$1}${maybeJoin("#", hashformat(fragment || ""))}`,
		docstemplate: ({ domain, user, project, treepath, committish }) => `https://${domain}/${user}/${project}${maybeJoin("/", treepath, "/", maybeEncode(committish))}#readme`,
		httpstemplate: ({ auth, domain, user, project, committish }) => `git+https://${maybeJoin(auth, "@")}${domain}/${user}/${project}.git${maybeJoin("#", committish)}`,
		filetemplate: ({ domain, user, project, committish, path: path$1 }) => `https://${domain}/${user}/${project}/raw/${maybeEncode(committish || "HEAD")}/${path$1}`,
		shortcuttemplate: ({ type, user, project, committish }) => `${type}:${user}/${project}${maybeJoin("#", committish)}`,
		pathtemplate: ({ user, project, committish }) => `${user}/${project}${maybeJoin("#", committish)}`,
		bugstemplate: ({ domain, user, project }) => `https://${domain}/${user}/${project}/issues`,
		hashformat: formatHashFragment
	};
	const hosts = {};
	hosts.github = {
		protocols: [
			"git:",
			"http:",
			"git+ssh:",
			"git+https:",
			"ssh:",
			"https:"
		],
		domain: "github.com",
		treepath: "tree",
		blobpath: "blob",
		editpath: "edit",
		filetemplate: ({ auth, user, project, committish, path: path$1 }) => `https://${maybeJoin(auth, "@")}raw.githubusercontent.com/${user}/${project}/${maybeEncode(committish || "HEAD")}/${path$1}`,
		gittemplate: ({ auth, domain, user, project, committish }) => `git://${maybeJoin(auth, "@")}${domain}/${user}/${project}.git${maybeJoin("#", committish)}`,
		tarballtemplate: ({ domain, user, project, committish }) => `https://codeload.${domain}/${user}/${project}/tar.gz/${maybeEncode(committish || "HEAD")}`,
		extract: (url) => {
			let [, user, project, type, committish] = url.pathname.split("/", 5);
			if (type && type !== "tree") return;
			if (!type) committish = url.hash.slice(1);
			if (project && project.endsWith(".git")) project = project.slice(0, -4);
			if (!user || !project) return;
			return {
				user,
				project,
				committish
			};
		}
	};
	hosts.bitbucket = {
		protocols: [
			"git+ssh:",
			"git+https:",
			"ssh:",
			"https:"
		],
		domain: "bitbucket.org",
		treepath: "src",
		blobpath: "src",
		editpath: "?mode=edit",
		edittemplate: ({ domain, user, project, committish, treepath, path: path$1, editpath }) => `https://${domain}/${user}/${project}${maybeJoin("/", treepath, "/", maybeEncode(committish || "HEAD"), "/", path$1, editpath)}`,
		tarballtemplate: ({ domain, user, project, committish }) => `https://${domain}/${user}/${project}/get/${maybeEncode(committish || "HEAD")}.tar.gz`,
		extract: (url) => {
			let [, user, project, aux] = url.pathname.split("/", 4);
			if (["get"].includes(aux)) return;
			if (project && project.endsWith(".git")) project = project.slice(0, -4);
			if (!user || !project) return;
			return {
				user,
				project,
				committish: url.hash.slice(1)
			};
		}
	};
	hosts.gitlab = {
		protocols: [
			"git+ssh:",
			"git+https:",
			"ssh:",
			"https:"
		],
		domain: "gitlab.com",
		treepath: "tree",
		blobpath: "tree",
		editpath: "-/edit",
		httpstemplate: ({ auth, domain, user, project, committish }) => `git+https://${maybeJoin(auth, "@")}${domain}/${user}/${project}.git${maybeJoin("#", committish)}`,
		tarballtemplate: ({ domain, user, project, committish }) => `https://${domain}/${user}/${project}/repository/archive.tar.gz?ref=${maybeEncode(committish || "HEAD")}`,
		extract: (url) => {
			const path$1 = url.pathname.slice(1);
			if (path$1.includes("/-/") || path$1.includes("/archive.tar.gz")) return;
			const segments = path$1.split("/");
			let project = segments.pop();
			if (project.endsWith(".git")) project = project.slice(0, -4);
			const user = segments.join("/");
			if (!user || !project) return;
			return {
				user,
				project,
				committish: url.hash.slice(1)
			};
		}
	};
	hosts.gist = {
		protocols: [
			"git:",
			"git+ssh:",
			"git+https:",
			"ssh:",
			"https:"
		],
		domain: "gist.github.com",
		editpath: "edit",
		sshtemplate: ({ domain, project, committish }) => `git@${domain}:${project}.git${maybeJoin("#", committish)}`,
		sshurltemplate: ({ domain, project, committish }) => `git+ssh://git@${domain}/${project}.git${maybeJoin("#", committish)}`,
		edittemplate: ({ domain, user, project, committish, editpath }) => `https://${domain}/${user}/${project}${maybeJoin("/", maybeEncode(committish))}/${editpath}`,
		browsetemplate: ({ domain, project, committish }) => `https://${domain}/${project}${maybeJoin("/", maybeEncode(committish))}`,
		browsetreetemplate: ({ domain, project, committish, path: path$1, hashformat }) => `https://${domain}/${project}${maybeJoin("/", maybeEncode(committish))}${maybeJoin("#", hashformat(path$1))}`,
		browseblobtemplate: ({ domain, project, committish, path: path$1, hashformat }) => `https://${domain}/${project}${maybeJoin("/", maybeEncode(committish))}${maybeJoin("#", hashformat(path$1))}`,
		docstemplate: ({ domain, project, committish }) => `https://${domain}/${project}${maybeJoin("/", maybeEncode(committish))}`,
		httpstemplate: ({ domain, project, committish }) => `git+https://${domain}/${project}.git${maybeJoin("#", committish)}`,
		filetemplate: ({ user, project, committish, path: path$1 }) => `https://gist.githubusercontent.com/${user}/${project}/raw${maybeJoin("/", maybeEncode(committish))}/${path$1}`,
		shortcuttemplate: ({ type, project, committish }) => `${type}:${project}${maybeJoin("#", committish)}`,
		pathtemplate: ({ project, committish }) => `${project}${maybeJoin("#", committish)}`,
		bugstemplate: ({ domain, project }) => `https://${domain}/${project}`,
		gittemplate: ({ domain, project, committish }) => `git://${domain}/${project}.git${maybeJoin("#", committish)}`,
		tarballtemplate: ({ project, committish }) => `https://codeload.github.com/gist/${project}/tar.gz/${maybeEncode(committish || "HEAD")}`,
		extract: (url) => {
			let [, user, project, aux] = url.pathname.split("/", 4);
			if (aux === "raw") return;
			if (!project) {
				if (!user) return;
				project = user;
				user = null;
			}
			if (project.endsWith(".git")) project = project.slice(0, -4);
			return {
				user,
				project,
				committish: url.hash.slice(1)
			};
		},
		hashformat: function(fragment) {
			return fragment && "file-" + formatHashFragment(fragment);
		}
	};
	hosts.sourcehut = {
		protocols: ["git+ssh:", "https:"],
		domain: "git.sr.ht",
		treepath: "tree",
		blobpath: "tree",
		filetemplate: ({ domain, user, project, committish, path: path$1 }) => `https://${domain}/${user}/${project}/blob/${maybeEncode(committish) || "HEAD"}/${path$1}`,
		httpstemplate: ({ domain, user, project, committish }) => `https://${domain}/${user}/${project}.git${maybeJoin("#", committish)}`,
		tarballtemplate: ({ domain, user, project, committish }) => `https://${domain}/${user}/${project}/archive/${maybeEncode(committish) || "HEAD"}.tar.gz`,
		bugstemplate: () => null,
		extract: (url) => {
			let [, user, project, aux] = url.pathname.split("/", 4);
			if (["archive"].includes(aux)) return;
			if (project && project.endsWith(".git")) project = project.slice(0, -4);
			if (!user || !project) return;
			return {
				user,
				project,
				committish: url.hash.slice(1)
			};
		}
	};
	for (const [name, host] of Object.entries(hosts)) hosts[name] = Object.assign({}, defaults, host);
	hosts_1$1 = hosts;
	return hosts_1$1;
}
var parseUrl$1;
var hasRequiredParseUrl$1;
function requireParseUrl$1() {
	if (hasRequiredParseUrl$1) return parseUrl$1;
	hasRequiredParseUrl$1 = 1;
	const url = require$$0;
	const lastIndexOfBefore = (str, char, beforeChar) => {
		const startPosition = str.indexOf(beforeChar);
		return str.lastIndexOf(char, startPosition > -1 ? startPosition : Infinity);
	};
	const safeUrl = (u) => {
		try {
			return new url.URL(u);
		} catch {}
	};
	const correctProtocol = (arg, protocols) => {
		const firstColon = arg.indexOf(":");
		const proto$1 = arg.slice(0, firstColon + 1);
		if (Object.prototype.hasOwnProperty.call(protocols, proto$1)) return arg;
		const firstAt = arg.indexOf("@");
		if (firstAt > -1) if (firstAt > firstColon) return `git+ssh://${arg}`;
		else return arg;
		if (arg.indexOf("//") === firstColon + 1) return arg;
		return `${arg.slice(0, firstColon + 1)}//${arg.slice(firstColon + 1)}`;
	};
	const correctUrl = (giturl) => {
		const firstAt = lastIndexOfBefore(giturl, "@", "#");
		const lastColonBeforeHash = lastIndexOfBefore(giturl, ":", "#");
		if (lastColonBeforeHash > firstAt) giturl = giturl.slice(0, lastColonBeforeHash) + "/" + giturl.slice(lastColonBeforeHash + 1);
		if (lastIndexOfBefore(giturl, ":", "#") === -1 && giturl.indexOf("//") === -1) giturl = `git+ssh://${giturl}`;
		return giturl;
	};
	parseUrl$1 = (giturl, protocols) => {
		const withProtocol = protocols ? correctProtocol(giturl, protocols) : giturl;
		return safeUrl(withProtocol) || safeUrl(correctUrl(withProtocol));
	};
	return parseUrl$1;
}
var fromUrl$1;
var hasRequiredFromUrl$1;
function requireFromUrl$1() {
	if (hasRequiredFromUrl$1) return fromUrl$1;
	hasRequiredFromUrl$1 = 1;
	const parseUrl$2 = requireParseUrl$1();
	const isGitHubShorthand = (arg) => {
		const firstHash = arg.indexOf("#");
		const firstSlash = arg.indexOf("/");
		const secondSlash = arg.indexOf("/", firstSlash + 1);
		const firstColon = arg.indexOf(":");
		const firstSpace = /\s/.exec(arg);
		const firstAt = arg.indexOf("@");
		const spaceOnlyAfterHash = !firstSpace || firstHash > -1 && firstSpace.index > firstHash;
		const atOnlyAfterHash = firstAt === -1 || firstHash > -1 && firstAt > firstHash;
		const colonOnlyAfterHash = firstColon === -1 || firstHash > -1 && firstColon > firstHash;
		const secondSlashOnlyAfterHash = secondSlash === -1 || firstHash > -1 && secondSlash > firstHash;
		const hasSlash = firstSlash > 0;
		const doesNotEndWithSlash = firstHash > -1 ? arg[firstHash - 1] !== "/" : !arg.endsWith("/");
		const doesNotStartWithDot = !arg.startsWith(".");
		return spaceOnlyAfterHash && hasSlash && doesNotEndWithSlash && doesNotStartWithDot && atOnlyAfterHash && colonOnlyAfterHash && secondSlashOnlyAfterHash;
	};
	fromUrl$1 = (giturl, opts, { gitHosts, protocols }) => {
		if (!giturl) return;
		const parsed = parseUrl$2(isGitHubShorthand(giturl) ? `github:${giturl}` : giturl, protocols);
		if (!parsed) return;
		const gitHostShortcut = gitHosts.byShortcut[parsed.protocol];
		const gitHostDomain = gitHosts.byDomain[parsed.hostname.startsWith("www.") ? parsed.hostname.slice(4) : parsed.hostname];
		const gitHostName = gitHostShortcut || gitHostDomain;
		if (!gitHostName) return;
		const gitHostInfo = gitHosts[gitHostShortcut || gitHostDomain];
		let auth = null;
		if (protocols[parsed.protocol]?.auth && (parsed.username || parsed.password)) auth = `${parsed.username}${parsed.password ? ":" + parsed.password : ""}`;
		let committish = null;
		let user = null;
		let project = null;
		let defaultRepresentation = null;
		try {
			if (gitHostShortcut) {
				let pathname = parsed.pathname.startsWith("/") ? parsed.pathname.slice(1) : parsed.pathname;
				const firstAt = pathname.indexOf("@");
				if (firstAt > -1) pathname = pathname.slice(firstAt + 1);
				const lastSlash = pathname.lastIndexOf("/");
				if (lastSlash > -1) {
					user = decodeURIComponent(pathname.slice(0, lastSlash));
					if (!user) user = null;
					project = decodeURIComponent(pathname.slice(lastSlash + 1));
				} else project = decodeURIComponent(pathname);
				if (project.endsWith(".git")) project = project.slice(0, -4);
				if (parsed.hash) committish = decodeURIComponent(parsed.hash.slice(1));
				defaultRepresentation = "shortcut";
			} else {
				if (!gitHostInfo.protocols.includes(parsed.protocol)) return;
				const segments = gitHostInfo.extract(parsed);
				if (!segments) return;
				user = segments.user && decodeURIComponent(segments.user);
				project = decodeURIComponent(segments.project);
				committish = decodeURIComponent(segments.committish);
				defaultRepresentation = protocols[parsed.protocol]?.name || parsed.protocol.slice(0, -1);
			}
		} catch (err) {
			if (err instanceof URIError) return;
			else throw err;
		}
		return [
			gitHostName,
			user,
			auth,
			project,
			committish,
			defaultRepresentation,
			opts
		];
	};
	return fromUrl$1;
}
var lib$1;
var hasRequiredLib$1;
function requireLib$1() {
	if (hasRequiredLib$1) return lib$1;
	hasRequiredLib$1 = 1;
	const { LRUCache } = requireCommonjs$1();
	const hosts = requireHosts$1();
	const fromUrl$2 = requireFromUrl$1();
	const parseUrl$2 = requireParseUrl$1();
	const cache$4 = new LRUCache({ max: 1e3 });
	class GitHost {
		constructor(type, user, auth, project, committish, defaultRepresentation, opts = {}) {
			Object.assign(this, GitHost.#gitHosts[type], {
				type,
				user,
				auth,
				project,
				committish,
				default: defaultRepresentation,
				opts
			});
		}
		static #gitHosts = {
			byShortcut: {},
			byDomain: {}
		};
		static #protocols = {
			"git+ssh:": { name: "sshurl" },
			"ssh:": { name: "sshurl" },
			"git+https:": {
				name: "https",
				auth: true
			},
			"git:": { auth: true },
			"http:": { auth: true },
			"https:": { auth: true },
			"git+http:": { auth: true }
		};
		static addHost(name, host) {
			GitHost.#gitHosts[name] = host;
			GitHost.#gitHosts.byDomain[host.domain] = name;
			GitHost.#gitHosts.byShortcut[`${name}:`] = name;
			GitHost.#protocols[`${name}:`] = { name };
		}
		static fromUrl(giturl, opts) {
			if (typeof giturl !== "string") return;
			const key = giturl + JSON.stringify(opts || {});
			if (!cache$4.has(key)) {
				const hostArgs = fromUrl$2(giturl, opts, {
					gitHosts: GitHost.#gitHosts,
					protocols: GitHost.#protocols
				});
				cache$4.set(key, hostArgs ? new GitHost(...hostArgs) : void 0);
			}
			return cache$4.get(key);
		}
		static parseUrl(url) {
			return parseUrl$2(url);
		}
		#fill(template, opts) {
			if (typeof template !== "function") return null;
			const options = {
				...this,
				...this.opts,
				...opts
			};
			if (!options.path) options.path = "";
			if (options.path.startsWith("/")) options.path = options.path.slice(1);
			if (options.noCommittish) options.committish = null;
			const result = template(options);
			return options.noGitPlus && result.startsWith("git+") ? result.slice(4) : result;
		}
		hash() {
			return this.committish ? `#${this.committish}` : "";
		}
		ssh(opts) {
			return this.#fill(this.sshtemplate, opts);
		}
		sshurl(opts) {
			return this.#fill(this.sshurltemplate, opts);
		}
		browse(path$1, ...args) {
			if (typeof path$1 !== "string") return this.#fill(this.browsetemplate, path$1);
			if (typeof args[0] !== "string") return this.#fill(this.browsetreetemplate, {
				...args[0],
				path: path$1
			});
			return this.#fill(this.browsetreetemplate, {
				...args[1],
				fragment: args[0],
				path: path$1
			});
		}
		browseFile(path$1, ...args) {
			if (typeof args[0] !== "string") return this.#fill(this.browseblobtemplate, {
				...args[0],
				path: path$1
			});
			return this.#fill(this.browseblobtemplate, {
				...args[1],
				fragment: args[0],
				path: path$1
			});
		}
		docs(opts) {
			return this.#fill(this.docstemplate, opts);
		}
		bugs(opts) {
			return this.#fill(this.bugstemplate, opts);
		}
		https(opts) {
			return this.#fill(this.httpstemplate, opts);
		}
		git(opts) {
			return this.#fill(this.gittemplate, opts);
		}
		shortcut(opts) {
			return this.#fill(this.shortcuttemplate, opts);
		}
		path(opts) {
			return this.#fill(this.pathtemplate, opts);
		}
		tarball(opts) {
			return this.#fill(this.tarballtemplate, {
				...opts,
				noCommittish: false
			});
		}
		file(path$1, opts) {
			return this.#fill(this.filetemplate, {
				...opts,
				path: path$1
			});
		}
		edit(path$1, opts) {
			return this.#fill(this.edittemplate, {
				...opts,
				path: path$1
			});
		}
		getDefaultRepresentation() {
			return this.default;
		}
		toString(opts) {
			if (this.default && typeof this[this.default] === "function") return this[this.default](opts);
			return this.sshurl(opts);
		}
	}
	for (const [name, host] of Object.entries(hosts)) GitHost.addHost(name, host);
	lib$1 = GitHost;
	return lib$1;
}
var extract_description$1;
var hasRequiredExtract_description$1;
function requireExtract_description$1() {
	if (hasRequiredExtract_description$1) return extract_description$1;
	hasRequiredExtract_description$1 = 1;
	extract_description$1 = extractDescription;
	function extractDescription(d) {
		if (!d) return;
		if (d === "ERROR: No README data found!") return;
		d = d.trim().split("\n");
		let s = 0;
		while (d[s] && d[s].trim().match(/^(#|$)/)) s++;
		const l = d.length;
		let e = s + 1;
		while (e < l && d[e].trim()) e++;
		return d.slice(s, e).join(" ").trim();
	}
	return extract_description$1;
}
const require$$7$1 = {
	topLevel: {
		dependancies: "dependencies",
		dependecies: "dependencies",
		depdenencies: "dependencies",
		devEependencies: "devDependencies",
		depends: "dependencies",
		"dev-dependencies": "devDependencies",
		devDependences: "devDependencies",
		devDepenencies: "devDependencies",
		devdependencies: "devDependencies",
		repostitory: "repository",
		repo: "repository",
		prefereGlobal: "preferGlobal",
		hompage: "homepage",
		hampage: "homepage",
		autohr: "author",
		autor: "author",
		contributers: "contributors",
		publicationConfig: "publishConfig",
		script: "scripts"
	},
	bugs: {
		web: "url",
		name: "url"
	},
	script: {
		server: "start",
		tests: "test"
	}
};
var fixer$1;
var hasRequiredFixer$1;
function requireFixer$1() {
	if (hasRequiredFixer$1) return fixer$1;
	hasRequiredFixer$1 = 1;
	var isValidSemver = requireValid();
	var cleanSemver = requireClean();
	var validateLicense = requireValidateNpmPackageLicense();
	var hostedGitInfo = requireLib$1();
	var moduleBuiltin = require$$4;
	var depTypes = [
		"dependencies",
		"devDependencies",
		"optionalDependencies"
	];
	var extractDescription = requireExtract_description$1();
	var url = require$$0;
	var typos = require$$7$1;
	var isEmail = (str) => str.includes("@") && str.indexOf("@") < str.lastIndexOf(".");
	fixer$1 = {
		warn: function() {},
		fixRepositoryField: function(data) {
			if (data.repositories) {
				this.warn("repositories");
				data.repository = data.repositories[0];
			}
			if (!data.repository) return this.warn("missingRepository");
			if (typeof data.repository === "string") data.repository = {
				type: "git",
				url: data.repository
			};
			var r = data.repository.url || "";
			if (r) {
				var hosted = hostedGitInfo.fromUrl(r);
				if (hosted) r = data.repository.url = hosted.getDefaultRepresentation() === "shortcut" ? hosted.https() : hosted.toString();
			}
			if (r.match(/github.com\/[^/]+\/[^/]+\.git\.git$/)) this.warn("brokenGitUrl", r);
		},
		fixTypos: function(data) {
			Object.keys(typos.topLevel).forEach(function(d) {
				if (Object.prototype.hasOwnProperty.call(data, d)) this.warn("typo", d, typos.topLevel[d]);
			}, this);
		},
		fixScriptsField: function(data) {
			if (!data.scripts) return;
			if (typeof data.scripts !== "object") {
				this.warn("nonObjectScripts");
				delete data.scripts;
				return;
			}
			Object.keys(data.scripts).forEach(function(k) {
				if (typeof data.scripts[k] !== "string") {
					this.warn("nonStringScript");
					delete data.scripts[k];
				} else if (typos.script[k] && !data.scripts[typos.script[k]]) this.warn("typo", k, typos.script[k], "scripts");
			}, this);
		},
		fixFilesField: function(data) {
			var files = data.files;
			if (files && !Array.isArray(files)) {
				this.warn("nonArrayFiles");
				delete data.files;
			} else if (data.files) data.files = data.files.filter(function(file) {
				if (!file || typeof file !== "string") {
					this.warn("invalidFilename", file);
					return false;
				} else return true;
			}, this);
		},
		fixBinField: function(data) {
			if (!data.bin) return;
			if (typeof data.bin === "string") {
				var b = {};
				var match;
				if (match = data.name.match(/^@[^/]+[/](.*)$/)) b[match[1]] = data.bin;
				else b[data.name] = data.bin;
				data.bin = b;
			}
		},
		fixManField: function(data) {
			if (!data.man) return;
			if (typeof data.man === "string") data.man = [data.man];
		},
		fixBundleDependenciesField: function(data) {
			var bdd = "bundledDependencies";
			var bd = "bundleDependencies";
			if (data[bdd] && !data[bd]) {
				data[bd] = data[bdd];
				delete data[bdd];
			}
			if (data[bd] && !Array.isArray(data[bd])) {
				this.warn("nonArrayBundleDependencies");
				delete data[bd];
			} else if (data[bd]) data[bd] = data[bd].filter(function(filtered) {
				if (!filtered || typeof filtered !== "string") {
					this.warn("nonStringBundleDependency", filtered);
					return false;
				} else {
					if (!data.dependencies) data.dependencies = {};
					if (!Object.prototype.hasOwnProperty.call(data.dependencies, filtered)) {
						this.warn("nonDependencyBundleDependency", filtered);
						data.dependencies[filtered] = "*";
					}
					return true;
				}
			}, this);
		},
		fixDependencies: function(data) {
			objectifyDeps(data, this.warn);
			addOptionalDepsToDeps(data, this.warn);
			this.fixBundleDependenciesField(data);
			["dependencies", "devDependencies"].forEach(function(deps) {
				if (!(deps in data)) return;
				if (!data[deps] || typeof data[deps] !== "object") {
					this.warn("nonObjectDependencies", deps);
					delete data[deps];
					return;
				}
				Object.keys(data[deps]).forEach(function(d) {
					var r = data[deps][d];
					if (typeof r !== "string") {
						this.warn("nonStringDependency", d, JSON.stringify(r));
						delete data[deps][d];
					}
					var hosted = hostedGitInfo.fromUrl(data[deps][d]);
					if (hosted) data[deps][d] = hosted.toString();
				}, this);
			}, this);
		},
		fixModulesField: function(data) {
			if (data.modules) {
				this.warn("deprecatedModules");
				delete data.modules;
			}
		},
		fixKeywordsField: function(data) {
			if (typeof data.keywords === "string") data.keywords = data.keywords.split(/,\s+/);
			if (data.keywords && !Array.isArray(data.keywords)) {
				delete data.keywords;
				this.warn("nonArrayKeywords");
			} else if (data.keywords) data.keywords = data.keywords.filter(function(kw) {
				if (typeof kw !== "string" || !kw) {
					this.warn("nonStringKeyword");
					return false;
				} else return true;
			}, this);
		},
		fixVersionField: function(data, strict) {
			var loose = !strict;
			if (!data.version) {
				data.version = "";
				return true;
			}
			if (!isValidSemver(data.version, loose)) throw new Error("Invalid version: \"" + data.version + "\"");
			data.version = cleanSemver(data.version, loose);
			return true;
		},
		fixPeople: function(data) {
			modifyPeople(data, unParsePerson);
			modifyPeople(data, parsePerson);
		},
		fixNameField: function(data, options) {
			if (typeof options === "boolean") options = { strict: options };
			else if (typeof options === "undefined") options = {};
			var strict = options.strict;
			if (!data.name && !strict) {
				data.name = "";
				return;
			}
			if (typeof data.name !== "string") throw new Error("name field must be a string.");
			if (!strict) data.name = data.name.trim();
			ensureValidName(data.name, strict, options.allowLegacyCase);
			if (moduleBuiltin.builtinModules.includes(data.name)) this.warn("conflictingName", data.name);
		},
		fixDescriptionField: function(data) {
			if (data.description && typeof data.description !== "string") {
				this.warn("nonStringDescription");
				delete data.description;
			}
			if (data.readme && !data.description) data.description = extractDescription(data.readme);
			if (data.description === void 0) delete data.description;
			if (!data.description) this.warn("missingDescription");
		},
		fixReadmeField: function(data) {
			if (!data.readme) {
				this.warn("missingReadme");
				data.readme = "ERROR: No README data found!";
			}
		},
		fixBugsField: function(data) {
			if (!data.bugs && data.repository && data.repository.url) {
				var hosted = hostedGitInfo.fromUrl(data.repository.url);
				if (hosted && hosted.bugs()) data.bugs = { url: hosted.bugs() };
			} else if (data.bugs) {
				if (typeof data.bugs === "string") if (isEmail(data.bugs)) data.bugs = { email: data.bugs };
				else if (url.parse(data.bugs).protocol) data.bugs = { url: data.bugs };
				else this.warn("nonEmailUrlBugsString");
				else {
					bugsTypos(data.bugs, this.warn);
					var oldBugs = data.bugs;
					data.bugs = {};
					if (oldBugs.url) if (typeof oldBugs.url === "string" && url.parse(oldBugs.url).protocol) data.bugs.url = oldBugs.url;
					else this.warn("nonUrlBugsUrlField");
					if (oldBugs.email) if (typeof oldBugs.email === "string" && isEmail(oldBugs.email)) data.bugs.email = oldBugs.email;
					else this.warn("nonEmailBugsEmailField");
				}
				if (!data.bugs.email && !data.bugs.url) {
					delete data.bugs;
					this.warn("emptyNormalizedBugs");
				}
			}
		},
		fixHomepageField: function(data) {
			if (!data.homepage && data.repository && data.repository.url) {
				var hosted = hostedGitInfo.fromUrl(data.repository.url);
				if (hosted && hosted.docs()) data.homepage = hosted.docs();
			}
			if (!data.homepage) return;
			if (typeof data.homepage !== "string") {
				this.warn("nonUrlHomepage");
				return delete data.homepage;
			}
			if (!url.parse(data.homepage).protocol) data.homepage = "http://" + data.homepage;
		},
		fixLicenseField: function(data) {
			const license = data.license || data.licence;
			if (!license) return this.warn("missingLicense");
			if (typeof license !== "string" || license.length < 1 || license.trim() === "") return this.warn("invalidLicense");
			if (!validateLicense(license).validForNewPackages) return this.warn("invalidLicense");
		}
	};
	function isValidScopedPackageName(spec) {
		if (spec.charAt(0) !== "@") return false;
		var rest = spec.slice(1).split("/");
		if (rest.length !== 2) return false;
		return rest[0] && rest[1] && rest[0] === encodeURIComponent(rest[0]) && rest[1] === encodeURIComponent(rest[1]);
	}
	function isCorrectlyEncodedName(spec) {
		return !spec.match(/[/@\s+%:]/) && spec === encodeURIComponent(spec);
	}
	function ensureValidName(name, strict, allowLegacyCase) {
		if (name.charAt(0) === "." || !(isValidScopedPackageName(name) || isCorrectlyEncodedName(name)) || strict && !allowLegacyCase && name !== name.toLowerCase() || name.toLowerCase() === "node_modules" || name.toLowerCase() === "favicon.ico") throw new Error("Invalid name: " + JSON.stringify(name));
	}
	function modifyPeople(data, fn) {
		if (data.author) data.author = fn(data.author);
		["maintainers", "contributors"].forEach(function(set) {
			if (!Array.isArray(data[set])) return;
			data[set] = data[set].map(fn);
		});
		return data;
	}
	function unParsePerson(person) {
		if (typeof person === "string") return person;
		var name = person.name || "";
		var u = person.url || person.web;
		var wrappedUrl = u ? " (" + u + ")" : "";
		var e = person.email || person.mail;
		return name + (e ? " <" + e + ">" : "") + wrappedUrl;
	}
	function parsePerson(person) {
		if (typeof person !== "string") return person;
		var matchedName = person.match(/^([^(<]+)/);
		var matchedUrl = person.match(/\(([^()]+)\)/);
		var matchedEmail = person.match(/<([^<>]+)>/);
		var obj = {};
		if (matchedName && matchedName[0].trim()) obj.name = matchedName[0].trim();
		if (matchedEmail) obj.email = matchedEmail[1];
		if (matchedUrl) obj.url = matchedUrl[1];
		return obj;
	}
	function addOptionalDepsToDeps(data) {
		var o = data.optionalDependencies;
		if (!o) return;
		var d = data.dependencies || {};
		Object.keys(o).forEach(function(k) {
			d[k] = o[k];
		});
		data.dependencies = d;
	}
	function depObjectify(deps, type, warn) {
		if (!deps) return {};
		if (typeof deps === "string") deps = deps.trim().split(/[\n\r\s\t ,]+/);
		if (!Array.isArray(deps)) return deps;
		warn("deprecatedArrayDependencies", type);
		var o = {};
		deps.filter(function(d) {
			return typeof d === "string";
		}).forEach(function(d) {
			d = d.trim().split(/(:?[@\s><=])/);
			var dn = d.shift();
			var dv = d.join("");
			dv = dv.trim();
			dv = dv.replace(/^@/, "");
			o[dn] = dv;
		});
		return o;
	}
	function objectifyDeps(data, warn) {
		depTypes.forEach(function(type) {
			if (!data[type]) return;
			data[type] = depObjectify(data[type], type, warn);
		});
	}
	function bugsTypos(bugs, warn) {
		if (!bugs) return;
		Object.keys(bugs).forEach(function(k) {
			if (typos.bugs[k]) {
				warn("typo", k, typos.bugs[k], "bugs");
				bugs[typos.bugs[k]] = bugs[k];
				delete bugs[k];
			}
		});
	}
	return fixer$1;
}
const require$$1$1 = {
	repositories: "'repositories' (plural) Not supported. Please pick one as the 'repository' field",
	missingRepository: "No repository field.",
	brokenGitUrl: "Probably broken git url: %s",
	nonObjectScripts: "scripts must be an object",
	nonStringScript: "script values must be string commands",
	nonArrayFiles: "Invalid 'files' member",
	invalidFilename: "Invalid filename in 'files' list: %s",
	nonArrayBundleDependencies: "Invalid 'bundleDependencies' list. Must be array of package names",
	nonStringBundleDependency: "Invalid bundleDependencies member: %s",
	nonDependencyBundleDependency: "Non-dependency in bundleDependencies: %s",
	nonObjectDependencies: "%s field must be an object",
	nonStringDependency: "Invalid dependency: %s %s",
	deprecatedArrayDependencies: "specifying %s as array is deprecated",
	deprecatedModules: "modules field is deprecated",
	nonArrayKeywords: "keywords should be an array of strings",
	nonStringKeyword: "keywords should be an array of strings",
	conflictingName: "%s is also the name of a node core module.",
	nonStringDescription: "'description' field should be a string",
	missingDescription: "No description",
	missingReadme: "No README data",
	missingLicense: "No license field.",
	nonEmailUrlBugsString: "Bug string field must be url, email, or {email,url}",
	nonUrlBugsUrlField: "bugs.url field must be a string url. Deleted.",
	nonEmailBugsEmailField: "bugs.email field must be a string email. Deleted.",
	emptyNormalizedBugs: "Normalized value of bugs field is an empty object. Deleted.",
	nonUrlHomepage: "homepage field must be a string url. Deleted.",
	invalidLicense: "license should be a valid SPDX license expression",
	typo: "%s should probably be %s."
};
var make_warning$1;
var hasRequiredMake_warning$1;
function requireMake_warning$1() {
	if (hasRequiredMake_warning$1) return make_warning$1;
	hasRequiredMake_warning$1 = 1;
	var util = require$$0$1;
	var messages = require$$1$1;
	make_warning$1 = function() {
		var args = Array.prototype.slice.call(arguments, 0);
		var warningName = args.shift();
		if (warningName === "typo") return makeTypoWarning.apply(null, args);
		else {
			var msgTemplate = messages[warningName] ? messages[warningName] : warningName + ": '%s'";
			args.unshift(msgTemplate);
			return util.format.apply(null, args);
		}
	};
	function makeTypoWarning(providedName, probableName, field) {
		if (field) {
			providedName = field + "['" + providedName + "']";
			probableName = field + "['" + probableName + "']";
		}
		return util.format(messages.typo, providedName, probableName);
	}
	return make_warning$1;
}
var normalize_1$1;
var hasRequiredNormalize$1;
function requireNormalize$1() {
	if (hasRequiredNormalize$1) return normalize_1$1;
	hasRequiredNormalize$1 = 1;
	normalize_1$1 = normalize$1;
	var fixer$2 = requireFixer$1();
	normalize$1.fixer = fixer$2;
	var makeWarning = requireMake_warning$1();
	var fieldsToFix = [
		"name",
		"version",
		"description",
		"repository",
		"modules",
		"scripts",
		"files",
		"bin",
		"man",
		"bugs",
		"keywords",
		"readme",
		"homepage",
		"license"
	];
	var otherThingsToFix = [
		"dependencies",
		"people",
		"typos"
	];
	var thingsToFix = fieldsToFix.map(function(fieldName) {
		return ucFirst(fieldName) + "Field";
	});
	thingsToFix = thingsToFix.concat(otherThingsToFix);
	function normalize$1(data, warn, strict) {
		if (warn === true) {
			warn = null;
			strict = true;
		}
		if (!strict) strict = false;
		if (!warn || data.private) warn = function() {};
		if (data.scripts && data.scripts.install === "node-gyp rebuild" && !data.scripts.preinstall) data.gypfile = true;
		fixer$2.warn = function() {
			warn(makeWarning.apply(null, arguments));
		};
		thingsToFix.forEach(function(thingName) {
			fixer$2["fix" + ucFirst(thingName)](data, strict);
		});
		data._id = data.name + "@" + data.version;
	}
	function ucFirst(string) {
		return string.charAt(0).toUpperCase() + string.slice(1);
	}
	return normalize_1$1;
}
const normalizePackageData$1 = getDefaultExportFromCjs(requireNormalize$1());
function toPath(urlOrPath) {
	return urlOrPath instanceof URL ? fileURLToPath(urlOrPath) : urlOrPath;
}
const getPackagePath = (cwd$2) => path.resolve(toPath(cwd$2) ?? ".", "package.json");
const _readPackage = (file, normalize$1) => {
	const json = typeof file === "string" ? parseJson(file) : file;
	if (normalize$1) normalizePackageData$1(json);
	return json;
};
function readPackageSync({ cwd: cwd$2, normalize: normalize$1 = true } = {}) {
	return _readPackage(fs.readFileSync(getPackagePath(cwd$2), "utf8"), normalize$1);
}
function readPackageUpSync(options) {
	const filePath = findUpSync("package.json", options);
	if (!filePath) return;
	return {
		packageJson: readPackageSync({
			...options,
			cwd: path.dirname(filePath)
		}),
		path: filePath
	};
}
var commonjs = {};
var hasRequiredCommonjs;
function requireCommonjs() {
	if (hasRequiredCommonjs) return commonjs;
	hasRequiredCommonjs = 1;
	Object.defineProperty(commonjs, "__esModule", { value: true });
	commonjs.LRUCache = void 0;
	const defaultPerf = typeof performance === "object" && performance && typeof performance.now === "function" ? performance : Date;
	const warned = /* @__PURE__ */ new Set();
	const PROCESS = typeof process === "object" && !!process ? process : {};
	const emitWarning = (msg, type, code, fn) => {
		typeof PROCESS.emitWarning === "function" ? PROCESS.emitWarning(msg, type, code, fn) : console.error(`[${code}] ${type}: ${msg}`);
	};
	let AC = globalThis.AbortController;
	let AS = globalThis.AbortSignal;
	if (typeof AC === "undefined") {
		AS = class AbortSignal {
			onabort;
			_onabort = [];
			reason;
			aborted = false;
			addEventListener(_, fn) {
				this._onabort.push(fn);
			}
		};
		AC = class AbortController$1 {
			constructor() {
				warnACPolyfill();
			}
			signal = new AS();
			abort(reason) {
				if (this.signal.aborted) return;
				this.signal.reason = reason;
				this.signal.aborted = true;
				for (const fn of this.signal._onabort) fn(reason);
				this.signal.onabort?.(reason);
			}
		};
		let printACPolyfillWarning = PROCESS.env?.LRU_CACHE_IGNORE_AC_WARNING !== "1";
		const warnACPolyfill = () => {
			if (!printACPolyfillWarning) return;
			printACPolyfillWarning = false;
			emitWarning("AbortController is not defined. If using lru-cache in node 14, load an AbortController polyfill from the `node-abort-controller` package. A minimal polyfill is provided for use by LRUCache.fetch(), but it should not be relied upon in other contexts (eg, passing it to other APIs that use AbortController/AbortSignal might have undesirable effects). You may disable this with LRU_CACHE_IGNORE_AC_WARNING=1 in the env.", "NO_ABORT_CONTROLLER", "ENOTSUP", warnACPolyfill);
		};
	}
	const shouldWarn = (code) => !warned.has(code);
	const isPosInt = (n) => n && n === Math.floor(n) && n > 0 && isFinite(n);
	const getUintArray = (max) => !isPosInt(max) ? null : max <= Math.pow(2, 8) ? Uint8Array : max <= Math.pow(2, 16) ? Uint16Array : max <= Math.pow(2, 32) ? Uint32Array : max <= Number.MAX_SAFE_INTEGER ? ZeroArray : null;
	class ZeroArray extends Array {
		constructor(size) {
			super(size);
			this.fill(0);
		}
	}
	class Stack {
		heap;
		length;
		static #constructing = false;
		static create(max) {
			const HeapCls = getUintArray(max);
			if (!HeapCls) return [];
			Stack.#constructing = true;
			const s = new Stack(max, HeapCls);
			Stack.#constructing = false;
			return s;
		}
		constructor(max, HeapCls) {
			if (!Stack.#constructing) throw new TypeError("instantiate Stack using Stack.create(n)");
			this.heap = new HeapCls(max);
			this.length = 0;
		}
		push(n) {
			this.heap[this.length++] = n;
		}
		pop() {
			return this.heap[--this.length];
		}
	}
	class LRUCache {
		#max;
		#maxSize;
		#dispose;
		#onInsert;
		#disposeAfter;
		#fetchMethod;
		#memoMethod;
		#perf;
		get perf() {
			return this.#perf;
		}
		ttl;
		ttlResolution;
		ttlAutopurge;
		updateAgeOnGet;
		updateAgeOnHas;
		allowStale;
		noDisposeOnSet;
		noUpdateTTL;
		maxEntrySize;
		sizeCalculation;
		noDeleteOnFetchRejection;
		noDeleteOnStaleGet;
		allowStaleOnFetchAbort;
		allowStaleOnFetchRejection;
		ignoreFetchAbort;
		#size;
		#calculatedSize;
		#keyMap;
		#keyList;
		#valList;
		#next;
		#prev;
		#head;
		#tail;
		#free;
		#disposed;
		#sizes;
		#starts;
		#ttls;
		#hasDispose;
		#hasFetchMethod;
		#hasDisposeAfter;
		#hasOnInsert;
		static unsafeExposeInternals(c) {
			return {
				starts: c.#starts,
				ttls: c.#ttls,
				sizes: c.#sizes,
				keyMap: c.#keyMap,
				keyList: c.#keyList,
				valList: c.#valList,
				next: c.#next,
				prev: c.#prev,
				get head() {
					return c.#head;
				},
				get tail() {
					return c.#tail;
				},
				free: c.#free,
				isBackgroundFetch: (p) => c.#isBackgroundFetch(p),
				backgroundFetch: (k, index, options, context) => c.#backgroundFetch(k, index, options, context),
				moveToTail: (index) => c.#moveToTail(index),
				indexes: (options) => c.#indexes(options),
				rindexes: (options) => c.#rindexes(options),
				isStale: (index) => c.#isStale(index)
			};
		}
		get max() {
			return this.#max;
		}
		get maxSize() {
			return this.#maxSize;
		}
		get calculatedSize() {
			return this.#calculatedSize;
		}
		get size() {
			return this.#size;
		}
		get fetchMethod() {
			return this.#fetchMethod;
		}
		get memoMethod() {
			return this.#memoMethod;
		}
		get dispose() {
			return this.#dispose;
		}
		get onInsert() {
			return this.#onInsert;
		}
		get disposeAfter() {
			return this.#disposeAfter;
		}
		constructor(options) {
			const { max = 0, ttl, ttlResolution = 1, ttlAutopurge, updateAgeOnGet, updateAgeOnHas, allowStale, dispose, onInsert, disposeAfter, noDisposeOnSet, noUpdateTTL, maxSize = 0, maxEntrySize = 0, sizeCalculation, fetchMethod, memoMethod, noDeleteOnFetchRejection, noDeleteOnStaleGet, allowStaleOnFetchRejection, allowStaleOnFetchAbort, ignoreFetchAbort, perf } = options;
			if (perf !== void 0) {
				if (typeof perf?.now !== "function") throw new TypeError("perf option must have a now() method if specified");
			}
			this.#perf = perf ?? defaultPerf;
			if (max !== 0 && !isPosInt(max)) throw new TypeError("max option must be a nonnegative integer");
			const UintArray = max ? getUintArray(max) : Array;
			if (!UintArray) throw new Error("invalid max value: " + max);
			this.#max = max;
			this.#maxSize = maxSize;
			this.maxEntrySize = maxEntrySize || this.#maxSize;
			this.sizeCalculation = sizeCalculation;
			if (this.sizeCalculation) {
				if (!this.#maxSize && !this.maxEntrySize) throw new TypeError("cannot set sizeCalculation without setting maxSize or maxEntrySize");
				if (typeof this.sizeCalculation !== "function") throw new TypeError("sizeCalculation set to non-function");
			}
			if (memoMethod !== void 0 && typeof memoMethod !== "function") throw new TypeError("memoMethod must be a function if defined");
			this.#memoMethod = memoMethod;
			if (fetchMethod !== void 0 && typeof fetchMethod !== "function") throw new TypeError("fetchMethod must be a function if specified");
			this.#fetchMethod = fetchMethod;
			this.#hasFetchMethod = !!fetchMethod;
			this.#keyMap = /* @__PURE__ */ new Map();
			this.#keyList = new Array(max).fill(void 0);
			this.#valList = new Array(max).fill(void 0);
			this.#next = new UintArray(max);
			this.#prev = new UintArray(max);
			this.#head = 0;
			this.#tail = 0;
			this.#free = Stack.create(max);
			this.#size = 0;
			this.#calculatedSize = 0;
			if (typeof dispose === "function") this.#dispose = dispose;
			if (typeof onInsert === "function") this.#onInsert = onInsert;
			if (typeof disposeAfter === "function") {
				this.#disposeAfter = disposeAfter;
				this.#disposed = [];
			} else {
				this.#disposeAfter = void 0;
				this.#disposed = void 0;
			}
			this.#hasDispose = !!this.#dispose;
			this.#hasOnInsert = !!this.#onInsert;
			this.#hasDisposeAfter = !!this.#disposeAfter;
			this.noDisposeOnSet = !!noDisposeOnSet;
			this.noUpdateTTL = !!noUpdateTTL;
			this.noDeleteOnFetchRejection = !!noDeleteOnFetchRejection;
			this.allowStaleOnFetchRejection = !!allowStaleOnFetchRejection;
			this.allowStaleOnFetchAbort = !!allowStaleOnFetchAbort;
			this.ignoreFetchAbort = !!ignoreFetchAbort;
			if (this.maxEntrySize !== 0) {
				if (this.#maxSize !== 0) {
					if (!isPosInt(this.#maxSize)) throw new TypeError("maxSize must be a positive integer if specified");
				}
				if (!isPosInt(this.maxEntrySize)) throw new TypeError("maxEntrySize must be a positive integer if specified");
				this.#initializeSizeTracking();
			}
			this.allowStale = !!allowStale;
			this.noDeleteOnStaleGet = !!noDeleteOnStaleGet;
			this.updateAgeOnGet = !!updateAgeOnGet;
			this.updateAgeOnHas = !!updateAgeOnHas;
			this.ttlResolution = isPosInt(ttlResolution) || ttlResolution === 0 ? ttlResolution : 1;
			this.ttlAutopurge = !!ttlAutopurge;
			this.ttl = ttl || 0;
			if (this.ttl) {
				if (!isPosInt(this.ttl)) throw new TypeError("ttl must be a positive integer if specified");
				this.#initializeTTLTracking();
			}
			if (this.#max === 0 && this.ttl === 0 && this.#maxSize === 0) throw new TypeError("At least one of max, maxSize, or ttl is required");
			if (!this.ttlAutopurge && !this.#max && !this.#maxSize) {
				const code = "LRU_CACHE_UNBOUNDED";
				if (shouldWarn(code)) {
					warned.add(code);
					emitWarning("TTL caching without ttlAutopurge, max, or maxSize can result in unbounded memory consumption.", "UnboundedCacheWarning", code, LRUCache);
				}
			}
		}
		getRemainingTTL(key) {
			return this.#keyMap.has(key) ? Infinity : 0;
		}
		#initializeTTLTracking() {
			const ttls = new ZeroArray(this.#max);
			const starts = new ZeroArray(this.#max);
			this.#ttls = ttls;
			this.#starts = starts;
			this.#setItemTTL = (index, ttl, start = this.#perf.now()) => {
				starts[index] = ttl !== 0 ? start : 0;
				ttls[index] = ttl;
				if (ttl !== 0 && this.ttlAutopurge) {
					const t = setTimeout(() => {
						if (this.#isStale(index)) this.#delete(this.#keyList[index], "expire");
					}, ttl + 1);
					if (t.unref) t.unref();
				}
			};
			this.#updateItemAge = (index) => {
				starts[index] = ttls[index] !== 0 ? this.#perf.now() : 0;
			};
			this.#statusTTL = (status, index) => {
				if (ttls[index]) {
					const ttl = ttls[index];
					const start = starts[index];
					if (!ttl || !start) return;
					status.ttl = ttl;
					status.start = start;
					status.now = cachedNow || getNow();
					status.remainingTTL = ttl - (status.now - start);
				}
			};
			let cachedNow = 0;
			const getNow = () => {
				const n = this.#perf.now();
				if (this.ttlResolution > 0) {
					cachedNow = n;
					const t = setTimeout(() => cachedNow = 0, this.ttlResolution);
					if (t.unref) t.unref();
				}
				return n;
			};
			this.getRemainingTTL = (key) => {
				const index = this.#keyMap.get(key);
				if (index === void 0) return 0;
				const ttl = ttls[index];
				const start = starts[index];
				if (!ttl || !start) return Infinity;
				return ttl - ((cachedNow || getNow()) - start);
			};
			this.#isStale = (index) => {
				const s = starts[index];
				const t = ttls[index];
				return !!t && !!s && (cachedNow || getNow()) - s > t;
			};
		}
		#updateItemAge = () => {};
		#statusTTL = () => {};
		#setItemTTL = () => {};
		#isStale = () => false;
		#initializeSizeTracking() {
			const sizes = new ZeroArray(this.#max);
			this.#calculatedSize = 0;
			this.#sizes = sizes;
			this.#removeItemSize = (index) => {
				this.#calculatedSize -= sizes[index];
				sizes[index] = 0;
			};
			this.#requireSize = (k, v, size, sizeCalculation) => {
				if (this.#isBackgroundFetch(v)) return 0;
				if (!isPosInt(size)) if (sizeCalculation) {
					if (typeof sizeCalculation !== "function") throw new TypeError("sizeCalculation must be a function");
					size = sizeCalculation(v, k);
					if (!isPosInt(size)) throw new TypeError("sizeCalculation return invalid (expect positive integer)");
				} else throw new TypeError("invalid size value (must be positive integer). When maxSize or maxEntrySize is used, sizeCalculation or size must be set.");
				return size;
			};
			this.#addItemSize = (index, size, status) => {
				sizes[index] = size;
				if (this.#maxSize) {
					const maxSize = this.#maxSize - sizes[index];
					while (this.#calculatedSize > maxSize) this.#evict(true);
				}
				this.#calculatedSize += sizes[index];
				if (status) {
					status.entrySize = size;
					status.totalCalculatedSize = this.#calculatedSize;
				}
			};
		}
		#removeItemSize = (_i) => {};
		#addItemSize = (_i, _s, _st) => {};
		#requireSize = (_k, _v, size, sizeCalculation) => {
			if (size || sizeCalculation) throw new TypeError("cannot set size without setting maxSize or maxEntrySize on cache");
			return 0;
		};
		*#indexes({ allowStale = this.allowStale } = {}) {
			if (this.#size) for (let i = this.#tail;;) {
				if (!this.#isValidIndex(i)) break;
				if (allowStale || !this.#isStale(i)) yield i;
				if (i === this.#head) break;
				else i = this.#prev[i];
			}
		}
		*#rindexes({ allowStale = this.allowStale } = {}) {
			if (this.#size) for (let i = this.#head;;) {
				if (!this.#isValidIndex(i)) break;
				if (allowStale || !this.#isStale(i)) yield i;
				if (i === this.#tail) break;
				else i = this.#next[i];
			}
		}
		#isValidIndex(index) {
			return index !== void 0 && this.#keyMap.get(this.#keyList[index]) === index;
		}
		*entries() {
			for (const i of this.#indexes()) if (this.#valList[i] !== void 0 && this.#keyList[i] !== void 0 && !this.#isBackgroundFetch(this.#valList[i])) yield [this.#keyList[i], this.#valList[i]];
		}
		*rentries() {
			for (const i of this.#rindexes()) if (this.#valList[i] !== void 0 && this.#keyList[i] !== void 0 && !this.#isBackgroundFetch(this.#valList[i])) yield [this.#keyList[i], this.#valList[i]];
		}
		*keys() {
			for (const i of this.#indexes()) {
				const k = this.#keyList[i];
				if (k !== void 0 && !this.#isBackgroundFetch(this.#valList[i])) yield k;
			}
		}
		*rkeys() {
			for (const i of this.#rindexes()) {
				const k = this.#keyList[i];
				if (k !== void 0 && !this.#isBackgroundFetch(this.#valList[i])) yield k;
			}
		}
		*values() {
			for (const i of this.#indexes()) if (this.#valList[i] !== void 0 && !this.#isBackgroundFetch(this.#valList[i])) yield this.#valList[i];
		}
		*rvalues() {
			for (const i of this.#rindexes()) if (this.#valList[i] !== void 0 && !this.#isBackgroundFetch(this.#valList[i])) yield this.#valList[i];
		}
		[Symbol.iterator]() {
			return this.entries();
		}
		[Symbol.toStringTag] = "LRUCache";
		find(fn, getOptions$1 = {}) {
			for (const i of this.#indexes()) {
				const v = this.#valList[i];
				const value = this.#isBackgroundFetch(v) ? v.__staleWhileFetching : v;
				if (value === void 0) continue;
				if (fn(value, this.#keyList[i], this)) return this.get(this.#keyList[i], getOptions$1);
			}
		}
		forEach(fn, thisp = this) {
			for (const i of this.#indexes()) {
				const v = this.#valList[i];
				const value = this.#isBackgroundFetch(v) ? v.__staleWhileFetching : v;
				if (value === void 0) continue;
				fn.call(thisp, value, this.#keyList[i], this);
			}
		}
		rforEach(fn, thisp = this) {
			for (const i of this.#rindexes()) {
				const v = this.#valList[i];
				const value = this.#isBackgroundFetch(v) ? v.__staleWhileFetching : v;
				if (value === void 0) continue;
				fn.call(thisp, value, this.#keyList[i], this);
			}
		}
		purgeStale() {
			let deleted = false;
			for (const i of this.#rindexes({ allowStale: true })) if (this.#isStale(i)) {
				this.#delete(this.#keyList[i], "expire");
				deleted = true;
			}
			return deleted;
		}
		info(key) {
			const i = this.#keyMap.get(key);
			if (i === void 0) return void 0;
			const v = this.#valList[i];
			const value = this.#isBackgroundFetch(v) ? v.__staleWhileFetching : v;
			if (value === void 0) return void 0;
			const entry = { value };
			if (this.#ttls && this.#starts) {
				const ttl = this.#ttls[i];
				const start = this.#starts[i];
				if (ttl && start) {
					entry.ttl = ttl - (this.#perf.now() - start);
					entry.start = Date.now();
				}
			}
			if (this.#sizes) entry.size = this.#sizes[i];
			return entry;
		}
		dump() {
			const arr = [];
			for (const i of this.#indexes({ allowStale: true })) {
				const key = this.#keyList[i];
				const v = this.#valList[i];
				const value = this.#isBackgroundFetch(v) ? v.__staleWhileFetching : v;
				if (value === void 0 || key === void 0) continue;
				const entry = { value };
				if (this.#ttls && this.#starts) {
					entry.ttl = this.#ttls[i];
					const age = this.#perf.now() - this.#starts[i];
					entry.start = Math.floor(Date.now() - age);
				}
				if (this.#sizes) entry.size = this.#sizes[i];
				arr.unshift([key, entry]);
			}
			return arr;
		}
		load(arr) {
			this.clear();
			for (const [key, entry] of arr) {
				if (entry.start) {
					const age = Date.now() - entry.start;
					entry.start = this.#perf.now() - age;
				}
				this.set(key, entry.value, entry);
			}
		}
		set(k, v, setOptions = {}) {
			if (v === void 0) {
				this.delete(k);
				return this;
			}
			const { ttl = this.ttl, start, noDisposeOnSet = this.noDisposeOnSet, sizeCalculation = this.sizeCalculation, status } = setOptions;
			let { noUpdateTTL = this.noUpdateTTL } = setOptions;
			const size = this.#requireSize(k, v, setOptions.size || 0, sizeCalculation);
			if (this.maxEntrySize && size > this.maxEntrySize) {
				if (status) {
					status.set = "miss";
					status.maxEntrySizeExceeded = true;
				}
				this.#delete(k, "set");
				return this;
			}
			let index = this.#size === 0 ? void 0 : this.#keyMap.get(k);
			if (index === void 0) {
				index = this.#size === 0 ? this.#tail : this.#free.length !== 0 ? this.#free.pop() : this.#size === this.#max ? this.#evict(false) : this.#size;
				this.#keyList[index] = k;
				this.#valList[index] = v;
				this.#keyMap.set(k, index);
				this.#next[this.#tail] = index;
				this.#prev[index] = this.#tail;
				this.#tail = index;
				this.#size++;
				this.#addItemSize(index, size, status);
				if (status) status.set = "add";
				noUpdateTTL = false;
				if (this.#hasOnInsert) this.#onInsert?.(v, k, "add");
			} else {
				this.#moveToTail(index);
				const oldVal = this.#valList[index];
				if (v !== oldVal) {
					if (this.#hasFetchMethod && this.#isBackgroundFetch(oldVal)) {
						oldVal.__abortController.abort(/* @__PURE__ */ new Error("replaced"));
						const { __staleWhileFetching: s } = oldVal;
						if (s !== void 0 && !noDisposeOnSet) {
							if (this.#hasDispose) this.#dispose?.(s, k, "set");
							if (this.#hasDisposeAfter) this.#disposed?.push([
								s,
								k,
								"set"
							]);
						}
					} else if (!noDisposeOnSet) {
						if (this.#hasDispose) this.#dispose?.(oldVal, k, "set");
						if (this.#hasDisposeAfter) this.#disposed?.push([
							oldVal,
							k,
							"set"
						]);
					}
					this.#removeItemSize(index);
					this.#addItemSize(index, size, status);
					this.#valList[index] = v;
					if (status) {
						status.set = "replace";
						const oldValue = oldVal && this.#isBackgroundFetch(oldVal) ? oldVal.__staleWhileFetching : oldVal;
						if (oldValue !== void 0) status.oldValue = oldValue;
					}
				} else if (status) status.set = "update";
				if (this.#hasOnInsert) this.onInsert?.(v, k, v === oldVal ? "update" : "replace");
			}
			if (ttl !== 0 && !this.#ttls) this.#initializeTTLTracking();
			if (this.#ttls) {
				if (!noUpdateTTL) this.#setItemTTL(index, ttl, start);
				if (status) this.#statusTTL(status, index);
			}
			if (!noDisposeOnSet && this.#hasDisposeAfter && this.#disposed) {
				const dt = this.#disposed;
				let task;
				while (task = dt?.shift()) this.#disposeAfter?.(...task);
			}
			return this;
		}
		pop() {
			try {
				while (this.#size) {
					const val = this.#valList[this.#head];
					this.#evict(true);
					if (this.#isBackgroundFetch(val)) {
						if (val.__staleWhileFetching) return val.__staleWhileFetching;
					} else if (val !== void 0) return val;
				}
			} finally {
				if (this.#hasDisposeAfter && this.#disposed) {
					const dt = this.#disposed;
					let task;
					while (task = dt?.shift()) this.#disposeAfter?.(...task);
				}
			}
		}
		#evict(free) {
			const head = this.#head;
			const k = this.#keyList[head];
			const v = this.#valList[head];
			if (this.#hasFetchMethod && this.#isBackgroundFetch(v)) v.__abortController.abort(/* @__PURE__ */ new Error("evicted"));
			else if (this.#hasDispose || this.#hasDisposeAfter) {
				if (this.#hasDispose) this.#dispose?.(v, k, "evict");
				if (this.#hasDisposeAfter) this.#disposed?.push([
					v,
					k,
					"evict"
				]);
			}
			this.#removeItemSize(head);
			if (free) {
				this.#keyList[head] = void 0;
				this.#valList[head] = void 0;
				this.#free.push(head);
			}
			if (this.#size === 1) {
				this.#head = this.#tail = 0;
				this.#free.length = 0;
			} else this.#head = this.#next[head];
			this.#keyMap.delete(k);
			this.#size--;
			return head;
		}
		has(k, hasOptions = {}) {
			const { updateAgeOnHas = this.updateAgeOnHas, status } = hasOptions;
			const index = this.#keyMap.get(k);
			if (index !== void 0) {
				const v = this.#valList[index];
				if (this.#isBackgroundFetch(v) && v.__staleWhileFetching === void 0) return false;
				if (!this.#isStale(index)) {
					if (updateAgeOnHas) this.#updateItemAge(index);
					if (status) {
						status.has = "hit";
						this.#statusTTL(status, index);
					}
					return true;
				} else if (status) {
					status.has = "stale";
					this.#statusTTL(status, index);
				}
			} else if (status) status.has = "miss";
			return false;
		}
		peek(k, peekOptions = {}) {
			const { allowStale = this.allowStale } = peekOptions;
			const index = this.#keyMap.get(k);
			if (index === void 0 || !allowStale && this.#isStale(index)) return;
			const v = this.#valList[index];
			return this.#isBackgroundFetch(v) ? v.__staleWhileFetching : v;
		}
		#backgroundFetch(k, index, options, context) {
			const v = index === void 0 ? void 0 : this.#valList[index];
			if (this.#isBackgroundFetch(v)) return v;
			const ac = new AC();
			const { signal } = options;
			signal?.addEventListener("abort", () => ac.abort(signal.reason), { signal: ac.signal });
			const fetchOpts = {
				signal: ac.signal,
				options,
				context
			};
			const cb = (v$1, updateCache = false) => {
				const { aborted } = ac.signal;
				const ignoreAbort = options.ignoreFetchAbort && v$1 !== void 0;
				if (options.status) if (aborted && !updateCache) {
					options.status.fetchAborted = true;
					options.status.fetchError = ac.signal.reason;
					if (ignoreAbort) options.status.fetchAbortIgnored = true;
				} else options.status.fetchResolved = true;
				if (aborted && !ignoreAbort && !updateCache) return fetchFail(ac.signal.reason);
				const bf$1 = p;
				if (this.#valList[index] === p) if (v$1 === void 0) if (bf$1.__staleWhileFetching !== void 0) this.#valList[index] = bf$1.__staleWhileFetching;
				else this.#delete(k, "fetch");
				else {
					if (options.status) options.status.fetchUpdated = true;
					this.set(k, v$1, fetchOpts.options);
				}
				return v$1;
			};
			const eb = (er) => {
				if (options.status) {
					options.status.fetchRejected = true;
					options.status.fetchError = er;
				}
				return fetchFail(er);
			};
			const fetchFail = (er) => {
				const { aborted } = ac.signal;
				const allowStaleAborted = aborted && options.allowStaleOnFetchAbort;
				const allowStale = allowStaleAborted || options.allowStaleOnFetchRejection;
				const noDelete = allowStale || options.noDeleteOnFetchRejection;
				const bf$1 = p;
				if (this.#valList[index] === p) {
					if (!noDelete || bf$1.__staleWhileFetching === void 0) this.#delete(k, "fetch");
					else if (!allowStaleAborted) this.#valList[index] = bf$1.__staleWhileFetching;
				}
				if (allowStale) {
					if (options.status && bf$1.__staleWhileFetching !== void 0) options.status.returnedStale = true;
					return bf$1.__staleWhileFetching;
				} else if (bf$1.__returned === bf$1) throw er;
			};
			const pcall = (res, rej) => {
				const fmp = this.#fetchMethod?.(k, v, fetchOpts);
				if (fmp && fmp instanceof Promise) fmp.then((v$1) => res(v$1 === void 0 ? void 0 : v$1), rej);
				ac.signal.addEventListener("abort", () => {
					if (!options.ignoreFetchAbort || options.allowStaleOnFetchAbort) {
						res(void 0);
						if (options.allowStaleOnFetchAbort) res = (v$1) => cb(v$1, true);
					}
				});
			};
			if (options.status) options.status.fetchDispatched = true;
			const p = new Promise(pcall).then(cb, eb);
			const bf = Object.assign(p, {
				__abortController: ac,
				__staleWhileFetching: v,
				__returned: void 0
			});
			if (index === void 0) {
				this.set(k, bf, {
					...fetchOpts.options,
					status: void 0
				});
				index = this.#keyMap.get(k);
			} else this.#valList[index] = bf;
			return bf;
		}
		#isBackgroundFetch(p) {
			if (!this.#hasFetchMethod) return false;
			const b = p;
			return !!b && b instanceof Promise && b.hasOwnProperty("__staleWhileFetching") && b.__abortController instanceof AC;
		}
		async fetch(k, fetchOptions = {}) {
			const { allowStale = this.allowStale, updateAgeOnGet = this.updateAgeOnGet, noDeleteOnStaleGet = this.noDeleteOnStaleGet, ttl = this.ttl, noDisposeOnSet = this.noDisposeOnSet, size = 0, sizeCalculation = this.sizeCalculation, noUpdateTTL = this.noUpdateTTL, noDeleteOnFetchRejection = this.noDeleteOnFetchRejection, allowStaleOnFetchRejection = this.allowStaleOnFetchRejection, ignoreFetchAbort = this.ignoreFetchAbort, allowStaleOnFetchAbort = this.allowStaleOnFetchAbort, context, forceRefresh = false, status, signal } = fetchOptions;
			if (!this.#hasFetchMethod) {
				if (status) status.fetch = "get";
				return this.get(k, {
					allowStale,
					updateAgeOnGet,
					noDeleteOnStaleGet,
					status
				});
			}
			const options = {
				allowStale,
				updateAgeOnGet,
				noDeleteOnStaleGet,
				ttl,
				noDisposeOnSet,
				size,
				sizeCalculation,
				noUpdateTTL,
				noDeleteOnFetchRejection,
				allowStaleOnFetchRejection,
				allowStaleOnFetchAbort,
				ignoreFetchAbort,
				status,
				signal
			};
			let index = this.#keyMap.get(k);
			if (index === void 0) {
				if (status) status.fetch = "miss";
				const p = this.#backgroundFetch(k, index, options, context);
				return p.__returned = p;
			} else {
				const v = this.#valList[index];
				if (this.#isBackgroundFetch(v)) {
					const stale = allowStale && v.__staleWhileFetching !== void 0;
					if (status) {
						status.fetch = "inflight";
						if (stale) status.returnedStale = true;
					}
					return stale ? v.__staleWhileFetching : v.__returned = v;
				}
				const isStale = this.#isStale(index);
				if (!forceRefresh && !isStale) {
					if (status) status.fetch = "hit";
					this.#moveToTail(index);
					if (updateAgeOnGet) this.#updateItemAge(index);
					if (status) this.#statusTTL(status, index);
					return v;
				}
				const p = this.#backgroundFetch(k, index, options, context);
				const staleVal = p.__staleWhileFetching !== void 0 && allowStale;
				if (status) {
					status.fetch = isStale ? "stale" : "refresh";
					if (staleVal && isStale) status.returnedStale = true;
				}
				return staleVal ? p.__staleWhileFetching : p.__returned = p;
			}
		}
		async forceFetch(k, fetchOptions = {}) {
			const v = await this.fetch(k, fetchOptions);
			if (v === void 0) throw new Error("fetch() returned undefined");
			return v;
		}
		memo(k, memoOptions = {}) {
			const memoMethod = this.#memoMethod;
			if (!memoMethod) throw new Error("no memoMethod provided to constructor");
			const { context, forceRefresh,...options } = memoOptions;
			const v = this.get(k, options);
			if (!forceRefresh && v !== void 0) return v;
			const vv = memoMethod(k, v, {
				options,
				context
			});
			this.set(k, vv, options);
			return vv;
		}
		get(k, getOptions$1 = {}) {
			const { allowStale = this.allowStale, updateAgeOnGet = this.updateAgeOnGet, noDeleteOnStaleGet = this.noDeleteOnStaleGet, status } = getOptions$1;
			const index = this.#keyMap.get(k);
			if (index !== void 0) {
				const value = this.#valList[index];
				const fetching = this.#isBackgroundFetch(value);
				if (status) this.#statusTTL(status, index);
				if (this.#isStale(index)) {
					if (status) status.get = "stale";
					if (!fetching) {
						if (!noDeleteOnStaleGet) this.#delete(k, "expire");
						if (status && allowStale) status.returnedStale = true;
						return allowStale ? value : void 0;
					} else {
						if (status && allowStale && value.__staleWhileFetching !== void 0) status.returnedStale = true;
						return allowStale ? value.__staleWhileFetching : void 0;
					}
				} else {
					if (status) status.get = "hit";
					if (fetching) return value.__staleWhileFetching;
					this.#moveToTail(index);
					if (updateAgeOnGet) this.#updateItemAge(index);
					return value;
				}
			} else if (status) status.get = "miss";
		}
		#connect(p, n) {
			this.#prev[n] = p;
			this.#next[p] = n;
		}
		#moveToTail(index) {
			if (index !== this.#tail) {
				if (index === this.#head) this.#head = this.#next[index];
				else this.#connect(this.#prev[index], this.#next[index]);
				this.#connect(this.#tail, index);
				this.#tail = index;
			}
		}
		delete(k) {
			return this.#delete(k, "delete");
		}
		#delete(k, reason) {
			let deleted = false;
			if (this.#size !== 0) {
				const index = this.#keyMap.get(k);
				if (index !== void 0) {
					deleted = true;
					if (this.#size === 1) this.#clear(reason);
					else {
						this.#removeItemSize(index);
						const v = this.#valList[index];
						if (this.#isBackgroundFetch(v)) v.__abortController.abort(/* @__PURE__ */ new Error("deleted"));
						else if (this.#hasDispose || this.#hasDisposeAfter) {
							if (this.#hasDispose) this.#dispose?.(v, k, reason);
							if (this.#hasDisposeAfter) this.#disposed?.push([
								v,
								k,
								reason
							]);
						}
						this.#keyMap.delete(k);
						this.#keyList[index] = void 0;
						this.#valList[index] = void 0;
						if (index === this.#tail) this.#tail = this.#prev[index];
						else if (index === this.#head) this.#head = this.#next[index];
						else {
							const pi = this.#prev[index];
							this.#next[pi] = this.#next[index];
							const ni = this.#next[index];
							this.#prev[ni] = this.#prev[index];
						}
						this.#size--;
						this.#free.push(index);
					}
				}
			}
			if (this.#hasDisposeAfter && this.#disposed?.length) {
				const dt = this.#disposed;
				let task;
				while (task = dt?.shift()) this.#disposeAfter?.(...task);
			}
			return deleted;
		}
		clear() {
			return this.#clear("delete");
		}
		#clear(reason) {
			for (const index of this.#rindexes({ allowStale: true })) {
				const v = this.#valList[index];
				if (this.#isBackgroundFetch(v)) v.__abortController.abort(/* @__PURE__ */ new Error("deleted"));
				else {
					const k = this.#keyList[index];
					if (this.#hasDispose) this.#dispose?.(v, k, reason);
					if (this.#hasDisposeAfter) this.#disposed?.push([
						v,
						k,
						reason
					]);
				}
			}
			this.#keyMap.clear();
			this.#valList.fill(void 0);
			this.#keyList.fill(void 0);
			if (this.#ttls && this.#starts) {
				this.#ttls.fill(0);
				this.#starts.fill(0);
			}
			if (this.#sizes) this.#sizes.fill(0);
			this.#head = 0;
			this.#tail = 0;
			this.#free.length = 0;
			this.#calculatedSize = 0;
			this.#size = 0;
			if (this.#hasDisposeAfter && this.#disposed) {
				const dt = this.#disposed;
				let task;
				while (task = dt?.shift()) this.#disposeAfter?.(...task);
			}
		}
	}
	commonjs.LRUCache = LRUCache;
	return commonjs;
}
var hosts_1;
var hasRequiredHosts;
function requireHosts() {
	if (hasRequiredHosts) return hosts_1;
	hasRequiredHosts = 1;
	const maybeJoin = (...args) => args.every((arg) => arg) ? args.join("") : "";
	const maybeEncode = (arg) => arg ? encodeURIComponent(arg) : "";
	const formatHashFragment = (f) => f.toLowerCase().replace(/^\W+/g, "").replace(/(?<!\W)\W+$/, "").replace(/\//g, "").replace(/\W+/g, "-");
	const defaults = {
		sshtemplate: ({ domain, user, project, committish }) => `git@${domain}:${user}/${project}.git${maybeJoin("#", committish)}`,
		sshurltemplate: ({ domain, user, project, committish }) => `git+ssh://git@${domain}/${user}/${project}.git${maybeJoin("#", committish)}`,
		edittemplate: ({ domain, user, project, committish, editpath, path: path$1 }) => `https://${domain}/${user}/${project}${maybeJoin("/", editpath, "/", maybeEncode(committish || "HEAD"), "/", path$1)}`,
		browsetemplate: ({ domain, user, project, committish, treepath }) => `https://${domain}/${user}/${project}${maybeJoin("/", treepath, "/", maybeEncode(committish))}`,
		browsetreetemplate: ({ domain, user, project, committish, treepath, path: path$1, fragment, hashformat }) => `https://${domain}/${user}/${project}/${treepath}/${maybeEncode(committish || "HEAD")}/${path$1}${maybeJoin("#", hashformat(fragment || ""))}`,
		browseblobtemplate: ({ domain, user, project, committish, blobpath, path: path$1, fragment, hashformat }) => `https://${domain}/${user}/${project}/${blobpath}/${maybeEncode(committish || "HEAD")}/${path$1}${maybeJoin("#", hashformat(fragment || ""))}`,
		docstemplate: ({ domain, user, project, treepath, committish }) => `https://${domain}/${user}/${project}${maybeJoin("/", treepath, "/", maybeEncode(committish))}#readme`,
		httpstemplate: ({ auth, domain, user, project, committish }) => `git+https://${maybeJoin(auth, "@")}${domain}/${user}/${project}.git${maybeJoin("#", committish)}`,
		filetemplate: ({ domain, user, project, committish, path: path$1 }) => `https://${domain}/${user}/${project}/raw/${maybeEncode(committish || "HEAD")}/${path$1}`,
		shortcuttemplate: ({ type, user, project, committish }) => `${type}:${user}/${project}${maybeJoin("#", committish)}`,
		pathtemplate: ({ user, project, committish }) => `${user}/${project}${maybeJoin("#", committish)}`,
		bugstemplate: ({ domain, user, project }) => `https://${domain}/${user}/${project}/issues`,
		hashformat: formatHashFragment
	};
	const hosts = {};
	hosts.github = {
		protocols: [
			"git:",
			"http:",
			"git+ssh:",
			"git+https:",
			"ssh:",
			"https:"
		],
		domain: "github.com",
		treepath: "tree",
		blobpath: "blob",
		editpath: "edit",
		filetemplate: ({ auth, user, project, committish, path: path$1 }) => `https://${maybeJoin(auth, "@")}raw.githubusercontent.com/${user}/${project}/${maybeEncode(committish || "HEAD")}/${path$1}`,
		gittemplate: ({ auth, domain, user, project, committish }) => `git://${maybeJoin(auth, "@")}${domain}/${user}/${project}.git${maybeJoin("#", committish)}`,
		tarballtemplate: ({ domain, user, project, committish }) => `https://codeload.${domain}/${user}/${project}/tar.gz/${maybeEncode(committish || "HEAD")}`,
		extract: (url) => {
			let [, user, project, type, committish] = url.pathname.split("/", 5);
			if (type && type !== "tree") return;
			if (!type) committish = url.hash.slice(1);
			if (project && project.endsWith(".git")) project = project.slice(0, -4);
			if (!user || !project) return;
			return {
				user,
				project,
				committish
			};
		}
	};
	hosts.bitbucket = {
		protocols: [
			"git+ssh:",
			"git+https:",
			"ssh:",
			"https:"
		],
		domain: "bitbucket.org",
		treepath: "src",
		blobpath: "src",
		editpath: "?mode=edit",
		edittemplate: ({ domain, user, project, committish, treepath, path: path$1, editpath }) => `https://${domain}/${user}/${project}${maybeJoin("/", treepath, "/", maybeEncode(committish || "HEAD"), "/", path$1, editpath)}`,
		tarballtemplate: ({ domain, user, project, committish }) => `https://${domain}/${user}/${project}/get/${maybeEncode(committish || "HEAD")}.tar.gz`,
		extract: (url) => {
			let [, user, project, aux] = url.pathname.split("/", 4);
			if (["get"].includes(aux)) return;
			if (project && project.endsWith(".git")) project = project.slice(0, -4);
			if (!user || !project) return;
			return {
				user,
				project,
				committish: url.hash.slice(1)
			};
		}
	};
	hosts.gitlab = {
		protocols: [
			"git+ssh:",
			"git+https:",
			"ssh:",
			"https:"
		],
		domain: "gitlab.com",
		treepath: "tree",
		blobpath: "tree",
		editpath: "-/edit",
		httpstemplate: ({ auth, domain, user, project, committish }) => `git+https://${maybeJoin(auth, "@")}${domain}/${user}/${project}.git${maybeJoin("#", committish)}`,
		tarballtemplate: ({ domain, user, project, committish }) => `https://${domain}/${user}/${project}/repository/archive.tar.gz?ref=${maybeEncode(committish || "HEAD")}`,
		extract: (url) => {
			const path$1 = url.pathname.slice(1);
			if (path$1.includes("/-/") || path$1.includes("/archive.tar.gz")) return;
			const segments = path$1.split("/");
			let project = segments.pop();
			if (project.endsWith(".git")) project = project.slice(0, -4);
			const user = segments.join("/");
			if (!user || !project) return;
			return {
				user,
				project,
				committish: url.hash.slice(1)
			};
		}
	};
	hosts.gist = {
		protocols: [
			"git:",
			"git+ssh:",
			"git+https:",
			"ssh:",
			"https:"
		],
		domain: "gist.github.com",
		editpath: "edit",
		sshtemplate: ({ domain, project, committish }) => `git@${domain}:${project}.git${maybeJoin("#", committish)}`,
		sshurltemplate: ({ domain, project, committish }) => `git+ssh://git@${domain}/${project}.git${maybeJoin("#", committish)}`,
		edittemplate: ({ domain, user, project, committish, editpath }) => `https://${domain}/${user}/${project}${maybeJoin("/", maybeEncode(committish))}/${editpath}`,
		browsetemplate: ({ domain, project, committish }) => `https://${domain}/${project}${maybeJoin("/", maybeEncode(committish))}`,
		browsetreetemplate: ({ domain, project, committish, path: path$1, hashformat }) => `https://${domain}/${project}${maybeJoin("/", maybeEncode(committish))}${maybeJoin("#", hashformat(path$1))}`,
		browseblobtemplate: ({ domain, project, committish, path: path$1, hashformat }) => `https://${domain}/${project}${maybeJoin("/", maybeEncode(committish))}${maybeJoin("#", hashformat(path$1))}`,
		docstemplate: ({ domain, project, committish }) => `https://${domain}/${project}${maybeJoin("/", maybeEncode(committish))}`,
		httpstemplate: ({ domain, project, committish }) => `git+https://${domain}/${project}.git${maybeJoin("#", committish)}`,
		filetemplate: ({ user, project, committish, path: path$1 }) => `https://gist.githubusercontent.com/${user}/${project}/raw${maybeJoin("/", maybeEncode(committish))}/${path$1}`,
		shortcuttemplate: ({ type, project, committish }) => `${type}:${project}${maybeJoin("#", committish)}`,
		pathtemplate: ({ project, committish }) => `${project}${maybeJoin("#", committish)}`,
		bugstemplate: ({ domain, project }) => `https://${domain}/${project}`,
		gittemplate: ({ domain, project, committish }) => `git://${domain}/${project}.git${maybeJoin("#", committish)}`,
		tarballtemplate: ({ project, committish }) => `https://codeload.github.com/gist/${project}/tar.gz/${maybeEncode(committish || "HEAD")}`,
		extract: (url) => {
			let [, user, project, aux] = url.pathname.split("/", 4);
			if (aux === "raw") return;
			if (!project) {
				if (!user) return;
				project = user;
				user = null;
			}
			if (project.endsWith(".git")) project = project.slice(0, -4);
			return {
				user,
				project,
				committish: url.hash.slice(1)
			};
		},
		hashformat: function(fragment) {
			return fragment && "file-" + formatHashFragment(fragment);
		}
	};
	hosts.sourcehut = {
		protocols: ["git+ssh:", "https:"],
		domain: "git.sr.ht",
		treepath: "tree",
		blobpath: "tree",
		filetemplate: ({ domain, user, project, committish, path: path$1 }) => `https://${domain}/${user}/${project}/blob/${maybeEncode(committish) || "HEAD"}/${path$1}`,
		httpstemplate: ({ domain, user, project, committish }) => `https://${domain}/${user}/${project}.git${maybeJoin("#", committish)}`,
		tarballtemplate: ({ domain, user, project, committish }) => `https://${domain}/${user}/${project}/archive/${maybeEncode(committish) || "HEAD"}.tar.gz`,
		bugstemplate: () => null,
		extract: (url) => {
			let [, user, project, aux] = url.pathname.split("/", 4);
			if (["archive"].includes(aux)) return;
			if (project && project.endsWith(".git")) project = project.slice(0, -4);
			if (!user || !project) return;
			return {
				user,
				project,
				committish: url.hash.slice(1)
			};
		}
	};
	for (const [name, host] of Object.entries(hosts)) hosts[name] = Object.assign({}, defaults, host);
	hosts_1 = hosts;
	return hosts_1;
}
var parseUrl;
var hasRequiredParseUrl;
function requireParseUrl() {
	if (hasRequiredParseUrl) return parseUrl;
	hasRequiredParseUrl = 1;
	const url = require$$0;
	const lastIndexOfBefore = (str, char, beforeChar) => {
		const startPosition = str.indexOf(beforeChar);
		return str.lastIndexOf(char, startPosition > -1 ? startPosition : Infinity);
	};
	const safeUrl = (u) => {
		try {
			return new url.URL(u);
		} catch {}
	};
	const correctProtocol = (arg, protocols) => {
		const firstColon = arg.indexOf(":");
		const proto$1 = arg.slice(0, firstColon + 1);
		if (Object.prototype.hasOwnProperty.call(protocols, proto$1)) return arg;
		const firstAt = arg.indexOf("@");
		if (firstAt > -1) if (firstAt > firstColon) return `git+ssh://${arg}`;
		else return arg;
		if (arg.indexOf("//") === firstColon + 1) return arg;
		return `${arg.slice(0, firstColon + 1)}//${arg.slice(firstColon + 1)}`;
	};
	const correctUrl = (giturl) => {
		const firstAt = lastIndexOfBefore(giturl, "@", "#");
		const lastColonBeforeHash = lastIndexOfBefore(giturl, ":", "#");
		if (lastColonBeforeHash > firstAt) giturl = giturl.slice(0, lastColonBeforeHash) + "/" + giturl.slice(lastColonBeforeHash + 1);
		if (lastIndexOfBefore(giturl, ":", "#") === -1 && giturl.indexOf("//") === -1) giturl = `git+ssh://${giturl}`;
		return giturl;
	};
	parseUrl = (giturl, protocols) => {
		const withProtocol = protocols ? correctProtocol(giturl, protocols) : giturl;
		return safeUrl(withProtocol) || safeUrl(correctUrl(withProtocol));
	};
	return parseUrl;
}
var fromUrl;
var hasRequiredFromUrl;
function requireFromUrl() {
	if (hasRequiredFromUrl) return fromUrl;
	hasRequiredFromUrl = 1;
	const parseUrl$2 = requireParseUrl();
	const isGitHubShorthand = (arg) => {
		const firstHash = arg.indexOf("#");
		const firstSlash = arg.indexOf("/");
		const secondSlash = arg.indexOf("/", firstSlash + 1);
		const firstColon = arg.indexOf(":");
		const firstSpace = /\s/.exec(arg);
		const firstAt = arg.indexOf("@");
		const spaceOnlyAfterHash = !firstSpace || firstHash > -1 && firstSpace.index > firstHash;
		const atOnlyAfterHash = firstAt === -1 || firstHash > -1 && firstAt > firstHash;
		const colonOnlyAfterHash = firstColon === -1 || firstHash > -1 && firstColon > firstHash;
		const secondSlashOnlyAfterHash = secondSlash === -1 || firstHash > -1 && secondSlash > firstHash;
		const hasSlash = firstSlash > 0;
		const doesNotEndWithSlash = firstHash > -1 ? arg[firstHash - 1] !== "/" : !arg.endsWith("/");
		const doesNotStartWithDot = !arg.startsWith(".");
		return spaceOnlyAfterHash && hasSlash && doesNotEndWithSlash && doesNotStartWithDot && atOnlyAfterHash && colonOnlyAfterHash && secondSlashOnlyAfterHash;
	};
	fromUrl = (giturl, opts, { gitHosts, protocols }) => {
		if (!giturl) return;
		const parsed = parseUrl$2(isGitHubShorthand(giturl) ? `github:${giturl}` : giturl, protocols);
		if (!parsed) return;
		const gitHostShortcut = gitHosts.byShortcut[parsed.protocol];
		const gitHostDomain = gitHosts.byDomain[parsed.hostname.startsWith("www.") ? parsed.hostname.slice(4) : parsed.hostname];
		const gitHostName = gitHostShortcut || gitHostDomain;
		if (!gitHostName) return;
		const gitHostInfo = gitHosts[gitHostShortcut || gitHostDomain];
		let auth = null;
		if (protocols[parsed.protocol]?.auth && (parsed.username || parsed.password)) auth = `${parsed.username}${parsed.password ? ":" + parsed.password : ""}`;
		let committish = null;
		let user = null;
		let project = null;
		let defaultRepresentation = null;
		try {
			if (gitHostShortcut) {
				let pathname = parsed.pathname.startsWith("/") ? parsed.pathname.slice(1) : parsed.pathname;
				const firstAt = pathname.indexOf("@");
				if (firstAt > -1) pathname = pathname.slice(firstAt + 1);
				const lastSlash = pathname.lastIndexOf("/");
				if (lastSlash > -1) {
					user = decodeURIComponent(pathname.slice(0, lastSlash));
					if (!user) user = null;
					project = decodeURIComponent(pathname.slice(lastSlash + 1));
				} else project = decodeURIComponent(pathname);
				if (project.endsWith(".git")) project = project.slice(0, -4);
				if (parsed.hash) committish = decodeURIComponent(parsed.hash.slice(1));
				defaultRepresentation = "shortcut";
			} else {
				if (!gitHostInfo.protocols.includes(parsed.protocol)) return;
				const segments = gitHostInfo.extract(parsed);
				if (!segments) return;
				user = segments.user && decodeURIComponent(segments.user);
				project = decodeURIComponent(segments.project);
				committish = decodeURIComponent(segments.committish);
				defaultRepresentation = protocols[parsed.protocol]?.name || parsed.protocol.slice(0, -1);
			}
		} catch (err) {
			if (err instanceof URIError) return;
			else throw err;
		}
		return [
			gitHostName,
			user,
			auth,
			project,
			committish,
			defaultRepresentation,
			opts
		];
	};
	return fromUrl;
}
var lib;
var hasRequiredLib;
function requireLib() {
	if (hasRequiredLib) return lib;
	hasRequiredLib = 1;
	const { LRUCache } = requireCommonjs();
	const hosts = requireHosts();
	const fromUrl$2 = requireFromUrl();
	const parseUrl$2 = requireParseUrl();
	const cache$4 = new LRUCache({ max: 1e3 });
	function unknownHostedUrl(url) {
		try {
			const { protocol, hostname, pathname } = new URL(url);
			if (!hostname) return null;
			return `${/(?:git\+)http:$/.test(protocol) ? "http:" : "https:"}//${hostname}${pathname.replace(/\.git$/, "")}`;
		} catch {
			return null;
		}
	}
	class GitHost {
		constructor(type, user, auth, project, committish, defaultRepresentation, opts = {}) {
			Object.assign(this, GitHost.#gitHosts[type], {
				type,
				user,
				auth,
				project,
				committish,
				default: defaultRepresentation,
				opts
			});
		}
		static #gitHosts = {
			byShortcut: {},
			byDomain: {}
		};
		static #protocols = {
			"git+ssh:": { name: "sshurl" },
			"ssh:": { name: "sshurl" },
			"git+https:": {
				name: "https",
				auth: true
			},
			"git:": { auth: true },
			"http:": { auth: true },
			"https:": { auth: true },
			"git+http:": { auth: true }
		};
		static addHost(name, host) {
			GitHost.#gitHosts[name] = host;
			GitHost.#gitHosts.byDomain[host.domain] = name;
			GitHost.#gitHosts.byShortcut[`${name}:`] = name;
			GitHost.#protocols[`${name}:`] = { name };
		}
		static fromUrl(giturl, opts) {
			if (typeof giturl !== "string") return;
			const key = giturl + JSON.stringify(opts || {});
			if (!cache$4.has(key)) {
				const hostArgs = fromUrl$2(giturl, opts, {
					gitHosts: GitHost.#gitHosts,
					protocols: GitHost.#protocols
				});
				cache$4.set(key, hostArgs ? new GitHost(...hostArgs) : void 0);
			}
			return cache$4.get(key);
		}
		static fromManifest(manifest, opts = {}) {
			if (!manifest || typeof manifest !== "object") return;
			const r = manifest.repository;
			const rurl = r && (typeof r === "string" ? r : typeof r === "object" && typeof r.url === "string" ? r.url : null);
			if (!rurl) throw new Error("no repository");
			const info = rurl && GitHost.fromUrl(rurl.replace(/^git\+/, ""), opts) || null;
			if (info) return info;
			const unk = unknownHostedUrl(rurl);
			return GitHost.fromUrl(unk, opts) || unk;
		}
		static parseUrl(url) {
			return parseUrl$2(url);
		}
		#fill(template, opts) {
			if (typeof template !== "function") return null;
			const options = {
				...this,
				...this.opts,
				...opts
			};
			if (!options.path) options.path = "";
			if (options.path.startsWith("/")) options.path = options.path.slice(1);
			if (options.noCommittish) options.committish = null;
			const result = template(options);
			return options.noGitPlus && result.startsWith("git+") ? result.slice(4) : result;
		}
		hash() {
			return this.committish ? `#${this.committish}` : "";
		}
		ssh(opts) {
			return this.#fill(this.sshtemplate, opts);
		}
		sshurl(opts) {
			return this.#fill(this.sshurltemplate, opts);
		}
		browse(path$1, ...args) {
			if (typeof path$1 !== "string") return this.#fill(this.browsetemplate, path$1);
			if (typeof args[0] !== "string") return this.#fill(this.browsetreetemplate, {
				...args[0],
				path: path$1
			});
			return this.#fill(this.browsetreetemplate, {
				...args[1],
				fragment: args[0],
				path: path$1
			});
		}
		browseFile(path$1, ...args) {
			if (typeof args[0] !== "string") return this.#fill(this.browseblobtemplate, {
				...args[0],
				path: path$1
			});
			return this.#fill(this.browseblobtemplate, {
				...args[1],
				fragment: args[0],
				path: path$1
			});
		}
		docs(opts) {
			return this.#fill(this.docstemplate, opts);
		}
		bugs(opts) {
			return this.#fill(this.bugstemplate, opts);
		}
		https(opts) {
			return this.#fill(this.httpstemplate, opts);
		}
		git(opts) {
			return this.#fill(this.gittemplate, opts);
		}
		shortcut(opts) {
			return this.#fill(this.shortcuttemplate, opts);
		}
		path(opts) {
			return this.#fill(this.pathtemplate, opts);
		}
		tarball(opts) {
			return this.#fill(this.tarballtemplate, {
				...opts,
				noCommittish: false
			});
		}
		file(path$1, opts) {
			return this.#fill(this.filetemplate, {
				...opts,
				path: path$1
			});
		}
		edit(path$1, opts) {
			return this.#fill(this.edittemplate, {
				...opts,
				path: path$1
			});
		}
		getDefaultRepresentation() {
			return this.default;
		}
		toString(opts) {
			if (this.default && typeof this[this.default] === "function") return this[this.default](opts);
			return this.sshurl(opts);
		}
	}
	for (const [name, host] of Object.entries(hosts)) GitHost.addHost(name, host);
	lib = GitHost;
	return lib;
}
var extract_description;
var hasRequiredExtract_description;
function requireExtract_description() {
	if (hasRequiredExtract_description) return extract_description;
	hasRequiredExtract_description = 1;
	extract_description = extractDescription;
	function extractDescription(d) {
		if (!d) return;
		if (d === "ERROR: No README data found!") return;
		d = d.trim().split("\n");
		let s = 0;
		while (d[s] && d[s].trim().match(/^(#|$)/)) s++;
		const l = d.length;
		let e = s + 1;
		while (e < l && d[e].trim()) e++;
		return d.slice(s, e).join(" ").trim();
	}
	return extract_description;
}
const require$$7 = {
	topLevel: {
		dependancies: "dependencies",
		dependecies: "dependencies",
		depdenencies: "dependencies",
		devEependencies: "devDependencies",
		depends: "dependencies",
		"dev-dependencies": "devDependencies",
		devDependences: "devDependencies",
		devDepenencies: "devDependencies",
		devdependencies: "devDependencies",
		repostitory: "repository",
		repo: "repository",
		prefereGlobal: "preferGlobal",
		hompage: "homepage",
		hampage: "homepage",
		autohr: "author",
		autor: "author",
		contributers: "contributors",
		publicationConfig: "publishConfig",
		script: "scripts"
	},
	bugs: {
		web: "url",
		name: "url"
	},
	script: {
		server: "start",
		tests: "test"
	}
};
var fixer;
var hasRequiredFixer;
function requireFixer() {
	if (hasRequiredFixer) return fixer;
	hasRequiredFixer = 1;
	var { URL: URL$2 } = require$$0$2;
	var isValidSemver = requireValid();
	var cleanSemver = requireClean();
	var validateLicense = requireValidateNpmPackageLicense();
	var hostedGitInfo = requireLib();
	var { isBuiltin } = require$$4;
	var depTypes = [
		"dependencies",
		"devDependencies",
		"optionalDependencies"
	];
	var extractDescription = requireExtract_description();
	var typos = require$$7;
	var isEmail = (str) => str.includes("@") && str.indexOf("@") < str.lastIndexOf(".");
	fixer = {
		warn: function() {},
		fixRepositoryField: function(data) {
			if (data.repositories) {
				this.warn("repositories");
				data.repository = data.repositories[0];
			}
			if (!data.repository) return this.warn("missingRepository");
			if (typeof data.repository === "string") data.repository = {
				type: "git",
				url: data.repository
			};
			var r = data.repository.url || "";
			if (r) {
				var hosted = hostedGitInfo.fromUrl(r);
				if (hosted) r = data.repository.url = hosted.getDefaultRepresentation() === "shortcut" ? hosted.https() : hosted.toString();
			}
			if (r.match(/github.com\/[^/]+\/[^/]+\.git\.git$/)) this.warn("brokenGitUrl", r);
		},
		fixTypos: function(data) {
			Object.keys(typos.topLevel).forEach(function(d) {
				if (Object.prototype.hasOwnProperty.call(data, d)) this.warn("typo", d, typos.topLevel[d]);
			}, this);
		},
		fixScriptsField: function(data) {
			if (!data.scripts) return;
			if (typeof data.scripts !== "object") {
				this.warn("nonObjectScripts");
				delete data.scripts;
				return;
			}
			Object.keys(data.scripts).forEach(function(k) {
				if (typeof data.scripts[k] !== "string") {
					this.warn("nonStringScript");
					delete data.scripts[k];
				} else if (typos.script[k] && !data.scripts[typos.script[k]]) this.warn("typo", k, typos.script[k], "scripts");
			}, this);
		},
		fixFilesField: function(data) {
			var files = data.files;
			if (files && !Array.isArray(files)) {
				this.warn("nonArrayFiles");
				delete data.files;
			} else if (data.files) data.files = data.files.filter(function(file) {
				if (!file || typeof file !== "string") {
					this.warn("invalidFilename", file);
					return false;
				} else return true;
			}, this);
		},
		fixBinField: function(data) {
			if (!data.bin) return;
			if (typeof data.bin === "string") {
				var b = {};
				var match;
				if (match = data.name.match(/^@[^/]+[/](.*)$/)) b[match[1]] = data.bin;
				else b[data.name] = data.bin;
				data.bin = b;
			}
		},
		fixManField: function(data) {
			if (!data.man) return;
			if (typeof data.man === "string") data.man = [data.man];
		},
		fixBundleDependenciesField: function(data) {
			var bdd = "bundledDependencies";
			var bd = "bundleDependencies";
			if (data[bdd] && !data[bd]) {
				data[bd] = data[bdd];
				delete data[bdd];
			}
			if (data[bd] && !Array.isArray(data[bd])) {
				this.warn("nonArrayBundleDependencies");
				delete data[bd];
			} else if (data[bd]) data[bd] = data[bd].filter(function(filtered) {
				if (!filtered || typeof filtered !== "string") {
					this.warn("nonStringBundleDependency", filtered);
					return false;
				} else {
					if (!data.dependencies) data.dependencies = {};
					if (!Object.prototype.hasOwnProperty.call(data.dependencies, filtered)) {
						this.warn("nonDependencyBundleDependency", filtered);
						data.dependencies[filtered] = "*";
					}
					return true;
				}
			}, this);
		},
		fixDependencies: function(data) {
			objectifyDeps(data, this.warn);
			addOptionalDepsToDeps(data, this.warn);
			this.fixBundleDependenciesField(data);
			["dependencies", "devDependencies"].forEach(function(deps) {
				if (!(deps in data)) return;
				if (!data[deps] || typeof data[deps] !== "object") {
					this.warn("nonObjectDependencies", deps);
					delete data[deps];
					return;
				}
				Object.keys(data[deps]).forEach(function(d) {
					var r = data[deps][d];
					if (typeof r !== "string") {
						this.warn("nonStringDependency", d, JSON.stringify(r));
						delete data[deps][d];
					}
					var hosted = hostedGitInfo.fromUrl(data[deps][d]);
					if (hosted) data[deps][d] = hosted.toString();
				}, this);
			}, this);
		},
		fixModulesField: function(data) {
			if (data.modules) {
				this.warn("deprecatedModules");
				delete data.modules;
			}
		},
		fixKeywordsField: function(data) {
			if (typeof data.keywords === "string") data.keywords = data.keywords.split(/,\s+/);
			if (data.keywords && !Array.isArray(data.keywords)) {
				delete data.keywords;
				this.warn("nonArrayKeywords");
			} else if (data.keywords) data.keywords = data.keywords.filter(function(kw) {
				if (typeof kw !== "string" || !kw) {
					this.warn("nonStringKeyword");
					return false;
				} else return true;
			}, this);
		},
		fixVersionField: function(data, strict) {
			var loose = !strict;
			if (!data.version) {
				data.version = "";
				return true;
			}
			if (!isValidSemver(data.version, loose)) throw new Error("Invalid version: \"" + data.version + "\"");
			data.version = cleanSemver(data.version, loose);
			return true;
		},
		fixPeople: function(data) {
			modifyPeople(data, unParsePerson);
			modifyPeople(data, parsePerson);
		},
		fixNameField: function(data, options) {
			if (typeof options === "boolean") options = { strict: options };
			else if (typeof options === "undefined") options = {};
			var strict = options.strict;
			if (!data.name && !strict) {
				data.name = "";
				return;
			}
			if (typeof data.name !== "string") throw new Error("name field must be a string.");
			if (!strict) data.name = data.name.trim();
			ensureValidName(data.name, strict, options.allowLegacyCase);
			if (isBuiltin(data.name)) this.warn("conflictingName", data.name);
		},
		fixDescriptionField: function(data) {
			if (data.description && typeof data.description !== "string") {
				this.warn("nonStringDescription");
				delete data.description;
			}
			if (data.readme && !data.description) data.description = extractDescription(data.readme);
			if (data.description === void 0) delete data.description;
			if (!data.description) this.warn("missingDescription");
		},
		fixReadmeField: function(data) {
			if (!data.readme) {
				this.warn("missingReadme");
				data.readme = "ERROR: No README data found!";
			}
		},
		fixBugsField: function(data) {
			if (!data.bugs && data.repository && data.repository.url) {
				var hosted = hostedGitInfo.fromUrl(data.repository.url);
				if (hosted && hosted.bugs()) data.bugs = { url: hosted.bugs() };
			} else if (data.bugs) {
				if (typeof data.bugs === "string") if (isEmail(data.bugs)) data.bugs = { email: data.bugs };
				else if (URL$2.canParse(data.bugs)) data.bugs = { url: data.bugs };
				else this.warn("nonEmailUrlBugsString");
				else {
					bugsTypos(data.bugs, this.warn);
					var oldBugs = data.bugs;
					data.bugs = {};
					if (oldBugs.url) if (URL$2.canParse(oldBugs.url)) data.bugs.url = oldBugs.url;
					else this.warn("nonUrlBugsUrlField");
					if (oldBugs.email) if (typeof oldBugs.email === "string" && isEmail(oldBugs.email)) data.bugs.email = oldBugs.email;
					else this.warn("nonEmailBugsEmailField");
				}
				if (!data.bugs.email && !data.bugs.url) {
					delete data.bugs;
					this.warn("emptyNormalizedBugs");
				}
			}
		},
		fixHomepageField: function(data) {
			if (!data.homepage && data.repository && data.repository.url) {
				var hosted = hostedGitInfo.fromUrl(data.repository.url);
				if (hosted && hosted.docs()) data.homepage = hosted.docs();
			}
			if (!data.homepage) return;
			if (typeof data.homepage !== "string") {
				this.warn("nonUrlHomepage");
				return delete data.homepage;
			}
			if (!URL$2.canParse(data.homepage)) data.homepage = "http://" + data.homepage;
		},
		fixLicenseField: function(data) {
			const license = data.license || data.licence;
			if (!license) return this.warn("missingLicense");
			if (typeof license !== "string" || license.length < 1 || license.trim() === "") return this.warn("invalidLicense");
			if (!validateLicense(license).validForNewPackages) return this.warn("invalidLicense");
		}
	};
	function isValidScopedPackageName(spec) {
		if (spec.charAt(0) !== "@") return false;
		var rest = spec.slice(1).split("/");
		if (rest.length !== 2) return false;
		return rest[0] && rest[1] && rest[0] === encodeURIComponent(rest[0]) && rest[1] === encodeURIComponent(rest[1]);
	}
	function isCorrectlyEncodedName(spec) {
		return !spec.match(/[/@\s+%:]/) && spec === encodeURIComponent(spec);
	}
	function ensureValidName(name, strict, allowLegacyCase) {
		if (name.charAt(0) === "." || !(isValidScopedPackageName(name) || isCorrectlyEncodedName(name)) || strict && !allowLegacyCase && name !== name.toLowerCase() || name.toLowerCase() === "node_modules" || name.toLowerCase() === "favicon.ico") throw new Error("Invalid name: " + JSON.stringify(name));
	}
	function modifyPeople(data, fn) {
		if (data.author) data.author = fn(data.author);
		["maintainers", "contributors"].forEach(function(set) {
			if (!Array.isArray(data[set])) return;
			data[set] = data[set].map(fn);
		});
		return data;
	}
	function unParsePerson(person) {
		if (typeof person === "string") return person;
		var name = person.name || "";
		var u = person.url || person.web;
		var wrappedUrl = u ? " (" + u + ")" : "";
		var e = person.email || person.mail;
		return name + (e ? " <" + e + ">" : "") + wrappedUrl;
	}
	function parsePerson(person) {
		if (typeof person !== "string") return person;
		var matchedName = person.match(/^([^(<]+)/);
		var matchedUrl = person.match(/\(([^()]+)\)/);
		var matchedEmail = person.match(/<([^<>]+)>/);
		var obj = {};
		if (matchedName && matchedName[0].trim()) obj.name = matchedName[0].trim();
		if (matchedEmail) obj.email = matchedEmail[1];
		if (matchedUrl) obj.url = matchedUrl[1];
		return obj;
	}
	function addOptionalDepsToDeps(data) {
		var o = data.optionalDependencies;
		if (!o) return;
		var d = data.dependencies || {};
		Object.keys(o).forEach(function(k) {
			d[k] = o[k];
		});
		data.dependencies = d;
	}
	function depObjectify(deps, type, warn) {
		if (!deps) return {};
		if (typeof deps === "string") deps = deps.trim().split(/[\n\r\s\t ,]+/);
		if (!Array.isArray(deps)) return deps;
		warn("deprecatedArrayDependencies", type);
		var o = {};
		deps.filter(function(d) {
			return typeof d === "string";
		}).forEach(function(d) {
			d = d.trim().split(/(:?[@\s><=])/);
			var dn = d.shift();
			var dv = d.join("");
			dv = dv.trim();
			dv = dv.replace(/^@/, "");
			o[dn] = dv;
		});
		return o;
	}
	function objectifyDeps(data, warn) {
		depTypes.forEach(function(type) {
			if (!data[type]) return;
			data[type] = depObjectify(data[type], type, warn);
		});
	}
	function bugsTypos(bugs, warn) {
		if (!bugs) return;
		Object.keys(bugs).forEach(function(k) {
			if (typos.bugs[k]) {
				warn("typo", k, typos.bugs[k], "bugs");
				bugs[typos.bugs[k]] = bugs[k];
				delete bugs[k];
			}
		});
	}
	return fixer;
}
const require$$1 = {
	repositories: "'repositories' (plural) Not supported. Please pick one as the 'repository' field",
	missingRepository: "No repository field.",
	brokenGitUrl: "Probably broken git url: %s",
	nonObjectScripts: "scripts must be an object",
	nonStringScript: "script values must be string commands",
	nonArrayFiles: "Invalid 'files' member",
	invalidFilename: "Invalid filename in 'files' list: %s",
	nonArrayBundleDependencies: "Invalid 'bundleDependencies' list. Must be array of package names",
	nonStringBundleDependency: "Invalid bundleDependencies member: %s",
	nonDependencyBundleDependency: "Non-dependency in bundleDependencies: %s",
	nonObjectDependencies: "%s field must be an object",
	nonStringDependency: "Invalid dependency: %s %s",
	deprecatedArrayDependencies: "specifying %s as array is deprecated",
	deprecatedModules: "modules field is deprecated",
	nonArrayKeywords: "keywords should be an array of strings",
	nonStringKeyword: "keywords should be an array of strings",
	conflictingName: "%s is also the name of a node core module.",
	nonStringDescription: "'description' field should be a string",
	missingDescription: "No description",
	missingReadme: "No README data",
	missingLicense: "No license field.",
	nonEmailUrlBugsString: "Bug string field must be url, email, or {email,url}",
	nonUrlBugsUrlField: "bugs.url field must be a string url. Deleted.",
	nonEmailBugsEmailField: "bugs.email field must be a string email. Deleted.",
	emptyNormalizedBugs: "Normalized value of bugs field is an empty object. Deleted.",
	nonUrlHomepage: "homepage field must be a string url. Deleted.",
	invalidLicense: "license should be a valid SPDX license expression",
	typo: "%s should probably be %s."
};
var make_warning;
var hasRequiredMake_warning;
function requireMake_warning() {
	if (hasRequiredMake_warning) return make_warning;
	hasRequiredMake_warning = 1;
	var util = require$$0$1;
	var messages = require$$1;
	make_warning = function() {
		var args = Array.prototype.slice.call(arguments, 0);
		var warningName = args.shift();
		if (warningName === "typo") return makeTypoWarning.apply(null, args);
		else {
			var msgTemplate = messages[warningName] ? messages[warningName] : warningName + ": '%s'";
			args.unshift(msgTemplate);
			return util.format.apply(null, args);
		}
	};
	function makeTypoWarning(providedName, probableName, field) {
		if (field) {
			providedName = field + "['" + providedName + "']";
			probableName = field + "['" + probableName + "']";
		}
		return util.format(messages.typo, providedName, probableName);
	}
	return make_warning;
}
var normalize_1;
var hasRequiredNormalize;
function requireNormalize() {
	if (hasRequiredNormalize) return normalize_1;
	hasRequiredNormalize = 1;
	normalize_1 = normalize$1;
	var fixer$2 = requireFixer();
	normalize$1.fixer = fixer$2;
	var makeWarning = requireMake_warning();
	var fieldsToFix = [
		"name",
		"version",
		"description",
		"repository",
		"modules",
		"scripts",
		"files",
		"bin",
		"man",
		"bugs",
		"keywords",
		"readme",
		"homepage",
		"license"
	];
	var otherThingsToFix = [
		"dependencies",
		"people",
		"typos"
	];
	var thingsToFix = fieldsToFix.map(function(fieldName) {
		return ucFirst(fieldName) + "Field";
	});
	thingsToFix = thingsToFix.concat(otherThingsToFix);
	function normalize$1(data, warn, strict) {
		if (warn === true) {
			warn = null;
			strict = true;
		}
		if (!strict) strict = false;
		if (!warn || data.private) warn = function() {};
		if (data.scripts && data.scripts.install === "node-gyp rebuild" && !data.scripts.preinstall) data.gypfile = true;
		fixer$2.warn = function() {
			warn(makeWarning.apply(null, arguments));
		};
		thingsToFix.forEach(function(thingName) {
			fixer$2["fix" + ucFirst(thingName)](data, strict);
		});
		data._id = data.name + "@" + data.version;
	}
	function ucFirst(string) {
		return string.charAt(0).toUpperCase() + string.slice(1);
	}
	return normalize_1;
}
const normalizePackageData = getDefaultExportFromCjs(requireNormalize());
const handlePreserveConsecutiveUppercase = (decamelized, separator) => {
	decamelized = decamelized.replace(/((?<![\p{Uppercase_Letter}\d])[\p{Uppercase_Letter}\d](?![\p{Uppercase_Letter}\d]))/gu, ($0) => $0.toLowerCase());
	return decamelized.replace(/(?<!\p{Uppercase_Letter})(\p{Uppercase_Letter}+)(\p{Uppercase_Letter}\p{Lowercase_Letter}+)/gu, (_, $1, $2) => $1 + separator + $2.toLowerCase());
};
function decamelize(text, { separator = "_", preserveConsecutiveUppercase: preserveConsecutiveUppercase$1 = false } = {}) {
	if (!(typeof text === "string" && typeof separator === "string")) throw new TypeError("The `text` and `separator` arguments should be of type `string`");
	if (text.length < 2) return preserveConsecutiveUppercase$1 ? text : text.toLowerCase();
	const replacement = `$1${separator}$2`;
	const decamelized = text.replace(/([\p{Lowercase_Letter}\d])(\p{Uppercase_Letter})/gu, replacement);
	if (preserveConsecutiveUppercase$1) return handlePreserveConsecutiveUppercase(decamelized, separator);
	return decamelized.replace(/(\p{Uppercase_Letter})(\p{Uppercase_Letter}\p{Lowercase_Letter}+)/gu, replacement).toLowerCase();
}
var minimistOptions = { exports: {} };
var isPlainObj;
var hasRequiredIsPlainObj;
function requireIsPlainObj() {
	if (hasRequiredIsPlainObj) return isPlainObj;
	hasRequiredIsPlainObj = 1;
	var toString = Object.prototype.toString;
	isPlainObj = function(x) {
		var prototype;
		return toString.call(x) === "[object Object]" && (prototype = Object.getPrototypeOf(x), prototype === null || prototype === Object.getPrototypeOf({}));
	};
	return isPlainObj;
}
var arrify;
var hasRequiredArrify;
function requireArrify() {
	if (hasRequiredArrify) return arrify;
	hasRequiredArrify = 1;
	arrify = function(val) {
		if (val === null || val === void 0) return [];
		return Array.isArray(val) ? val : [val];
	};
	return arrify;
}
var kindOf;
var hasRequiredKindOf;
function requireKindOf() {
	if (hasRequiredKindOf) return kindOf;
	hasRequiredKindOf = 1;
	var toString = Object.prototype.toString;
	kindOf = function kindOf$1(val) {
		if (val === void 0) return "undefined";
		if (val === null) return "null";
		var type = typeof val;
		if (type === "boolean") return "boolean";
		if (type === "string") return "string";
		if (type === "number") return "number";
		if (type === "symbol") return "symbol";
		if (type === "function") return isGeneratorFn(val) ? "generatorfunction" : "function";
		if (isArray(val)) return "array";
		if (isBuffer(val)) return "buffer";
		if (isArguments(val)) return "arguments";
		if (isDate(val)) return "date";
		if (isError(val)) return "error";
		if (isRegexp(val)) return "regexp";
		switch (ctorName(val)) {
			case "Symbol": return "symbol";
			case "Promise": return "promise";
			case "WeakMap": return "weakmap";
			case "WeakSet": return "weakset";
			case "Map": return "map";
			case "Set": return "set";
			case "Int8Array": return "int8array";
			case "Uint8Array": return "uint8array";
			case "Uint8ClampedArray": return "uint8clampedarray";
			case "Int16Array": return "int16array";
			case "Uint16Array": return "uint16array";
			case "Int32Array": return "int32array";
			case "Uint32Array": return "uint32array";
			case "Float32Array": return "float32array";
			case "Float64Array": return "float64array";
		}
		if (isGeneratorObj(val)) return "generator";
		type = toString.call(val);
		switch (type) {
			case "[object Object]": return "object";
			case "[object Map Iterator]": return "mapiterator";
			case "[object Set Iterator]": return "setiterator";
			case "[object String Iterator]": return "stringiterator";
			case "[object Array Iterator]": return "arrayiterator";
		}
		return type.slice(8, -1).toLowerCase().replace(/\s/g, "");
	};
	function ctorName(val) {
		return typeof val.constructor === "function" ? val.constructor.name : null;
	}
	function isArray(val) {
		if (Array.isArray) return Array.isArray(val);
		return val instanceof Array;
	}
	function isError(val) {
		return val instanceof Error || typeof val.message === "string" && val.constructor && typeof val.constructor.stackTraceLimit === "number";
	}
	function isDate(val) {
		if (val instanceof Date) return true;
		return typeof val.toDateString === "function" && typeof val.getDate === "function" && typeof val.setDate === "function";
	}
	function isRegexp(val) {
		if (val instanceof RegExp) return true;
		return typeof val.flags === "string" && typeof val.ignoreCase === "boolean" && typeof val.multiline === "boolean" && typeof val.global === "boolean";
	}
	function isGeneratorFn(name, val) {
		return ctorName(name) === "GeneratorFunction";
	}
	function isGeneratorObj(val) {
		return typeof val.throw === "function" && typeof val.return === "function" && typeof val.next === "function";
	}
	function isArguments(val) {
		try {
			if (typeof val.length === "number" && typeof val.callee === "function") return true;
		} catch (err) {
			if (err.message.indexOf("callee") !== -1) return true;
		}
		return false;
	}
	function isBuffer(val) {
		if (val.constructor && typeof val.constructor.isBuffer === "function") return val.constructor.isBuffer(val);
		return false;
	}
	return kindOf;
}
var hasRequiredMinimistOptions;
function requireMinimistOptions() {
	if (hasRequiredMinimistOptions) return minimistOptions.exports;
	hasRequiredMinimistOptions = 1;
	const isPlainObject = requireIsPlainObj();
	const arrify$1 = requireArrify();
	const kindOf$1 = requireKindOf();
	const push$2 = (obj, prop, value) => {
		if (!obj[prop]) obj[prop] = [];
		obj[prop].push(value);
	};
	const insert = (obj, prop, key, value) => {
		if (!obj[prop]) obj[prop] = {};
		obj[prop][key] = value;
	};
	const prettyPrint = (output) => {
		return Array.isArray(output) ? `[${output.map(prettyPrint).join(", ")}]` : kindOf$1(output) === "string" ? JSON.stringify(output) : output;
	};
	const resolveType = (value) => {
		if (Array.isArray(value) && value.length > 0) {
			const [element] = value;
			return `${kindOf$1(element)}-array`;
		}
		return kindOf$1(value);
	};
	const normalizeExpectedType = (type, defaultValue) => {
		const inferredType = type === "array" ? "string-array" : type;
		if (arrayTypes.includes(inferredType) && Array.isArray(defaultValue) && defaultValue.length === 0) return "array";
		return inferredType;
	};
	const passthroughOptions = [
		"stopEarly",
		"unknown",
		"--"
	];
	const primitiveTypes = [
		"string",
		"boolean",
		"number"
	];
	const arrayTypes = primitiveTypes.map((t) => `${t}-array`);
	const availableTypes = [
		...primitiveTypes,
		"array",
		...arrayTypes
	];
	const buildOptions$1 = (options) => {
		options = options || {};
		const result = {};
		passthroughOptions.forEach((key) => {
			if (options[key]) result[key] = options[key];
		});
		Object.keys(options).forEach((key) => {
			let value = options[key];
			if (key === "arguments") key = "_";
			if (typeof value === "string") value = { type: value };
			if (isPlainObject(value)) {
				const props = value;
				const { type } = props;
				if (type) {
					if (!availableTypes.includes(type)) throw new TypeError(`Expected type of "${key}" to be one of ${prettyPrint(availableTypes)}, got ${prettyPrint(type)}`);
					if (arrayTypes.includes(type)) {
						const [elementType] = type.split("-");
						push$2(result, "array", {
							key,
							[elementType]: true
						});
					} else push$2(result, type, key);
				}
				if ({}.hasOwnProperty.call(props, "default")) {
					const { default: defaultValue } = props;
					const defaultType = resolveType(defaultValue);
					const expectedType = normalizeExpectedType(type, defaultValue);
					if (expectedType && expectedType !== defaultType) throw new TypeError(`Expected "${key}" default value to be of type "${expectedType}", got ${prettyPrint(defaultType)}`);
					insert(result, "default", key, defaultValue);
				}
				arrify$1(props.alias).forEach((alias) => {
					insert(result, "alias", alias, key);
				});
			}
		});
		return result;
	};
	minimistOptions.exports = buildOptions$1;
	minimistOptions.exports.default = buildOptions$1;
	return minimistOptions.exports;
}
const constructParserOptions = getDefaultExportFromCjs(requireMinimistOptions());
var mapObj = { exports: {} };
var hasRequiredMapObj;
function requireMapObj() {
	if (hasRequiredMapObj) return mapObj.exports;
	hasRequiredMapObj = 1;
	const isObject$3 = (value) => typeof value === "object" && value !== null;
	const mapObjectSkip$1 = Symbol("skip");
	const isObjectCustom$1 = (value) => isObject$3(value) && !(value instanceof RegExp) && !(value instanceof Error) && !(value instanceof Date);
	const mapObject$2 = (object, mapper, options, isSeen = /* @__PURE__ */ new WeakMap()) => {
		options = {
			deep: false,
			target: {},
			...options
		};
		if (isSeen.has(object)) return isSeen.get(object);
		isSeen.set(object, options.target);
		const { target } = options;
		delete options.target;
		const mapArray = (array) => array.map((element) => isObjectCustom$1(element) ? mapObject$2(element, mapper, options, isSeen) : element);
		if (Array.isArray(object)) return mapArray(object);
		for (const [key, value] of Object.entries(object)) {
			const mapResult = mapper(key, value, object);
			if (mapResult === mapObjectSkip$1) continue;
			let [newKey, newValue, { shouldRecurse = true } = {}] = mapResult;
			if (newKey === "__proto__") continue;
			if (options.deep && shouldRecurse && isObjectCustom$1(newValue)) newValue = Array.isArray(newValue) ? mapArray(newValue) : mapObject$2(newValue, mapper, options, isSeen);
			target[newKey] = newValue;
		}
		return target;
	};
	mapObj.exports = (object, mapper, options) => {
		if (!isObject$3(object)) throw new TypeError(`Expected an object, got \`${object}\` (${typeof object})`);
		return mapObject$2(object, mapper, options);
	};
	mapObj.exports.mapObjectSkip = mapObjectSkip$1;
	return mapObj.exports;
}
const mapObject = getDefaultExportFromCjs(requireMapObj());
var QuickLRU = class extends Map {
	constructor(options = {}) {
		super();
		if (!(options.maxSize && options.maxSize > 0)) throw new TypeError("`maxSize` must be a number greater than 0");
		if (typeof options.maxAge === "number" && options.maxAge === 0) throw new TypeError("`maxAge` must be a number greater than 0");
		this.maxSize = options.maxSize;
		this.maxAge = options.maxAge || Number.POSITIVE_INFINITY;
		this.onEviction = options.onEviction;
		this.cache = /* @__PURE__ */ new Map();
		this.oldCache = /* @__PURE__ */ new Map();
		this._size = 0;
	}
	_emitEvictions(cache$4) {
		if (typeof this.onEviction !== "function") return;
		for (const [key, item] of cache$4) this.onEviction(key, item.value);
	}
	_deleteIfExpired(key, item) {
		if (typeof item.expiry === "number" && item.expiry <= Date.now()) {
			if (typeof this.onEviction === "function") this.onEviction(key, item.value);
			return this.delete(key);
		}
		return false;
	}
	_getOrDeleteIfExpired(key, item) {
		if (this._deleteIfExpired(key, item) === false) return item.value;
	}
	_getItemValue(key, item) {
		return item.expiry ? this._getOrDeleteIfExpired(key, item) : item.value;
	}
	_peek(key, cache$4) {
		const item = cache$4.get(key);
		return this._getItemValue(key, item);
	}
	_set(key, value) {
		this.cache.set(key, value);
		this._size++;
		if (this._size >= this.maxSize) {
			this._size = 0;
			this._emitEvictions(this.oldCache);
			this.oldCache = this.cache;
			this.cache = /* @__PURE__ */ new Map();
		}
	}
	_moveToRecent(key, item) {
		this.oldCache.delete(key);
		this._set(key, item);
	}
	*_entriesAscending() {
		for (const item of this.oldCache) {
			const [key, value] = item;
			if (!this.cache.has(key)) {
				if (this._deleteIfExpired(key, value) === false) yield item;
			}
		}
		for (const item of this.cache) {
			const [key, value] = item;
			if (this._deleteIfExpired(key, value) === false) yield item;
		}
	}
	get(key) {
		if (this.cache.has(key)) {
			const item = this.cache.get(key);
			return this._getItemValue(key, item);
		}
		if (this.oldCache.has(key)) {
			const item = this.oldCache.get(key);
			if (this._deleteIfExpired(key, item) === false) {
				this._moveToRecent(key, item);
				return item.value;
			}
		}
	}
	set(key, value, { maxAge = this.maxAge } = {}) {
		const expiry = typeof maxAge === "number" && maxAge !== Number.POSITIVE_INFINITY ? Date.now() + maxAge : void 0;
		if (this.cache.has(key)) this.cache.set(key, {
			value,
			expiry
		});
		else this._set(key, {
			value,
			expiry
		});
		return this;
	}
	has(key) {
		if (this.cache.has(key)) return !this._deleteIfExpired(key, this.cache.get(key));
		if (this.oldCache.has(key)) return !this._deleteIfExpired(key, this.oldCache.get(key));
		return false;
	}
	peek(key) {
		if (this.cache.has(key)) return this._peek(key, this.cache);
		if (this.oldCache.has(key)) return this._peek(key, this.oldCache);
	}
	delete(key) {
		const deleted = this.cache.delete(key);
		if (deleted) this._size--;
		return this.oldCache.delete(key) || deleted;
	}
	clear() {
		this.cache.clear();
		this.oldCache.clear();
		this._size = 0;
	}
	resize(newSize) {
		if (!(newSize && newSize > 0)) throw new TypeError("`maxSize` must be a number greater than 0");
		const items = [...this._entriesAscending()];
		const removeCount = items.length - newSize;
		if (removeCount < 0) {
			this.cache = new Map(items);
			this.oldCache = /* @__PURE__ */ new Map();
			this._size = items.length;
		} else {
			if (removeCount > 0) this._emitEvictions(items.slice(0, removeCount));
			this.oldCache = new Map(items.slice(removeCount));
			this.cache = /* @__PURE__ */ new Map();
			this._size = 0;
		}
		this.maxSize = newSize;
	}
	*keys() {
		for (const [key] of this) yield key;
	}
	*values() {
		for (const [, value] of this) yield value;
	}
	*[Symbol.iterator]() {
		for (const item of this.cache) {
			const [key, value] = item;
			if (this._deleteIfExpired(key, value) === false) yield [key, value.value];
		}
		for (const item of this.oldCache) {
			const [key, value] = item;
			if (!this.cache.has(key)) {
				if (this._deleteIfExpired(key, value) === false) yield [key, value.value];
			}
		}
	}
	*entriesDescending() {
		let items = [...this.cache];
		for (let i = items.length - 1; i >= 0; --i) {
			const [key, value] = items[i];
			if (this._deleteIfExpired(key, value) === false) yield [key, value.value];
		}
		items = [...this.oldCache];
		for (let i = items.length - 1; i >= 0; --i) {
			const [key, value] = items[i];
			if (!this.cache.has(key)) {
				if (this._deleteIfExpired(key, value) === false) yield [key, value.value];
			}
		}
	}
	*entriesAscending() {
		for (const [key, value] of this._entriesAscending()) yield [key, value.value];
	}
	get size() {
		if (!this._size) return this.oldCache.size;
		let oldCacheSize = 0;
		for (const key of this.oldCache.keys()) if (!this.cache.has(key)) oldCacheSize++;
		return Math.min(this._size + oldCacheSize, this.maxSize);
	}
	entries() {
		return this.entriesAscending();
	}
	forEach(callbackFunction, thisArgument = this) {
		for (const [key, value] of this.entriesAscending()) callbackFunction.call(thisArgument, value, key, this);
	}
	get [Symbol.toStringTag]() {
		return JSON.stringify([...this.entriesAscending()]);
	}
};
const has = (array, key) => array.some((element) => {
	if (typeof element === "string") return element === key;
	element.lastIndex = 0;
	return element.test(key);
});
const cache = new QuickLRU({ maxSize: 1e5 });
const isObject = (value) => typeof value === "object" && value !== null && !(value instanceof RegExp) && !(value instanceof Error) && !(value instanceof Date);
const transform = (input, options = {}) => {
	if (!isObject(input)) return input;
	const { separator = "_", exclude, deep = false } = options;
	const makeMapper = (parentPath) => (key, value) => {
		if (deep && isObject(value)) value = mapObject(value, makeMapper());
		if (!(exclude && has(exclude, key))) {
			const cacheKey = `${separator}${key}`;
			if (cache.has(cacheKey)) key = cache.get(cacheKey);
			else {
				const returnValue = decamelize(key, { separator });
				if (key.length < 100) cache.set(cacheKey, returnValue);
				key = returnValue;
			}
		}
		return [key, value];
	};
	return mapObject(input, makeMapper());
};
function decamelizeKeys(input, options) {
	if (Array.isArray(input)) return Object.keys(input).map((key) => transform(input[key], options));
	return transform(input, options);
}

//#endregion
//#region node_modules/meow/build/utils.js
const decamelizeFlagKey = (flagKey) => `--${decamelize(flagKey, { separator: "-" })}`;
const joinFlagKeys = (flagKeys, prefix = "--") => `\`${prefix}${flagKeys.join(`\`, \`${prefix}`)}\``;

//#endregion
//#region node_modules/meow/build/options.js
const validateOptions = (options) => {
	const invalidOptionFilters = { flags: {
		keyContainsDashes: {
			filter: ([flagKey]) => flagKey.includes("-") && flagKey !== "--",
			message: (flagKeys) => `Flag keys may not contain '-'. Invalid flags: ${joinFlagKeys(flagKeys, "")}`
		},
		aliasIsSet: {
			filter: ([, flag]) => Object.hasOwn(flag, "alias"),
			message: (flagKeys) => `The option \`alias\` has been renamed to \`shortFlag\`. The following flags need to be updated: ${joinFlagKeys(flagKeys)}`
		},
		choicesNotAnArray: {
			filter: ([, flag]) => Object.hasOwn(flag, "choices") && !Array.isArray(flag.choices),
			message: (flagKeys) => `The option \`choices\` must be an array. Invalid flags: ${joinFlagKeys(flagKeys)}`
		},
		choicesNotMatchFlagType: {
			filter: ([, flag]) => flag.type && Array.isArray(flag.choices) && flag.choices.some((choice) => typeof choice !== flag.type),
			message(flagKeys) {
				return `Each value of the option \`choices\` must be of the same type as its flag. Invalid flags: ${flagKeys.map((flagKey) => `(\`${decamelizeFlagKey(flagKey)}\`, type: '${options.flags[flagKey].type}')`).join(", ")}`;
			}
		},
		defaultNotInChoices: {
			filter: ([, flag]) => flag.default && Array.isArray(flag.choices) && ![flag.default].flat().every((value) => flag.choices.includes(value)),
			message: (flagKeys) => `Each value of the option \`default\` must exist within the option \`choices\`. Invalid flags: ${joinFlagKeys(flagKeys)}`
		}
	} };
	const errorMessages = [];
	for (const [optionKey, filters] of Object.entries(invalidOptionFilters)) {
		const optionEntries = Object.entries(options[optionKey]);
		for (const { filter, message } of Object.values(filters)) {
			const invalidOptions = optionEntries.filter((option) => filter(option));
			const invalidOptionKeys = invalidOptions.map(([key]) => key);
			if (invalidOptions.length > 0) errorMessages.push(message(invalidOptionKeys));
		}
	}
	if (errorMessages.length > 0) throw new Error(errorMessages.join("\n"));
};
const buildOptions = (helpText, options) => {
	if (typeof helpText !== "string") {
		options = helpText;
		helpText = "";
	}
	if (!options.importMeta?.url) throw new TypeError("The `importMeta` option is required. Its value must be `import.meta`.");
	const pkg = options.pkg ?? readPackageUpSync({
		cwd: path.dirname(fileURLToPath(options.importMeta.url)),
		normalize: false
	})?.packageJson ?? {};
	normalizePackageData(pkg);
	const parsedOptions = {
		argv: process$1.argv.slice(2),
		flags: {},
		inferType: false,
		input: "string",
		description: pkg.description ?? false,
		help: helpText,
		version: pkg.version || "No version found",
		autoHelp: true,
		autoVersion: true,
		booleanDefault: false,
		allowUnknownFlags: true,
		allowParentFlags: true,
		helpIndent: 2,
		...options,
		pkg
	};
	validateOptions(parsedOptions);
	return parsedOptions;
};

//#endregion
//#region node_modules/meow/build/parser.js
const buildParserFlags = ({ flags, booleanDefault }) => {
	const parserFlags = {};
	for (const [flagKey, flagValue] of Object.entries(flags)) {
		const flag = { ...flagValue };
		if (flag.shortFlag) {
			flag.alias = flag.shortFlag;
			delete flag.shortFlag;
		}
		if (booleanDefault !== void 0 && flag.type === "boolean" && !Object.hasOwn(flag, "default")) flag.default = flag.isMultiple ? [booleanDefault] : booleanDefault;
		if (flag.isMultiple) {
			flag.type = flag.type ? `${flag.type}-array` : "array";
			flag.default ??= [];
			delete flag.isMultiple;
		}
		if (Array.isArray(flag.aliases)) {
			if (flag.alias) flag.aliases.push(flag.alias);
			flag.alias = flag.aliases;
			delete flag.aliases;
		}
		parserFlags[flagKey] = flag;
	}
	return parserFlags;
};
const buildParserOptions = (options) => {
	let parserOptions = buildParserFlags(options);
	parserOptions.arguments = options.input;
	parserOptions = decamelizeKeys(parserOptions, {
		separator: "-",
		exclude: ["stopEarly", "--"]
	});
	if (options.inferType) delete parserOptions.arguments;
	if (!options.allowUnknownFlags) {
		if (options.autoHelp && !parserOptions.help) parserOptions.help = { type: "boolean" };
		if (options.autoVersion && !parserOptions.version) parserOptions.version = { type: "boolean" };
	}
	parserOptions = constructParserOptions(parserOptions);
	parserOptions.configuration = {
		...parserOptions.configuration,
		"greedy-arrays": false,
		"parse-numbers": options.inferType
	};
	if (parserOptions["--"]) parserOptions.configuration["populate--"] = true;
	if (!options.allowUnknownFlags) parserOptions.configuration["unknown-options-as-args"] = true;
	return parserOptions;
};

//#endregion
//#region node_modules/meow/build/validate.js
const validateFlags = (flags, options) => {
	for (const [flagKey, flagValue] of Object.entries(options.flags)) if (flagKey !== "--" && !flagValue.isMultiple && Array.isArray(flags[flagKey])) throw new Error(`The flag --${flagKey} can only be set once.`);
};
const validateChoicesByFlag = (flagKey, flagValue, receivedInput) => {
	const { choices, isRequired } = flagValue;
	if (!choices) return;
	const valueMustBeOneOf = `Value must be one of: [\`${choices.join("`, `")}\`]`;
	if (!receivedInput) {
		if (isRequired) return `Flag \`${decamelizeFlagKey(flagKey)}\` has no value. ${valueMustBeOneOf}`;
		return;
	}
	if (Array.isArray(receivedInput)) {
		const unknownValues = receivedInput.filter((index) => !choices.includes(index));
		if (unknownValues.length > 0) return `Unknown ${unknownValues.length > 1 ? "values" : "value"} for flag \`${decamelizeFlagKey(flagKey)}\`: \`${unknownValues.join("`, `")}\`. ${valueMustBeOneOf}`;
	} else if (!choices.includes(receivedInput)) return `Unknown value for flag \`${decamelizeFlagKey(flagKey)}\`: \`${receivedInput}\`. ${valueMustBeOneOf}`;
};
const validateChoices = (flags, receivedFlags) => {
	const errors = [];
	for (const [flagKey, flagValue] of Object.entries(flags)) {
		const receivedInput = receivedFlags[flagKey];
		const errorMessage = validateChoicesByFlag(flagKey, flagValue, receivedInput);
		if (errorMessage) errors.push(errorMessage);
	}
	if (errors.length > 0) throw new Error(`${errors.join("\n")}`);
};
const validate = (flags, options) => {
	validateFlags(flags, options);
	validateChoices(options.flags, flags);
};
const reportUnknownFlags = (unknownFlags) => {
	console.error([`Unknown flag${unknownFlags.length > 1 ? "s" : ""}`, ...unknownFlags].join("\n"));
};
const checkUnknownFlags = (input) => {
	const unknownFlags = input.filter((item) => typeof item === "string" && item.startsWith("-"));
	if (unknownFlags.length > 0) {
		reportUnknownFlags(unknownFlags);
		process$1.exit(2);
	}
};
const isFlagMissing = (flagName, definedFlags, receivedFlags, input) => {
	const flag = definedFlags[flagName];
	let isFlagRequired = true;
	if (typeof flag.isRequired === "function") {
		isFlagRequired = flag.isRequired(receivedFlags, input);
		if (typeof isFlagRequired !== "boolean") throw new TypeError(`Return value for isRequired callback should be of type boolean, but ${typeof isFlagRequired} was returned.`);
	}
	if (receivedFlags[flagName] === void 0) return isFlagRequired;
	return flag.isMultiple && receivedFlags[flagName].length === 0 && isFlagRequired;
};
const reportMissingRequiredFlags = (missingRequiredFlags) => {
	console.error(`Missing required flag${missingRequiredFlags.length > 1 ? "s" : ""}`);
	for (const flag of missingRequiredFlags) console.error(`\t${decamelizeFlagKey(flag.key)}${flag.shortFlag ? `, -${flag.shortFlag}` : ""}`);
};
const checkMissingRequiredFlags = (flags, receivedFlags, input) => {
	const missingRequiredFlags = [];
	if (flags === void 0) return [];
	for (const flagName of Object.keys(flags)) if (flags[flagName].isRequired && isFlagMissing(flagName, flags, receivedFlags, input)) missingRequiredFlags.push({
		key: flagName,
		...flags[flagName]
	});
	if (missingRequiredFlags.length > 0) {
		reportMissingRequiredFlags(missingRequiredFlags);
		process$1.exit(2);
	}
};

//#endregion
//#region node_modules/meow/build/index.js
const buildResult = ({ pkg: packageJson,...options }, parserOptions) => {
	const argv$1 = yargsParser(options.argv, parserOptions);
	let help = "";
	if (options.help) {
		help = trimNewlines((options.help || "").replace(/\t+\n*$/, ""));
		if (help.includes("\n")) help = redent(help, options.helpIndent);
		help = `\n${help}`;
	}
	if (options.description !== false) {
		let { description } = options;
		if (description) {
			description = help ? redent(`\n${description}\n`, options.helpIndent) : `\n${description}`;
			help = `${description}${help}`;
		}
	}
	help += "\n";
	const showHelp = (code) => {
		console.log(help);
		process$1.exit(typeof code === "number" ? code : 2);
	};
	const showVersion = () => {
		console.log(options.version);
		process$1.exit(0);
	};
	if (argv$1._.length === 0 && options.argv.length === 1) {
		if (argv$1.version === true && options.autoVersion) showVersion();
		else if (argv$1.help === true && options.autoHelp) showHelp(0);
	}
	const input = argv$1._;
	delete argv$1._;
	if (!options.allowUnknownFlags) checkUnknownFlags(input);
	const flags = camelcaseKeys(argv$1, { exclude: ["--", /^\w$/] });
	const unnormalizedFlags = { ...flags };
	validate(flags, options);
	for (const flagValue of Object.values(options.flags)) {
		if (Array.isArray(flagValue.aliases)) for (const alias of flagValue.aliases) delete flags[alias];
		delete flags[flagValue.shortFlag];
	}
	checkMissingRequiredFlags(options.flags, flags, input);
	return {
		input,
		flags,
		unnormalizedFlags,
		pkg: packageJson,
		help,
		showHelp,
		showVersion
	};
};
const meow = (helpText, options = {}) => {
	const parsedOptions = buildOptions(helpText, options);
	const result = buildResult(parsedOptions, buildParserOptions(parsedOptions));
	process$1.title = result.pkg.bin ? Object.keys(result.pkg.bin).at(0) : result.pkg.name;
	return result;
};

//#endregion
//#region src/cli/args.ts
/**
* CLI
*
* @param argv - 
* @returns 
*/
function parseCliArgs(argv$1) {
	const cli = meow(`
    Usage
      $ chrome-remote-debug --url <url> --profile <name>

    Options
      --url <string>           URLhttp/https
      --profile <string>        + -_
      --port <number>          1024-65535
      --chrome-path <string>   Chrome
      --additional-args <string> Chrome

    Examples
      $ chrome-remote-debug --url https://example.com --profile dev-login
      $ chrome-remote-debug --url https://staging.example.com --profile qa --port 9223
  `, {
		importMeta: import.meta,
		argv: argv$1,
		flags: {
			url: {
				type: "string",
				isRequired: true
			},
			profile: {
				type: "string",
				isRequired: true
			},
			port: { type: "number" },
			chromePath: { type: "string" },
			additionalArgs: { type: "string" }
		}
	});
	return {
		url: cli.flags.url,
		profile: cli.flags.profile,
		...cli.flags.port !== void 0 && { port: cli.flags.port },
		...cli.flags.chromePath !== void 0 && { chromePath: cli.flags.chromePath },
		...cli.flags.additionalArgs !== void 0 && { additionalArgs: cli.flags.additionalArgs.split(",").map((arg) => arg.trim()) }
	};
}

//#endregion
//#region src/cli.tsx
render_default(/* @__PURE__ */ (0, import_jsx_runtime.jsx)(App, { args: parseCliArgs(argv.slice(2)) }));

//#endregion
export {  };